<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Golang 常问知识点(简略) - ChnMig的个人网站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ChnMig的个人网站"><meta name="msapplication-TileImage" content="/images/logo.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ChnMig的个人网站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="记录一下面试常问的知识点吧"><meta property="og:type" content="blog"><meta property="og:title" content="Golang 常问知识点(简略)"><meta property="og:url" content="https://www.chnmig.com/2022/01/20/go_interview/"><meta property="og:site_name" content="ChnMig的个人网站"><meta property="og:description" content="记录一下面试常问的知识点吧"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f4af.png?v8"><meta property="article:published_time" content="2022-01-19T16:00:00.000Z"><meta property="article:modified_time" content="2022-01-19T16:00:00.000Z"><meta property="article:author" content="ChnMig"><meta property="article:tag" content="Golang"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://github.githubassets.com/images/icons/emoji/unicode/1f4af.png?v8"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.chnmig.com/2022/01/20/go_interview/"},"headline":"Golang 常问知识点(简略)","image":[],"datePublished":"2022-01-19T16:00:00.000Z","dateModified":"2022-01-19T16:00:00.000Z","author":{"@type":"Person","name":"ChnMig"},"publisher":{"@type":"Organization","name":"ChnMig的个人网站","logo":{"@type":"ImageObject","url":"https://www.chnmig.com/images/logo.gif"}},"description":"记录一下面试常问的知识点吧"}</script><link rel="canonical" href="https://www.chnmig.com/2022/01/20/go_interview/"><link rel="icon" href="/images/logo.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?8c2572cbfe4082d1fcd1327e4614cf34";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><meta name="generator" content="Hexo 6.1.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">类别</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://tongji.baidu.com/web/welcome/ico?s=8c2572cbfe4082d1fcd1327e4614cf34">访问统计</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-01-19T16:00:00.000Z" title="2022/1/20 00:00:00">2022-01-20</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span><span class="level-item">39 分钟读完 (大约5862个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Golang 常问知识点(简略)</h1><div class="content"><h2 id="前言-6">前言</h2>
<p>稍微记录一下问题点吧, 文章会不断的优化更新</p>
<p>有些比较大的知识点, 比如锁原理啥的, 会单独拎出来写一篇, 这里只是大概</p>
<h2 id="Go-语言的基础数据类型占用大小">Go 语言的基础数据类型占用大小</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小(字节)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8</td>
<td>1</td>
</tr>
<tr>
<td>Int16</td>
<td>2</td>
</tr>
<tr>
<td>Int32</td>
<td>4</td>
</tr>
<tr>
<td>Int64</td>
<td>8</td>
</tr>
<tr>
<td>int</td>
<td>4/8</td>
</tr>
<tr>
<td>Float32</td>
<td>4</td>
</tr>
<tr>
<td>Float64</td>
<td>8</td>
</tr>
<tr>
<td>string</td>
<td>1/2~4</td>
</tr>
<tr>
<td>bool</td>
<td>1</td>
</tr>
</tbody>
</table>
<h2 id="Go-语言的变量分配在栈还是堆">Go 语言的变量分配在栈还是堆</h2>
<p><a target="_blank" rel="noopener" href="https://go.dev/doc/faq#stack_or_heap">Frequently Asked Questions (FAQ) - The Go Programming Language</a></p>
<p>引用类型, 比如 切片,map 是堆</p>
<p>对于函数内部的变量, 其分配规则由编译器自己决定, 规则如下:</p>
<p>编译器会进行变量的逃逸分析. 当某个变量在函数外也使用时, 作用域不仅仅在函数内时, 比如 return 出变量的值的地址, 这种情况就会把数据分配到堆中.</p>
<p>此外, 如果某个变量的值很大的时候, 也会分配到堆中.</p>
<p>其他正常情况, 函数内的变量都在栈中</p>
<h2 id="select是随机还是顺序">select是随机还是顺序</h2>
<p><a target="_blank" rel="noopener" href="https://www.reddit.com/r/golang/comments/4ibs68/why_is_the_select_statement_nondeterministic/">Why is the select statement non-deterministic? : golang (reddit.com)</a></p>
<p>是随机的</p>
<p>在 select 的执行函数<code>selectgo</code>中, 会先将 case 的顺序打乱</p>
<p>据说是为了保持均衡, 不出现比如总是命中第一个 case, 导致其他下面的 case 完全不执行的情况, 尤其是 select 还通常用来监听多个 channel</p>
<h2 id="Go-语言的垃圾回收">Go 语言的垃圾回收</h2>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/12544c0ad5c1">三色标记法与读写屏障 - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://legendtkl.com/2017/04/28/golang-gc/">Golang 垃圾回收剖析 | Legendtkl</a></p>
<h3 id="什么时候进行垃圾回收">什么时候进行垃圾回收</h3>
<ul>
<li>调用 runtime.GC() 进行主动垃圾回收(主动)</li>
<li>当堆上的活跃对象大于 4M(默认) 的时候进行 GC</li>
<li>上次 GC 的2分钟后</li>
<li>当前没有开启 GC 的时候</li>
</ul>
<h3 id="标记-GC">标记 GC</h3>
<p>go 语言使用的是三色标记法</p>
<p>他有三种颜色(标记):</p>
<ul>
<li>白色代表还未访问过</li>
<li>灰色代表对象已经访问过, 但是本对象引用到的其他对象没有访问完</li>
<li>黑色代表对象和引用到的其他对象都已经访问完</li>
</ul>
<p>1.初始时，所有对象都在 【白色集合】中；</p>
<p>2.将GC Roots 直接引用到的对象 挪到 【灰色集合】中；</p>
<p>3.从灰色集合中获取对象：<br>
3.1.  将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；<br>
3.2.  将本对象 挪到 【黑色集合】里面。</p>
<p>4.重复步骤3，直至【灰色集合】为空时结束。</p>
<p>5.结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。</p>
<p>当 CG 过程中, 新增了变量, 或者手动把变量的值设置成 nil,  默认把他设置成黑色, 留给下一次 GC 再处理</p>
<h2 id="Go-协程">Go 协程</h2>
<p><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">Go 语言调度器与 Goroutine 实现原理 | Go 语言设计与实现 (draveness.me)</a></p>
<p>Go 在启动的时候会根据硬件的状态占用对应的进程和线程(默认1核1个), 然后通过内部的调度器来进行协程的切换, 减少操作系统和硬件的负载.</p>
<p>从 1.14 版本开始, 使用的是抢占式调度.</p>
<p>调度器由 3 个部分组成, GMP 模型说的就是这个</p>
<ul>
<li>G - goroutine, 就是需要执行的任务, 包含了任务的执行函数, goroutine 状态和一些信息</li>
<li>M - 操作系统的线程, 这个是由操作系统进行调度和管理, 这里是真正执行计算的部分</li>
<li>P - 调度器的逻辑. 存放线程 M 执行的上下文</li>
</ul>
<p><strong>G</strong></p>
<p>G 里包含了需要执行的任务, 是 Go 给用户态提供的类似线程的东西, 只是因为是自己维护的, 可以做到更小的占用内存空间, 同时降低了上下文切换的开销</p>
<p><strong>M</strong></p>
<p>M 是真正的操作系统线程, 比如说 4 核, 就会有 4 个线程, 但是我们可以启动很多 goroutine, 而调度器帮助我们把这些 goroutine 落到线程中, 开发者感觉到 goroutine 是并行, 实际上是调度器将其进行排队后放到线程里运行</p>
<p><strong>P</strong></p>
<p>P 是联通 G 和 M 的中间层他会去将若干个 goroutine 进行排队和调度, 比如说在某一个 goroutine 进行 I/O 操作时让出资源给另一个 G</p>
<h2 id="GMP-优势-相比多线程开发">GMP 优势(相比多线程开发)</h2>
<ul>
<li>goroutine 更加轻量(2kb), 线程1~2M</li>
<li>切换更加的快速, 减少内核切换的资源消耗</li>
</ul>
<h2 id="GMP-中-G-的状态">GMP 中 G 的状态</h2>
<ul>
<li>空闲(Gidle): 刚新建, 未初始化</li>
<li>等待运行(Grunnable): 在队列中等待运行</li>
<li>运行中(Grunning): 表示操作系统线程 M 正在运行这个 G</li>
<li>系统调用中(Gsyscall): M 正在运行这个 G 发起的系统调用, 此时 M 并不拥有 G</li>
<li>等待中(Gwaiting): G 正在等待某些东西完成, 这时候 G 没有运行也不在运行队列中</li>
<li>已终止(Gdead): G 没有被使用, 可能已经执行完毕</li>
<li>栈复制中(Gcopystack): G正在获取新的栈空间并且把原有数据复制进去(防止 GC 清理)</li>
</ul>
<h2 id="GMP-中-M-的状态">GMP 中 M 的状态</h2>
<ul>
<li>自旋中: M 正在从运行队列中获取 G</li>
<li>执行 Go 代码中: 正在运行 G</li>
<li>执行原生代码中: 正在运行 G 的 syscall</li>
<li>休眠中: 没有 G 时进行休眠</li>
</ul>
<h2 id="GMP-中-P-的状态">GMP 中 P 的状态</h2>
<ul>
<li>空闲中: M 没有 G 需要运行时, P 空闲</li>
<li>运行中: M 正在运行 G</li>
<li>系统调用中: G 正在 syscall</li>
<li>GC 停止中: GC 导致整个世界停止</li>
<li>终止: 多余的 P 会终止</li>
</ul>
<h2 id="GMP-抢占式调度">GMP 抢占式调度</h2>
<p>有一个额外的线程M进行死循环, 去检查 G 的运行时间, 如果超过10ms, 则去抢占这个 G 使用的 P, 交给其他的 G 使用</p>
<p>通知 G 停止使用的是信号协作</p>
<h2 id="Go-两个结构体生成的对象能不能相互比较">Go 两个结构体生成的对象能不能相互比较</h2>
<p>同一个结构体生成的对象可以相互比较</p>
<p>不同的如果结构和顺序完全一致也可以</p>
<h2 id="Go-的-context">Go 的 context</h2>
<p><a href="https://www.chnmig.com/2021/10/16/go_context">go语言的context - ChnMig的个人网站</a></p>
<p>context 主要是为了控制 goroutine 的生命周期, ctx 传进去之后 select 监听 Done 信号就行</p>
<p>另外 redis 包等一些包在调用时需要传入ctx 参数, 一般使用 TODO</p>
<p>context有四种, 分别是:</p>
<ul>
<li><code>WithCancel</code> 需要手动的出发<code>Done</code>才会取消</li>
<li><code>WithDeadline</code> 指定一个终止时间(明确的时间), 当时间到就自动取消</li>
<li><code>WithTimeout</code> 指定一个终止时间间隔, 当时间间隔到时自动取消</li>
<li><code>WithValue</code> 这个目的不是取消, 而是上下文之间的数据传输</li>
</ul>
<p>context 内有一个 channel, 当需要关闭时, 向这个 channel 发送数据通知关闭</p>
<h2 id="interface">interface</h2>
<p>interface 虽然说可以放进任意的数据, 比如说一个切片的 value 是 interface 类型, 但是放进去之后就变成了 interface 类型, 即使拿出来还要通过断言来转, 所以基本不用</p>
<p>用接口的稍微多一些, 比如统一的推送接口, 让钉钉包和邮件包都实现这个接口, 然后需要发送时 for 这几个对象, 调用接口即可</p>
<h2 id="goroutine-控制">goroutine 控制</h2>
<p>wg 来进行夯住整个程序操作, <code>Add</code>之后<code>Done</code>进行夯住程序结束</p>
<p>使用 context 生成 ctx, 监听 Done 队列可以在外层进行通知关闭, goroutine 内进行关闭操作, 主动退出</p>
<h2 id="堆和栈">堆和栈</h2>
<p><a target="_blank" rel="noopener" href="https://driverzhang.github.io/post/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">Golang内存分配逃逸分析 (driverzhang.github.io)</a></p>
<p><strong>分配规则</strong></p>
<ul>
<li>
<p>栈存放占用小的数据, 栈先进先出, 而且栈在分配时必须要指定长度</p>
</li>
<li>
<p>当在函数内部申请栈的内存时, 当函数结束, 栈内存会直接释放而不通过 GC, 不会影响性能</p>
</li>
<li>
<p>当函数内部的变量, 作为返回值返回了, 也就是说其作用域不仅仅在函数内部, 那么即使占用小还是会分配到堆上, 引起 GC</p>
</li>
<li>
<p>如果申请的内存比较大, 比如长度为20000的切片, 即使作用域只在内部, 也会申请到堆上</p>
</li>
<li>
<p>对于在编译时不能确定长度的数据, 也会分配到堆上</p>
</li>
</ul>
<p><strong>逃逸分析</strong></p>
<p>决定分配到堆还是栈的不是开发者而是 go 的编译器, 当编译器检测到某个变量会发生逃逸, 就一定会存放到堆上</p>
<ul>
<li>指针逃逸: 函数返回局部变量的指针时</li>
<li>栈空间不足: 局部变量的数据长度过大时</li>
<li>动态类型逃逸: 函数的参数为 interface 这种, 编译器无法确认大小时</li>
<li>闭包引用对象逃逸: 变量被闭包引用时</li>
</ul>
<h2 id="优雅的结束程序">优雅的结束程序</h2>
<p>设置一个管道监听强制结束的 os 信号, 同时设置 defer 的 ctx</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel() <span class="comment">// 关闭管道</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(c, os.Interrupt)</span><br><span class="line">&lt;-c</span><br></pre></td></tr></tbody></table></figure>
<h2 id="CSP-并发模型">CSP 并发模型</h2>
<blockquote>
<p>不要以共享内存的方式来通信, 相反, 要通过通信来共享内存</p>
</blockquote>
<p>例如<code>Python</code>, <code>Java</code>这种语言, 他们一般使用线程进行并发, 因为都是属于一个进程, 所以通过共享的内存来进行通信, 比如说如何控制关闭<code>python</code>下的某一个线程, 更安全的做法可能是维护一个字典保存对应状态, 让每个线程去获取字典来判断是否需要停止, 这种通过共享内存的方式进行通信, 要考虑一些问题</p>
<p>例如数据读写抢占问题, 比如<code>Python</code>在必要的时候会加一个锁来防止资源竞争, 这样其实就提高了编写时的逻辑复杂度, 因为你要考虑到死锁的可能性</p>
<p>而对于<code>Golang</code>来讲, 他使用 GMP 模型给开发者包装成了<code>goroutine</code>, 让开发者能很容易的启用并发, 而对于每个 <code>goroutine</code>之间的通信, <code>Golang</code>推荐使用<code>channel</code>管道来处理, 而不是共享内存</p>
<p>一般的, 逻辑可以抽象成流水式, 可能中间的某一步, 需要通过并发的方式来提高效率, 然后到某一步的时候, 又需要进行流控, 比如说数据的入库等, 使用共享内存的方式, 可能是向同一个变量存储数据, 而在<code>Golang</code>中, 我们就可以让并发的那一步数据向<code>channel</code>里发送, 而下一步从<code>channel</code>中读取, 从而进行流控</p>
<h2 id="锁-2">锁</h2>
<p>当代码中确实可能存在多个<code>goroutine</code>试图修改同一个数据时, 就需要加锁, 锁分为两种</p>
<h3 id="互斥锁-2">互斥锁</h3>
<p>互斥锁在被占用后, 其他协程完全无法访问, 不可读更不可写</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁, 占用后不可读也不可写</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line">lock.Lock()  <span class="comment">// 加锁</span></span><br><span class="line">lock.Unlock()  <span class="comment">// 解锁</span></span><br></pre></td></tr></tbody></table></figure>
<p>互斥锁内部使用信号量+自旋的方式来进行锁的处理</p>
<h3 id="读写锁">读写锁</h3>
<p>读写互斥锁可以添加两种锁, 读锁和写锁, 在读锁上锁时其他协程可读不可写, 写锁上锁时其他协程不可写不可读</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写互斥锁</span></span><br><span class="line"><span class="keyword">var</span> rwlock sync.RWMutex</span><br><span class="line">rwlock.RLock()  <span class="comment">// 读锁, 此时其他协程不可写, 不可读</span></span><br><span class="line">rwlock.RUnlock()</span><br><span class="line"></span><br><span class="line">rwlock.Lock()  <span class="comment">// 写锁, 此时其他协程无法写, 可以读</span></span><br><span class="line">rwlock.Unlock() </span><br></pre></td></tr></tbody></table></figure>
<p>读写锁中写锁为互斥锁, 而读锁就是一个数字, 因为其并不互斥, 只是在加写锁时有用</p>
<h2 id="单例">单例</h2>
<p>在很多时候, 我们需要保证某个操作只执行一次, 例如生成配置文件, 你可能把他包装成一个模块让别人使用, 而你无法控制使用者只调用一次你的读取函数, 有一种方法是在内部生成对象, 在调用读取函数时先查看是否为<code>nil</code>, 你也可以使用 <code>sync.Once</code></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> config *Config</span><br><span class="line"><span class="keyword">var</span> once sync.Once  <span class="comment">// 生成只执行一次的"锁"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitConfig</span><span class="params">()</span></span> *Config {</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> {  <span class="comment">// Do 接收一个函数</span></span><br><span class="line">        config = &amp;Config{}  <span class="comment">// 在函数内进行初始化</span></span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> config  <span class="comment">// 返回</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>sync.Once</code>内部包含了一个互斥锁和一个布尔值, 互斥锁保证了在第一次执行时不会有抢占, 布尔值保证了只会执行一次</p>
<h2 id="map-并发">map 并发</h2>
<p>在多个<code>goroutine</code> 操控同一个 map 时, 可能会出现并发数据争抢问题, 官方为我们提供了<code>sync.Map</code>, 是并发安全的, 使用时不需要 make, 他是并发安全的</p>
<p><code>sync.map</code>生成的 map 有以下几种方法</p>
<ul>
<li>store: 更新/插入</li>
<li>load: 获取</li>
<li>delete: 删除</li>
<li>loadOrStore: 有则返回, 没有则插入</li>
<li>range: 遍历输出</li>
</ul>
<p><code>sync.map</code>主要通过两个数据集的方式, 来读写分离, 提高效率</p>
<h2 id="原子操作">原子操作</h2>
<p>go 当然也有很多的原子操作, 保证不会出现抢占问题, 在包 <code>sync/atomic</code> 中</p>
<p>比如 <code>AddInt64</code> 就是向一个 <code>int64</code> 值中增加某数</p>
<p>直接使用原子操作要比自己加锁来实现的效率高</p>
<h2 id="map-的底层实现">map 的底层实现</h2>
<p>go 语言的 map 是 hashmap, 使用<strong>数组+链表</strong>的形式实现</p>
<p>将<code>key</code>经过哈希并切分生成<code>高位</code>和<code>低位</code>数, 通过<code>低位数</code>寻找存储在哪个数组, 通过<code>高位数</code>寻找存储在这个数组的哪一个地方</p>
<p>map 内的<code>key</code>和<code>value</code>存储排列是</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key0, key1, key2, value0, value1, value2</span><br></pre></td></tr></tbody></table></figure>
<p>这是因为<code>key</code>和<code>value</code>分别为不同的数据结构, 将至分别放在一起可以达到<strong>内存对齐</strong>的目的</p>
<h2 id="sort-排序算法">sort 排序算法</h2>
<p>自带的<code>sort</code>包使用简单, 实现对应接口即可</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> {</span><br><span class="line">    Len() <span class="type">int</span>           <span class="comment">// Len方法返回集合中的元素个数</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span> <span class="comment">// i&gt;j，该方法返回索引i的元素是否比索引j的元素小、</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)      <span class="comment">// 交换i, j的值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>sort</code>内部根据不同情况选择不同的排序算法</p>
<p>当长度小于12时进行<strong>希尔排序</strong></p>
<p>长度大于12时, 使用<strong>快速排序</strong></p>
<h3 id="希尔排序">希尔排序</h3>
<p>希尔排序的时间复杂度是<code>O(n^(1.3-2))</code>, 在应对数据不长的时候速度较快, 其步骤如下</p>
<ol>
<li>计算增量, 初始是<code>gap=length/2</code>, 如果列表长度是12就是6</li>
<li>将原本的列表按照步长跳跃, 分为6个子列表, 每个列表有2个数据, 例如<code>[1, 3, 2, 4]</code>就将其拆分为<code>[1, 2]</code>和<code>[3, 4]</code></li>
<li>将这几个子列表进行排序比较(当然并不是真的独立出来, 只是在原列表中根据索引比对)</li>
<li>缩小增量, <code>gap=gap/2</code></li>
<li>重复步骤<code>2, 3, 4</code></li>
<li>增量缩小为1, 结束</li>
</ol>
<p>在长度不多的时候, 增量不会很大, 缩小起来很快, 速度较快</p>
<h3 id="快速排序">快速排序</h3>
<p>在数据较大的时候, 快排的速度更快, 时间复杂度为<code>o(nlogn)</code></p>
<p>快速排序是有<code>L(索引)</code>和<code>R(索引)</code>和<code>temp(固定值)</code>, 由此来进行分区, 步骤如下</p>
<ol>
<li><code>L</code>开始是第0位(索引), <code>R</code>开始是最后一位(索引), <code>temp</code>为第0位</li>
<li>将<code>L</code>向后移动, 如果扫描到<code>L</code>的值小于<code>temp</code>的值,  则将<code>temp</code>的位置与<code>L</code>当前的位置进行调换</li>
<li><code>L</code>不动, 将<code>R</code>向前移动, 如果扫描到<code>R</code>的值小于<code>temp</code>的值, 则将<code>temp</code>的位置与<code>R</code>当前的位置进行调换</li>
<li>循环步骤<code>2, 3</code>一直到<code>L</code>和<code>R</code>相等, 此时以<code>temp</code>为界, 左边比<code>temp</code>小, 右边比<code>temp</code>大</li>
<li>按照<code>temp</code>为界, 将左边和右边分别重复步骤<code>1到4</code>, 一直到分不出来, 结束</li>
</ol>
<p>快排主要是通过分界, 将列表切分, 然后对切分的子列表再切分, 达到排序的目的</p>
<h2 id="Defer">Defer</h2>
<p>defer 主要用于延迟调用, defer 会在函数返回之前执行 defer 注册的函数</p>
<p>defer 的注册顺序和执行顺序是相反的, 也就是<strong>先进后出</strong></p>
<p>另外, defer 可以与<code>recover</code>一起使用, 类似于 python 的<code>try</code>, 来捕捉程序的<code>panic</code>, 从而防止程序直接退出</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> {  <span class="comment">// 捕捉</span></span><br><span class="line">    fmt.Println(<span class="string">"Recovered in f"</span>, r)</span><br><span class="line">  }</span><br><span class="line">}()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="goroutine如何阻塞">goroutine如何阻塞</h2>
<ul>
<li><code>WaitGroup</code>进行等待</li>
<li>监听<code>ctx.Done()</code>管道</li>
<li><code>for</code>循环</li>
<li>向一个没有接受者并且缓冲区已满的 chan 发送数据</li>
<li>从一个没有发送者并且缓冲区为空的 chan 读取数据</li>
</ul>
<h2 id="goroutine-什么时候发生阻塞">goroutine 什么时候发生阻塞</h2>
<ul>
<li>等待 channel</li>
<li>发生一次系统调用等待回调结果</li>
<li>…</li>
</ul>
<h2 id="goroutine-阻塞时调度器怎么做">goroutine 阻塞时调度器怎么做</h2>
<p>调度器将阻塞的 goroutine 放到一边, 切换到其他 goroutine 继续执行, 直到这个 goroutine 结束阻塞</p>
<h2 id="channel-自动关闭">channel 自动关闭</h2>
<p>在这个 channel 没有goroutine 持有时, 会自动关闭</p>
<h2 id="goroutine-的最大数量">goroutine 的最大数量</h2>
<p>在1.4版本之后, 一个 goroutine 占用<strong>2kb</strong>的内存大小</p>
<h2 id="限制协程数量">限制协程数量</h2>
<p>使用 channel 来限制协程数量, channel 缓冲区的长度就是协程最大数量</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * <span class="number">1e9</span>)</span><br><span class="line">	&lt;-ch  <span class="comment">// goroutine 运行结束后将指标返回</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)  <span class="comment">// 最多允许10个 goroutine</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++ {</span><br><span class="line">		ch&lt;-i  <span class="comment">// 有指标再进行 goroutine 启动, 没有就一直夯住</span></span><br><span class="line">		<span class="keyword">go</span> test(i)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="new-和-make-区别">new 和 make 区别</h2>
<p><strong>new</strong></p>
<p>分配内存</p>
<p>new 为新的类型分配内存, 返回对应的指针, 比如创建 对象, struct 等</p>
<p>new 返回的是指针, 不使用指针的时候一般不使用 new</p>
<p><strong>make</strong></p>
<p>初始化</p>
<p>返回类型的初始值, 只适用于切片/map/channel</p>
<h2 id="go-的内存分配">go 的内存分配</h2>
<p>分为3块</p>
<ul>
<li>spans: 512MB</li>
<li>bitmap: 16GB</li>
<li>arena: 512GB</li>
</ul>
<p><strong>arena</strong></p>
<p>堆区, 动态分配的内存在这里, go 把内存分割成每个 8kb 的若干页(page)</p>
<p><strong>bitmap</strong></p>
<p>标记 arena 对象的地址, 并有4bit 标志位标识了对象是否包含指针和 GC 标记信息</p>
<p>bitmap 中一个 bytes(8bit) 大小的内存对应 arena 里4个指针大小(32bit)的内存,</p>
<p><strong>spans</strong></p>
<p>span 是 go 内存管理的基本单位, span 有多种规格, 每个规格占用若干个 page, 最大的 span 是32kb, 超过32kb 则是特殊的 class</p>
<h2 id="结构体作为参数传入时-传值还是指针">结构体作为参数传入时, 传值还是指针</h2>
<p>go 都是值传递, 只是参数可以选值类型还是引用类型</p>
<p>看具体的逻辑, 如果需要修改结构体的值时, 需要传入指针来修改数据</p>
<p>其他时候传值, 因为结构体一般存储在栈上(前提是结构体不是特别大), 栈的代价很小, 而传指针有可能会引发内存逃逸</p>
<h2 id="go-中使用过线程吗">go 中使用过线程吗</h2>
<p>GMP 模型中 M 为操作系统线程, 由 go 调度, 实际的应用开发中没有直接使用过</p>
<h2 id="linux-有几种线程模型">linux 有几种线程模型</h2>
<ul>
<li>一对一(M:1)</li>
<li>多对一(1:1)</li>
<li>多对多(M:N)</li>
</ul>
<h2 id="go-线程中某一个发生了-OOM-内存泄露-会怎样">go 线程中某一个发生了 OOM(内存泄露) 会怎样</h2>
<p>kill 掉这个线程, 不影响其他线程</p>
<h2 id="goroutine-发生-OOM-什么情况">goroutine 发生 OOM 什么情况</h2>
<p>没遇到过, 本地写代码发生过内存逃逸, 发现是 slice 的坑</p>
<h2 id="OOM-排查">OOM 排查</h2>
<p>个人经验是 OOM 基本都是 giroutine 泄露, 使用 pprof 定位问题然后排查</p>
<h2 id="错误处理怎么做">错误处理怎么做</h2>
<p>不是特别简单的逻辑, 牵扯到调用其他服务的函数, 一定有 error 返回值</p>
<p>外面通过判断 <code>err!=nil</code> 进行错误捕捉, 通过<code>fmt.Errorf("test")</code>进行 error 创建</p>
<h2 id="goroutine-发生-panic-会怎样">goroutine 发生 panic 会怎样</h2>
<p>如果没有设置<code>recover</code>捕捉, 会导致整个程序崩溃</p>
<p>goroutine 是互相独立的, <code>recover</code>必须在本层, 否则无法捕捉 panic</p>
<h2 id="怎么管理的-proto-文件">怎么管理的 proto 文件</h2>
<p>单独的仓库存放, 通过 git 管理</p>
<h2 id="gin-框架使用参数校验">gin 框架使用参数校验</h2>
<p>gin 内置了 <a target="_blank" rel="noopener" href="https://github.com/go-playground/validator">go-playground/validator: <span class="github-emoji"><span>💯</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4af.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Go Struct and Field validation, including Cross Field, Cross Struct, Map, Slice and Array diving (github.com)</a> 插件, 先定义校验的结构体, 通过<code>tag</code>的方式指定字段名字, 是否必填等信息, 通过 <code>c.ShouldBind</code>来进行参数的校验</p>
<h2 id="gin-的中间件">gin 的中间件</h2>
<p>经常使用自己写的同意跨域中间件</p>
<p><code>gin.Default()</code>默认带两个中间件, 一个是打印日志, 一个是捕捉 panic 处理成500错误</p>
<p>使用<code>router.Use()</code>添加自定义中间件</p>
<h2 id="gin-跨域中间件">gin 跨域中间件</h2>
<p>跨域主要是浏览器从服务端返回的 Header 中获取指定的 key, 来判断是否是跨域的</p>
<p>浏览器将请求分为两种:</p>
<p><strong>简单请求</strong></p>
<ol>
<li>使用 <code>GET、POST、HEAD</code> 其中一种请求方法。</li>
<li>HTTP的头信息不超出以下几种字段：
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 <code>application/x-www-form-urlencoded、multipart/form-data、text/plain</code></li>
</ul>
</li>
</ol>
<p>简单请求的同意跨域, 直接在返回值的 header 中插入<code>Access-Control-Allow-Origin: *</code>即可</p>
<p><strong>非简单请求</strong></p>
<p>请求方法是 <code>put</code> 或 <code>delete</code>, 或者 <code>content-type</code> 的类型是 <code>application/json</code></p>
<p>其实简单请求之外的都是非简单请求了</p>
<p>浏览器在处理非简单请求时, 会先发送<code>OPTIONS</code>方法, 查看返回值的 header 字段, 符合要求则同意跨域</p>
<p>gin 使用中间件时, 使用<code>c.Header</code>添加<code>Header</code>数据, 使用<code>c.Next()</code>将请求处理移交到下一部分</p>
<h2 id="go-怎么解析-tag">go 怎么解析 tag</h2>
<p>使用反射进行 tag 的解析</p>
<h2 id="反射原理">反射原理</h2>
<p>go 的<code>reflect</code>包提供了反射的支持</p>
<p>获取对象的 type 和 value 的元数据和一些方法, 进行调用</p>
<p><strong>反射一般不使用</strong></p>
<ul>
<li>可读性差</li>
<li>可能会 panic</li>
<li>影响效率</li>
</ul>
<h2 id="channel的坑">channel的坑</h2>
<ul>
<li>向一个已经 close 的 chan 写入数据会 panic</li>
<li>从一个已经 close 的 chan 读取数据会获取到 chan 数据类型的默认值</li>
<li>推荐使用<code>for i := range chan</code>或者<code>select</code>来读取 chan 数据, 这样在关闭后自动退出</li>
<li>有可能造成 goroutine 阻塞</li>
</ul>
<h2 id="负载均衡算法">负载均衡算法</h2>
<p><strong>哈希</strong></p>
<p>根据 hash 取模进行分配, 保证同一个 key 会分配到同一个节点</p>
<p>可能会导致不均衡</p>
<p><strong>轮询</strong></p>
<p>所有节点进行轮询, 排序选择分配的节点</p>
<p>请求均衡, 但是负载不一定</p>
<p><strong>随机</strong></p>
<p>随机选一个节点</p>
<p>类似轮询</p>
<p><strong>加权轮询</strong></p>
<p>根据权重优先分配给权重高的节点</p>
<h2 id="select-执行原理">select 执行原理</h2>
<p>具体的代码在<code>selectgo</code>中</p>
<p>先将 case 打乱顺序, 然后尝试从 chan 获取值, 没有则运行 default, 没有定义 default 时将所在的 G 加入到对应的 N 个 chan 监听队列中等待唤醒</p>
<h2 id="channel-关闭后对-channel-操作会出现什么">channel 关闭后对 channel 操作会出现什么</h2>
<p>使用<code>clse(ch1)</code>来关闭管道</p>
<p>在 close 时, go 会将 chan 中等待插入数据的 goroutine 全部唤醒, 并且设置插入的值为 nil</p>
<ul>
<li>如果从 chan 中尝试发送数据, 会导致程序<strong>panic</strong></li>
<li>如果从 chan 中尝试读取数据, 会读取出存储类型的默认值, 不会 panic</li>
</ul>
<h2 id="大对象-小对象-微对象">大对象/小对象/微对象</h2>
<p><strong>大对象</strong></p>
<p>占用内存&gt;32kb 时, 认为他是大对象</p>
<p>大对象分配不走 mcache 和 mcentral, 直接通过 mheap 分配</p>
<p><strong>小对象</strong></p>
<p>16b&lt;占用内存&lt;32kb 时, 认为他是小对象</p>
<p>小对象先获取到合适大小的的 mspan, 并存储到 mheap 中</p>
<p><strong>微对象</strong></p>
<p>占用内存&lt;16b 时, 认为他是微对象</p>
<p>微对象直接存储在 mcache 上, 每个微对象的大小是16b</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Golang 常问知识点(简略)</p><p><a href="https://www.chnmig.com/2022/01/20/go_interview/">https://www.chnmig.com/2022/01/20/go_interview/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ChnMig</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-01-20</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-01-20</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Golang/">Golang</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/01/21/mysql_interview/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL 常问知识点(简略)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/12/21/skip_gitbook_lock/"><span class="level-item">记一次破解 gitbook_lock 密码的过程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言-6"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#Go-语言的基础数据类型占用大小"><span class="level-left"><span class="level-item">2</span><span class="level-item">Go 语言的基础数据类型占用大小</span></span></a></li><li><a class="level is-mobile" href="#Go-语言的变量分配在栈还是堆"><span class="level-left"><span class="level-item">3</span><span class="level-item">Go 语言的变量分配在栈还是堆</span></span></a></li><li><a class="level is-mobile" href="#select是随机还是顺序"><span class="level-left"><span class="level-item">4</span><span class="level-item">select是随机还是顺序</span></span></a></li><li><a class="level is-mobile" href="#Go-语言的垃圾回收"><span class="level-left"><span class="level-item">5</span><span class="level-item">Go 语言的垃圾回收</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么时候进行垃圾回收"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">什么时候进行垃圾回收</span></span></a></li><li><a class="level is-mobile" href="#标记-GC"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">标记 GC</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Go-协程"><span class="level-left"><span class="level-item">6</span><span class="level-item">Go 协程</span></span></a></li><li><a class="level is-mobile" href="#GMP-优势-相比多线程开发"><span class="level-left"><span class="level-item">7</span><span class="level-item">GMP 优势(相比多线程开发)</span></span></a></li><li><a class="level is-mobile" href="#GMP-中-G-的状态"><span class="level-left"><span class="level-item">8</span><span class="level-item">GMP 中 G 的状态</span></span></a></li><li><a class="level is-mobile" href="#GMP-中-M-的状态"><span class="level-left"><span class="level-item">9</span><span class="level-item">GMP 中 M 的状态</span></span></a></li><li><a class="level is-mobile" href="#GMP-中-P-的状态"><span class="level-left"><span class="level-item">10</span><span class="level-item">GMP 中 P 的状态</span></span></a></li><li><a class="level is-mobile" href="#GMP-抢占式调度"><span class="level-left"><span class="level-item">11</span><span class="level-item">GMP 抢占式调度</span></span></a></li><li><a class="level is-mobile" href="#Go-两个结构体生成的对象能不能相互比较"><span class="level-left"><span class="level-item">12</span><span class="level-item">Go 两个结构体生成的对象能不能相互比较</span></span></a></li><li><a class="level is-mobile" href="#Go-的-context"><span class="level-left"><span class="level-item">13</span><span class="level-item">Go 的 context</span></span></a></li><li><a class="level is-mobile" href="#interface"><span class="level-left"><span class="level-item">14</span><span class="level-item">interface</span></span></a></li><li><a class="level is-mobile" href="#goroutine-控制"><span class="level-left"><span class="level-item">15</span><span class="level-item">goroutine 控制</span></span></a></li><li><a class="level is-mobile" href="#堆和栈"><span class="level-left"><span class="level-item">16</span><span class="level-item">堆和栈</span></span></a></li><li><a class="level is-mobile" href="#优雅的结束程序"><span class="level-left"><span class="level-item">17</span><span class="level-item">优雅的结束程序</span></span></a></li><li><a class="level is-mobile" href="#CSP-并发模型"><span class="level-left"><span class="level-item">18</span><span class="level-item">CSP 并发模型</span></span></a></li><li><a class="level is-mobile" href="#锁-2"><span class="level-left"><span class="level-item">19</span><span class="level-item">锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#互斥锁-2"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">互斥锁</span></span></a></li><li><a class="level is-mobile" href="#读写锁"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">读写锁</span></span></a></li></ul></li><li><a class="level is-mobile" href="#单例"><span class="level-left"><span class="level-item">20</span><span class="level-item">单例</span></span></a></li><li><a class="level is-mobile" href="#map-并发"><span class="level-left"><span class="level-item">21</span><span class="level-item">map 并发</span></span></a></li><li><a class="level is-mobile" href="#原子操作"><span class="level-left"><span class="level-item">22</span><span class="level-item">原子操作</span></span></a></li><li><a class="level is-mobile" href="#map-的底层实现"><span class="level-left"><span class="level-item">23</span><span class="level-item">map 的底层实现</span></span></a></li><li><a class="level is-mobile" href="#sort-排序算法"><span class="level-left"><span class="level-item">24</span><span class="level-item">sort 排序算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#希尔排序"><span class="level-left"><span class="level-item">24.1</span><span class="level-item">希尔排序</span></span></a></li><li><a class="level is-mobile" href="#快速排序"><span class="level-left"><span class="level-item">24.2</span><span class="level-item">快速排序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Defer"><span class="level-left"><span class="level-item">25</span><span class="level-item">Defer</span></span></a></li><li><a class="level is-mobile" href="#goroutine如何阻塞"><span class="level-left"><span class="level-item">26</span><span class="level-item">goroutine如何阻塞</span></span></a></li><li><a class="level is-mobile" href="#goroutine-什么时候发生阻塞"><span class="level-left"><span class="level-item">27</span><span class="level-item">goroutine 什么时候发生阻塞</span></span></a></li><li><a class="level is-mobile" href="#goroutine-阻塞时调度器怎么做"><span class="level-left"><span class="level-item">28</span><span class="level-item">goroutine 阻塞时调度器怎么做</span></span></a></li><li><a class="level is-mobile" href="#channel-自动关闭"><span class="level-left"><span class="level-item">29</span><span class="level-item">channel 自动关闭</span></span></a></li><li><a class="level is-mobile" href="#goroutine-的最大数量"><span class="level-left"><span class="level-item">30</span><span class="level-item">goroutine 的最大数量</span></span></a></li><li><a class="level is-mobile" href="#限制协程数量"><span class="level-left"><span class="level-item">31</span><span class="level-item">限制协程数量</span></span></a></li><li><a class="level is-mobile" href="#new-和-make-区别"><span class="level-left"><span class="level-item">32</span><span class="level-item">new 和 make 区别</span></span></a></li><li><a class="level is-mobile" href="#go-的内存分配"><span class="level-left"><span class="level-item">33</span><span class="level-item">go 的内存分配</span></span></a></li><li><a class="level is-mobile" href="#结构体作为参数传入时-传值还是指针"><span class="level-left"><span class="level-item">34</span><span class="level-item">结构体作为参数传入时, 传值还是指针</span></span></a></li><li><a class="level is-mobile" href="#go-中使用过线程吗"><span class="level-left"><span class="level-item">35</span><span class="level-item">go 中使用过线程吗</span></span></a></li><li><a class="level is-mobile" href="#linux-有几种线程模型"><span class="level-left"><span class="level-item">36</span><span class="level-item">linux 有几种线程模型</span></span></a></li><li><a class="level is-mobile" href="#go-线程中某一个发生了-OOM-内存泄露-会怎样"><span class="level-left"><span class="level-item">37</span><span class="level-item">go 线程中某一个发生了 OOM(内存泄露) 会怎样</span></span></a></li><li><a class="level is-mobile" href="#goroutine-发生-OOM-什么情况"><span class="level-left"><span class="level-item">38</span><span class="level-item">goroutine 发生 OOM 什么情况</span></span></a></li><li><a class="level is-mobile" href="#OOM-排查"><span class="level-left"><span class="level-item">39</span><span class="level-item">OOM 排查</span></span></a></li><li><a class="level is-mobile" href="#错误处理怎么做"><span class="level-left"><span class="level-item">40</span><span class="level-item">错误处理怎么做</span></span></a></li><li><a class="level is-mobile" href="#goroutine-发生-panic-会怎样"><span class="level-left"><span class="level-item">41</span><span class="level-item">goroutine 发生 panic 会怎样</span></span></a></li><li><a class="level is-mobile" href="#怎么管理的-proto-文件"><span class="level-left"><span class="level-item">42</span><span class="level-item">怎么管理的 proto 文件</span></span></a></li><li><a class="level is-mobile" href="#gin-框架使用参数校验"><span class="level-left"><span class="level-item">43</span><span class="level-item">gin 框架使用参数校验</span></span></a></li><li><a class="level is-mobile" href="#gin-的中间件"><span class="level-left"><span class="level-item">44</span><span class="level-item">gin 的中间件</span></span></a></li><li><a class="level is-mobile" href="#gin-跨域中间件"><span class="level-left"><span class="level-item">45</span><span class="level-item">gin 跨域中间件</span></span></a></li><li><a class="level is-mobile" href="#go-怎么解析-tag"><span class="level-left"><span class="level-item">46</span><span class="level-item">go 怎么解析 tag</span></span></a></li><li><a class="level is-mobile" href="#反射原理"><span class="level-left"><span class="level-item">47</span><span class="level-item">反射原理</span></span></a></li><li><a class="level is-mobile" href="#channel的坑"><span class="level-left"><span class="level-item">48</span><span class="level-item">channel的坑</span></span></a></li><li><a class="level is-mobile" href="#负载均衡算法"><span class="level-left"><span class="level-item">49</span><span class="level-item">负载均衡算法</span></span></a></li><li><a class="level is-mobile" href="#select-执行原理"><span class="level-left"><span class="level-item">50</span><span class="level-item">select 执行原理</span></span></a></li><li><a class="level is-mobile" href="#channel-关闭后对-channel-操作会出现什么"><span class="level-left"><span class="level-item">51</span><span class="level-item">channel 关闭后对 channel 操作会出现什么</span></span></a></li><li><a class="level is-mobile" href="#大对象-小对象-微对象"><span class="level-left"><span class="level-item">52</span><span class="level-item">大对象/小对象/微对象</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a><p class="is-size-7"><span>&copy; 2022 ChnMig</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Contact me" href="mailto:ChnMig@Outlook.com"><i class="far fa-envelope"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ChnMig"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>