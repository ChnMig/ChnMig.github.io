<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Rust程序设计语言(4) - ChnMig的个人网站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ChnMig的个人网站"><meta name="msapplication-TileImage" content="/images/logo.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ChnMig的个人网站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Rust的所有权与作用域"><meta property="og:type" content="blog"><meta property="og:title" content="Rust程序设计语言(4)"><meta property="og:url" content="https://www.chnmig.com/2021/09/04/rust_programming_language(4)/"><meta property="og:site_name" content="ChnMig的个人网站"><meta property="og:description" content="Rust的所有权与作用域"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.chnmig.com/img/og_image.png"><meta property="article:published_time" content="2021-09-03T16:00:00.000Z"><meta property="article:modified_time" content="2021-09-03T16:00:00.000Z"><meta property="article:author" content="ChnMig"><meta property="article:tag" content="Rust"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://www.chnmig.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.chnmig.com/2021/09/04/rust_programming_language(4)/"},"headline":"Rust程序设计语言(4)","image":["https://www.chnmig.com/img/og_image.png"],"datePublished":"2021-09-03T16:00:00.000Z","dateModified":"2021-09-03T16:00:00.000Z","author":{"@type":"Person","name":"ChnMig"},"publisher":{"@type":"Organization","name":"ChnMig的个人网站","logo":{"@type":"ImageObject","url":"https://www.chnmig.com/images/logo.gif"}},"description":"Rust的所有权与作用域"}</script><link rel="canonical" href="https://www.chnmig.com/2021/09/04/rust_programming_language(4)/"><link rel="icon" href="/images/logo.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?8c2572cbfe4082d1fcd1327e4614cf34";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">类别</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://tongji.baidu.com/web/welcome/ico?s=8c2572cbfe4082d1fcd1327e4614cf34">访问统计</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-03T16:00:00.000Z" title="2021/9/4 00:00:00">2021-09-04</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span><span class="level-item">1 小时读完 (大约7819个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Rust程序设计语言(4)</h1><div class="content"><h2 id="前言">前言</h2>
<p>所有权系统是Rust最为独特的性质, 他让Rust无需垃圾回收即可保障内存的安全. 所以, 理解所有权怎么工作是非常重要的, 本章, 我们将讲到所有权和相关的功能, 借用, slice以及Rust如何在内存中放置数据</p>
<h2 id="什么是所有权">什么是所有权</h2>
<p>rust的核心之一就是所有权</p>
<p>对于运行中的程序来说, 他必须对使用的内存进行管理, 同时对于运行中产生的垃圾, 程序也需要进行销毁, 以免出现内存泄露等问题</p>
<p>某些语言自带了垃圾回收机制, 在程序运行时不断的扫描寻找不再使用的内存将其释放</p>
<p>另一些语言要求程序员通过代码来自己分配和释放内存</p>
<p>而rust使用的是第三种, 通过所有权系统来管理内存, 编译器在编译时会根据规则来进行检查. 在运行时可以保证不会减慢程序的运行速度</p>
<h2 id="栈-stack-与堆-heap">栈(stack)与堆(heap)</h2>
<p>栈和堆都是在程序运行中可供使用的内存, 他们的结构并不相同, 栈是有序的, 他就像一个水桶, 最上面的是栈顶, 向这个栈里存放数据叫做<strong>进栈</strong>, 他像一个水桶, 所以存储数据只能存放在水桶的最上面, 当移除数据<strong>出栈</strong>的时候, 也只能从栈顶移除, 所以, 栈遵循<strong>先进后出</strong>的逻辑.</p>
<p>栈中的所有数据都必须占用已知且固定的大小, 而且栈中的数据是有大小限制的, 所以在程序运行中出现的大小未知或者可能变化的数据, 必须存储在堆上, 堆不是有序的, 当你向堆中存储一个数据, 操作系统首先在堆的某处找到一块足够大的空间, 把它标记为已使用, 然后回传该空间的<strong>指针</strong>, 这个过程叫做<strong>在堆上分配内存</strong>, 指针的大小是已知且固定的</p>
<p>所以可以把真正的数据存储在堆中, 将指针存放在栈中, 当需要访问真实数据时, 先获取指针, 再访问指针</p>
<p>入栈比在堆上分配内存快, 这是因为栈在建立时每一块数据的大小是固定的, 而且是有序的, 操作系统无需为新数据去搜索合适的内存空间. 当在堆上分配内存时, 系统需要先找到一块足够大的内存, 然后做记录</p>
<p>访问堆上的数据也比访问栈的数据慢, 堆上面的数据通过指针访问, 现代处理器在内存中跳转越少速度就越快(缓存), 而堆是无序的, 意味着指针指向的地方可能需要很多次内存跳转</p>
<p>同样的, 因为这个原因, 处理器在处理数据彼此相近的时候(比如栈)比远的时候(堆)效率更高. 在堆上分配大量空间也会消耗时间.</p>
<p>当代码调用一个函数时, 会将函数的值和函数内部的局部变量压入栈中, 当这个函数结束时, 这些数据就属于垃圾, 理应被回收, 此时则出栈, 因为栈是后进先出, 导致这种回收是快速的, 符合逻辑的, rust的所有权就是这样做的</p>
<p>跟踪哪部分代码正在使用哪些数据, 最大限度的减少堆上重复数据的数量, 同时清理堆上不再使用的数据, 这些就是所有权系统需要去关心的</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设一个抽象的栈 []</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">  A;  <span class="comment">// A入栈, [A]</span></span><br><span class="line">  B;  <span class="comment">// B入栈, [B, A]</span></span><br><span class="line">  {</span><br><span class="line">    a;  <span class="comment">// a入栈, [a, B, A]</span></span><br><span class="line">    b;  <span class="comment">// b入栈, [b, a, B, A]</span></span><br><span class="line">  };</span><br><span class="line">  <span class="comment">// 函数结束了, a和b是垃圾了, 将a和b出栈, 直接取栈顶的的一段即可,保证效率的同时也符合逻辑(代码从上往下执行的顺序), [b, a, B, A] -&gt; [B, A]</span></span><br><span class="line">  C;  <span class="comment">// C入栈, [C, B, A]</span></span><br><span class="line">  D;  <span class="comment">// D入栈, [D, C, B, A]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="所有权的基本规则">所有权的基本规则</h2>
<blockquote>
<p>Rust中的每一个值都有且只有一个被称为其 所有者 的变量</p>
<p>值在任一时刻有且只有一个所有者</p>
<p>所有者离开作用域时, 这个值将会被丢弃</p>
</blockquote>
<h3 id="变量作用域">变量作用域</h3>
<p>每个变量都有其 <strong>作用域(scope)</strong>, 作用域是一个 <strong>项(item)</strong> 在程序中有效的范围</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>=<span class="string">"hello"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这里的变量<code>s</code>绑定到了字符串<code>hello</code>中, 这个字符串编码进了程序代码中, 那么s从声明开始到当前作用域结束时都是有效的</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// s未声明</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"hello"</span>;  <span class="comment">// s在这里生效</span></span><br><span class="line">    <span class="comment">// 可以使用s</span></span><br><span class="line">}<span class="comment">// 函数结束, 作用域也结束, s无法使用了</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里有两个关键点</p>
<blockquote>
<p>s进入作用域时, s是有效的</p>
<p>s离开作用域, s无效</p>
</blockquote>
<h2 id="String类型">String类型</h2>
<p>上面的例子来说, s因为是不可变的, 加上其数据很小, 所以本体存储在栈中</p>
<p>本次测试将把数据的本体放置在堆中, 而将指针放置在栈中</p>
<p>我们这里使用<code>String</code>作为例子, 专注于<code>String</code>与所有权相关部分.</p>
<p>对于在编译时无法知道具体的值的变量, 也就是说并不知道大小, 他就会被分配到堆上, 比如<code>String</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>这里的<code>::</code>是运算符, 具体的详情我们在之后的章节说明.</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">", world"</span>);  <span class="comment">// 在s后拼接字符串</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);  <span class="comment">// hello, world</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里得到的s是可变的, 他可以通过调用 <code>push_str</code> 函数来修改自己</p>
<h3 id="内存与分配">内存与分配</h3>
<p>对于字符串字面值来说, 我们在编译时就能准确的知道其内容, 所以直接硬编码进最终的可执行文件中, 这使得字符串字面值快速且高效. 这里的前提是字符串字面值的不可变性, 但是, 对于未知的文本, 我们无法在开始时确定大小, 因为他是可以改变的.</p>
<p>对于<code>string</code>类型, 为了让他可以支持一个可变的, 可增长的文本片段, 需要在堆上分配一块在编译时未知大小的内存存放数据, 这就有两个问题</p>
<ul>
<li>必须在运行时向操作系统请求内存</li>
<li>当<code>string</code>处理完成后将内存返回给操作系统</li>
</ul>
<p>如何在运行时请求内存呢? 当我们调用<code>String::from</code> 时, 他会请求所需要的内存</p>
<p>如何在处理完成后将内存返给操作系统呢? 在有垃圾回收 <strong>GC</strong> 的语言中, GC会记录和清理不再使用的内存, 作为开发者我们不需要关心他, 没有GC则需要开发者手动的释放, 就跟请求一样需要我们写在代码中, 正确的处理内存回收通常比较困难, 如果忘记回收会浪费内存, 导致内存泄露等. 如果回收过早, 可能会在后续的使用中出现无效变量, 如果重复回收也可能会导致问题, 所以要准确的在合适的地方对一个 <strong>分配(allocate)</strong> 配对一个 <strong>释放(free)</strong></p>
<p>在Rust中, 内存在拥有他的变量离开作用域时就被自动释放, 例如下面的例子</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);  <span class="comment">// 创建s, s此时是有效的, 在此作用域中</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">", world"</span>);  <span class="comment">// 使用修改s, 在s后拼接字符串</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);  <span class="comment">// hello, world</span></span><br><span class="line">}  <span class="comment">// 该作用域已结束, 作用域内的使用的内存需要释放</span></span><br><span class="line"><span class="comment">// s失效了</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里, 当s离开当前有效的作用域时, Rust为我们自动调用函数<code>drop</code>  (前提是该数据类型有drop), 该函数可以将变量释放, Rust会在结尾<code>}</code>自动调用 需要释放的变量的<code>drop</code></p>
<p><strong>变量与数据交互: 移动</strong></p>
<p>如果我们将一个变量赋值给另一个变量, 其数据会怎么处理呢?</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;  <span class="comment">// x为5</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;  <span class="comment">// copy x的值5, 赋值给y</span></span><br><span class="line"><span class="comment">// x和y都等于5</span></span><br></pre></td></tr></tbody></table></figure>
<p>因为5是在编译时就可以确定的, 所以这两个5被放入了栈中</p>
<p>那么对于无法确定大小的变量来说, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"s1"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></tbody></table></figure>
<p>之前说过, 对于不可预测的变量, 我们会在栈上存储指针而在堆上存储真正的数据, 那么对于s1来说, 在栈上的数据为</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ptr(指针)</td>
<td style="text-align:center">堆上的地址</td>
</tr>
<tr>
<td style="text-align:center">len(长度)</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">capacity(容量)</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>指针指向的堆的数据为</p>
<table>
<thead>
<tr>
<th style="text-align:center">index</th>
<th style="text-align:center">value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">s</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>这就是将<code>s1</code>绑定给变量<code>s1</code>在内存中的表现形式</p>
<p>我们注意到, 栈上的数据有 长度 和 容量, 长度指的是当前使用了多少字节的内存, 容量指的是从操作系统申请了多少字节的内存, 这两个是不一样的, 不要混淆</p>
<p>而我们将s1赋值给s2时,  实际上只是从拷贝了s1在栈上的数据, 也就是说此时 s1与s2共同指向了一个堆地址, 这跟其他语言的 <strong>浅COPY(shallow copy)</strong> 非常像, 这样做的好处是使操作变得快速, 如果是 <strong>深COPY(deep copy)</strong> , 意味着需要将堆上的数据找到,再插入到堆的另一个地方, 如果堆上的值很大, 则会造成效率的低下</p>
<p>但是这样会导致问题出现, 例如当s1与s2离开了作用域时, Rust 会对s1和s2进行清理, 但是他们实际上指向了同一个地址, 两次清理一个内存, 这就会出现前文提到的 <strong>二次释放(double free)</strong> 问题, 因此, Rust使用了不同的方法, 即 <strong>移动(move)</strong> , 就是在运行 <code>s2=s1</code> 时, 将s1无效化</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"s1"</span>);  <span class="comment">// 创建s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1;  <span class="comment">// 将s1栈上的数据转移到s2上, s1失效了</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s1);  <span class="comment">// s1不可用, 所以会出错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2);  <span class="comment">// s2可用</span></span><br><span class="line">}  <span class="comment">// drop时, 先处理s2的Drop再s2的栈, s1无了, 只清理s1的栈</span></span><br></pre></td></tr></tbody></table></figure>
<p>运行该代码时, 会出错</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"> --&gt; src/main.rs:4:20</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> s1 = String::from(<span class="string">"s1"</span>);</span><br><span class="line">  |         -- move occurs because `s1` has <span class="built_in">type</span> `std::string::String`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">3 |     <span class="built_in">let</span> s2 = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line">4 |     println!(<span class="string">"{}"</span>, s1);</span><br><span class="line">  |                    ^^ value borrowed here after move</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `ownership`.</span><br></pre></td></tr></tbody></table></figure>
<p>Rust禁止你使用无效的引用</p>
<p>所以, Rust在处理这个<code>s2 = s1</code>时, 先将s1的栈数据复制一份给s2, 然后将s1置空, 这样就解决了二次释放的问题</p>
<p>需要知道的是, Rust的设计原则是: <strong>永远不会自动创建数据的深拷贝</strong>, 这是出于对性能影响的考虑</p>
<p><strong>变量与数据交互: 克隆</strong></p>
<p>如果你确实需要进行<strong>深copy</strong>, 你可以使用内置函数<code>clone</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"s1"</span>);  <span class="comment">// 创建s1, s1进入作用域</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();  <span class="comment">// s1的堆数据复制为另一份, 然后重新生成栈数据, 指向新的堆数据, s2进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s1);  <span class="comment">// 未发生转移, s1还是可用的</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2);  <span class="comment">// s2可用</span></span><br><span class="line">}  <span class="comment">// drop时, s1和s2的堆数据并不是一个, 所以没有二次释放的问题, 先进后出所以先清理s2</span></span><br></pre></td></tr></tbody></table></figure>
<p>必须要注意的是, 这样会对资源和性能造成一定的损耗, 在确保你必须这样做时才需要进行克隆操作</p>
<p><strong>只在栈上的数据: 拷贝</strong></p>
<p>而对于只在栈上保存的数据, 也就是在编译时就知道值的数据来说, 不存在转移和克隆, 因为他是只保存在栈上, 所以进行拷贝速度很快,Rust在处理这种数据的赋值时直接copy栈的数据到另一个变量, 所以两个变量都可用</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="number">1</span>;  <span class="comment">// 创建s1, 进入作用域</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1;  <span class="comment">// 拷贝s1的栈数据生成s2, s2进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{},{}"</span>, s1, s2)  <span class="comment">// s1与s2都可以使用</span></span><br><span class="line">}  <span class="comment">// i32没有drop, 根据先进先出, 清理s2再s1</span></span><br></pre></td></tr></tbody></table></figure>
<p>怎么分辨什么是会出现移动的呢, Rust有一个叫做<code>Copy</code>的trait的特殊注解, 如果某个类型拥有这个注解, 那么旧的变量在赋值给新的变量后依旧可用. 如果一个类型有<code>Drop</code>注解, 那么他就无法使用<code>Copy</code>注解. 他们是无法共存的.</p>
<p>什么类型是<code>Copy</code>的呢? 可以查看对应的文档. 一般的, 任何简单标量值的组合可以是<code>Copy</code>的, 不需要分配内存或者某种形式的资源类型是<code>Copy</code>的, 比如</p>
<ul>
<li>所有整数类型</li>
<li>布尔类型</li>
<li>所有浮点类型</li>
<li>字符类型, <code>char</code></li>
<li>元组, 当其包含的类型都是<code>Copy</code>时</li>
</ul>
<p><strong>drop与内存释放的关系</strong></p>
<blockquote>
<p>这里是本人记录的</p>
</blockquote>
<p>需要注意的是, Rust释放内存有两种</p>
<p>如果是有<code>drop</code>注解的数据类型(例如String), 先执行<code>drop</code>方法,再将栈数据删除</p>
<p>而没有<code>drop</code>注解的数据类型(例如i32), 直接将栈数据删除</p>
<p><strong>为什么drop与copy注解不能兼容</strong></p>
<blockquote>
<p>这里是本人记录的</p>
</blockquote>
<p>我们知道, <code>copy</code>注解代表着该数据类型并不会发生转移, 也就是说发生 <code>s1 = s2</code> 时,<code>s2</code> 依旧存在, 在内部逻辑中是Copy一份栈数据, 有<code>copy</code> 的数据类型一般只将数据放置在栈上, 在退出作用域时, 只需要清理栈数据即可, 而拥有<code>drop</code>的数据类型, rust会优先调用<code>drop</code>方法, 一般来讲, <code>drop</code> 一般是清理堆的有关数据, <code>copy</code>的不需要清理, 所以为了保持统一, 就规定了两者不兼容</p>
<p>如果某个类型同时拥有<code>Copy</code>和<code>Drop</code>注解的话, 首先拥有<code>Drop</code>一般都需要将数据本体放置进堆, 那样在重复赋值时又有<code>Copy</code>会Copy一份栈数据, 就造成了两个变量实际上指向了同一个资源, 在清理时就会发生<strong>二次释放</strong>的问题</p>
<h2 id="所有权与函数">所有权与函数</h2>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"s"</span>);  <span class="comment">// 创建s, 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);  <span class="comment">// s转移进了函数takes_ownership的some_string中</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);  <span class="comment">// 这里会报错, 因为s已经转移, s不可用了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">5</span>;  <span class="comment">// i进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(i);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, i);  <span class="comment">// i可用, 因为i是存储在栈上, 有`Copy`直接复制一份进makes_copy的some_integer</span></span><br><span class="line">}  <span class="comment">// s和i退出作用域, 栈是先进后出, 所以先清理i, i没有`Drop`所以直接删除栈, s已经被转移所以不做特殊操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) { <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, some_string);</span><br><span class="line">}  <span class="comment">// some_string 移出作用域并调用`drop`方法。占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) { <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, some_integer);</span><br><span class="line">} <span class="comment">// 将 some_integer 释放, 因为i32没有`drop`注解所以只清理栈数据</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="返回值与作用域">返回值与作用域</h3>
<p>如果函数是拥有返回值, 如果返回值是<code>drop</code>, 则会将返回值移动给返回值的接收者, 如果是<code>copy</code>, 则是copy给返回值</p>
<p>变量的所有权总是遵循相同的模式: 将值付给另一个变量时移动他. 当持有堆中数据值的变量离开作用域时, 堆中值会通过<code>drop</code>被清理, 除非数据被移动到另一个变量</p>
<p>看下面代码</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();  <span class="comment">// s1接受返回值, 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"s2"</span>);  <span class="comment">// 创建s2, 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2传入takes_and_gives_back函数, s2转移给该函数的a_string, 随后s3接受返回值, 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2);  <span class="comment">// 这里s2已经发生转移, 指针为空, 所以使用会报错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}, {}"</span>, s1, s3);  <span class="comment">// s1和s3可用</span></span><br><span class="line">} <span class="comment">// 退出作用域, 清理s3&gt;s2&gt;s1</span></span><br><span class="line"><span class="comment">// s2为空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> { </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"gives_ownership"</span>);</span><br><span class="line"></span><br><span class="line">    some_string  <span class="comment">// 如果这里返回了, 而返回值是String类型, 有Drop注解, 会发生所有权的移动, 移动给接受者, some_string失效了</span></span><br><span class="line">}  <span class="comment">// some_string 移除作用域, 因为 some_string 已经转移所以只删除栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 如果这里返回了, 而返回值是String类型, 有Drop注解, 会发生移动, 移动给接受者, a_string失效了</span></span><br><span class="line">}  <span class="comment">// a_string 移除作用域, 因为 a_string 已经转移所以只删除栈</span></span><br></pre></td></tr></tbody></table></figure>
<p>这样就会出现一个问题, 如果某个变量是拥有<code>Drop</code>的, 那么这个变量需要作为某个函数的参数使用, 我们传入到这个函数中总会使原有的变量失效, 那么如果我还需要再使用这个变量呢?</p>
<p>有一个折中的办法, 在函数中再将参数值传出, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"s1"</span>); </span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);  <span class="comment">// s1转移了, 用s2接受原来的s1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The length of '{}' is {}."</span>, s2, len);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() 返回字符串的长度</span></span><br><span class="line"></span><br><span class="line">    (s, length)  <span class="comment">// 将s也返回</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是这样太LOW了, 为了解决这样的问题, Rust提供了<strong>引用(references)</strong></p>
<h2 id="引用和借用">引用和借用</h2>
<p>引用可以在不转移所有权的情况下使用变量</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);  <span class="comment">// s1进入作用域</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);  <span class="comment">// 将 &amp;s1 传入, &amp;意思是引用, 即将s1的引用传入函数calculate_length</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The length of '{}' is {}."</span>, s1, len);  <span class="comment">// 仍可以使用s1, 因为未发生所有权转移</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> {  <span class="comment">// 因为类型变成了String的引用, 所以接收参数类型发生变化</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>&amp;代表对某个引用, 引用允许你使用值但不获取其所有权, 比如上面的 s1, 当 s1传入到 calculate_length 的参数 s 时, 实际上s是 s1 的引用, 类似于指针, 指向了s1</p>
<blockquote>
<p>与&amp;(引用)相反的操作是<strong>解引用(dereferences)</strong>, 他的运算符是 *, 之后会讲到</p>
</blockquote>
<p><code>&amp;s1</code> 让我们创建一个指向<code>s1</code>的引用, 但是并不拥有他, 因为不拥有他, 所以当引用离开作用域时其指向的值也不会被清理</p>
<p>在 calculate_length 结束时, s离开作用域, 理应清理, 但是因为s只是个引用类型, 所以只把s清理并不会清理s对应的真正的变量</p>
<p>对于函数 calculate_length 来说, 其接受了String的引用, 这种行为被称为 <strong>借用</strong></p>
<p>需要注意的是, 如果你借用了某个变量, 那你 <strong>默认情况下</strong> 是无法修改这个变量的值的</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="type">String</span>) {</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">", world"</span>);  <span class="comment">// 尝试追加字符串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>会报错</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference</span><br><span class="line"> --&gt; src/main.rs:8:5</span><br><span class="line">  |</span><br><span class="line">7 | fn change(some_string: &amp;String) {</span><br><span class="line">  |                        ------- <span class="built_in">help</span>: consider changing this to be a mutable reference: `&amp;mut std::string::String`</span><br><span class="line">8 |     some_string.push_str(<span class="string">", world"</span>);  // 尝试追加字符串</span><br><span class="line">  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br><span class="line">error: could not compile `ownership`.</span><br></pre></td></tr></tbody></table></figure>
<p>提示你无法修改他, 当然这是<strong>默认情况下</strong></p>
<h3 id="可变引用">可变引用</h3>
<p>某些情况下可以修改引用的值, 我们修改代码成</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);  <span class="comment">// &amp;mut 表示是可变的引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s)  <span class="comment">// hello, world</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) {  <span class="comment">// 同样的参数类型也要 mut</span></span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">", world"</span>);  <span class="comment">// 尝试追加字符串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样即可运行, 但是注意, 可变引用有几个限制</p>
<p><strong>在特定作用域的特定数据只能有一个可变引用</strong></p>
<p>例如以下代码</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;  <span class="comment">// 错误, 因为s的 &amp;mut 同时只能出现一个</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{},{}"</span>, r1, r2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>会报错</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"> --&gt; src/main.rs:4:14</span><br><span class="line">  |</span><br><span class="line">3 |     <span class="built_in">let</span> r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">4 |     <span class="built_in">let</span> r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">5 |     println!(<span class="string">"{},{}"</span>, r1, r2)</span><br><span class="line">  |                       -- first borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br><span class="line">error: could not compile `ownership`.</span><br></pre></td></tr></tbody></table></figure>
<p>这是为了避免出现<strong>数据竞争</strong>的问题, 数据竞争通常由这三种行为造成:</p>
<ul>
<li>两个或多个指针同时访问一个数据</li>
<li>至少一个指针写入数据</li>
<li>没有同步数据的机制</li>
</ul>
<p>数据竞争可能导致出现BUG, 并且让开发者难以定位和解决问题, 所以Rust在编译时会检查这个问题</p>
<p>当然, 这个限制只是存在于同一个作用域, 例如下面的代码是可以的</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    } <span class="comment">// 可变引用r1退出作用域</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;  <span class="comment">// 可以重新创建</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>在特定作用域的特定数据不能同时拥有可变和不可变引用</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 不可变1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 不可变2</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 可变1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}, {}, and {}"</span>, r1, r2, r3);  <span class="comment">// 会报错, 因为不可变与可变引用无法共存</span></span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>报错</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"> --&gt; src/main.rs:6:14</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> r1 = &amp;s; // 不可变1</span><br><span class="line">  |              -- immutable borrow occurs here</span><br><span class="line">5 |     <span class="built_in">let</span> r2 = &amp;s; // 不可变2</span><br><span class="line">6 |     <span class="built_in">let</span> r3 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |     </span><br><span class="line">8 |     println!(<span class="string">"{}, {}, and {}"</span>, r1, r2, r3);</span><br><span class="line">  |                                -- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line">error: could not compile `ownership`.</span><br></pre></td></tr></tbody></table></figure>
<p>两者不能共存, Rust认为如果你使用了不可变引用. 你一定不希望他在某些时候变化, 所以禁止共存, 但是对于多个不可变引用, 是可以的.</p>
<p>因为都是读取, 就是安全的, 没有办法影响到别人, 所以可以一个作用域可以有多个不可变引用存在</p>
<p>标题所言的是<strong>特定作用域</strong>, 对于引用来说, 他的作用域从声明的地方开始到最后一次使用为止. 如果声明未使用, 那么只存在于声明的那一行, 当然最好不要声明却不使用, 这是不好的习惯</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 不可变1, 未使用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 不可变2, 未使用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s;  <span class="comment">// 可变1, 使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, r3);  <span class="comment">// 这里已经超出了r1和r2的作用域, 因为r1/r2未使用, 作用域只有生成的一行</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 不可变1, 未使用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 不可变2, 未使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{},{}"</span>, r1, r2);  <span class="comment">// 这里是r1/r2最后一次使用, r1/r2作用域到此结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s;  <span class="comment">// 可变1, 使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, r3);  <span class="comment">// 可使用, 当前作用域无不可变引用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="垂悬引用">垂悬引用</h3>
<p>垂悬指针指的是指针指向的内容已经被分配给了其他的持有者.</p>
<p>在Rust中, 编译器确保了永远不会出现这个问题, 因为当你拥有引用时, 编译器会确保数据不会在其引用之前离开作用域</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">dangle</span>();  <span class="comment">// 接收返回的引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, res);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);  <span class="comment">// s进入作用域</span></span><br><span class="line"></span><br><span class="line">    &amp;s  <span class="comment">// 将s的引用返回</span></span><br><span class="line">}  <span class="comment">// 函数结束, s的数据会被清理, 但是s的引用返回出去了</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里的 res 是函数 dangle 内部生成的变量的引用, 但是该函数内部的变量会结束后销毁, 此时你获取到的引用就是错误的, 就会发生悬垂引用的问题, Rust会在编译时予以拦截</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:6:16</span><br><span class="line">  |</span><br><span class="line">6 | fn dangle() -&gt; &amp;String {</span><br><span class="line">  |                ^ <span class="built_in">help</span>: consider giving it a <span class="string">'static lifetime: `&amp;'</span>static`</span><br><span class="line">  |</span><br><span class="line">  = <span class="built_in">help</span>: this <span class="keyword">function</span><span class="string">'s return type contains a borrowed value, but there is no value for it to be borrowed from</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error: aborting due to previous error</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0106`.</span></span><br><span class="line"><span class="string">error: could not compile `ownership`.</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果有这样的需求, 你应该直接返回变量, 而不是他的引用, 这样会发生所有权的移动</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">dangle</span>();  <span class="comment">// 接收返回</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, res);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);  <span class="comment">// s进入作用域</span></span><br><span class="line"></span><br><span class="line">    s  <span class="comment">// 将s返回</span></span><br><span class="line">}  <span class="comment">// 函数结束, s触发了所有权的移动</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="slices">slices</h2>
<p>slice是没有所有权的. slice允许你引用集合中某一短连续的元素序列, 而不引用整个集合</p>
<p>假设有这样的需求, 写一个函数, 接受一个字符串, 返回字符串中的第一个单词. 如果函数在该字符串中没有找到空格, 那么这整个就是一个单词, 如果有空格, 则第一个空格前的是一个单词</p>
<p>初版代码如下</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> {  <span class="comment">// 接收引用, 返回索引</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();  <span class="comment">// 转换成bytes元组</span></span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() {  <span class="comment">// 生成迭代器并循环他</span></span><br><span class="line">        <span class="comment">// i是当前遍历到的索引, &amp;item是当前内容的引用</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> {  <span class="comment">// 如果遇到了空格</span></span><br><span class="line">            <span class="keyword">return</span> i;  <span class="comment">// 将索引return</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到, 证明全部都是一个单词, 所以返回整体的索引</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>s是原本的字符串的引用, 因为我们并不需要该字符串的所有权</p>
<p>我们返回的是该字符串中第一个单词的索引</p>
<p><code>.as_bytes()</code>是将字符串转换成bytes元组, <code>.iter()</code>是返回里面的每一个值, 而<code>.enumerate()</code> 则是接收<code>.iter()</code>返回的值进一步包装. 返回一个元组, 分为索引和值的引用, 当当前字节为空格的时候, 证明需要返回了, 单词结束, 于是将索引直接返回, 当遍历完也没有的时候证明整个字符串都是一个单词, 此时将整个长度返回</p>
<p>这样看起来没什么问题, 但是这里返回的索引长度其实与我们传入的s不是绑定的, 我们在开发中可能遇到这样的问题, 在某一个地方求出结果, 在后面调用时发现不匹配, 原来是源数据被改动了, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>(){</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"word"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">k</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>();  <span class="comment">// 这里调用clear方法, 会获取s的可变引用, 字符串变成初始值, 也就是空串</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, k)  <span class="comment">// k依旧是原来的"word"时的结果</span></span><br><span class="line">    <span class="comment">// 后续中使用 k 就会出现问题, 因为s已经变更</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为 first_word 虽然需要了s的不可变引用, 但是返回值是普通的数字, 与s无关, 所以执行 first_word 之后不可变引用退出作用域了, 所以可以在 clear 里顺利的申请可变引用, 从而修改值</p>
<h3 id="字符串slice">字符串slice</h3>
<p>字符串slice是<code>String</code>中一部分值的引用</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>(){</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"h={},w={}"</span>, h, w)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如上面的代码. <code>&amp;s[0..5]</code>代表引用了s的索引<code>0-5</code>之间的内容, 语法是<code>[start_index..end_index]</code>, start_index是slice中的开始索引, end_index是slice中最后一个位置的后一个值索引. 例如<code>[0..5]</code>实际上是s的索引0到索引4, 也就是字符串<code>hello</code>的引用, 我们运行查看结果</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h=hello,w=world</span><br></pre></td></tr></tbody></table></figure>
<p>这种方法不是引用整个字符串, 而是字符串中的某一段</p>
<p>Rust的<code>..</code>range语法, 还有多种简略写法</p>
<p>如果从索引0开始, 可以忽略0, 可以达到一样的效果</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];  <span class="comment">// he</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];  <span class="comment">// he</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果一直到索引最后, 也可以舍弃尾部的数字</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..len];  <span class="comment">// llo</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..];  <span class="comment">// llo</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果是同时舍弃开头和结尾, 则是将整个字符串获取</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];  <span class="comment">// hello</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];  <span class="comment">// hello</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们将之前的代码修改为新的字符串slice引用的方式, 之后会解释为什么这样做</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() {</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b' '</span> {</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];  <span class="comment">// 返回s的引用, 从0到当前空格的索引</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    &amp;s[..]  <span class="comment">// 全部都是一个单词, 就把整个返回</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>那么这样写的好处是什么呢? 回忆一下借用的规则, 当某个值已经有不可变引用时, 无法生成可变引用了, 对于s来讲,   函数 fiest_word 返回的是s的不可变引用, 而后我们在尝试改变s的值的时候<code>.clear()</code>尝试申请s的可变引用, 这样就会导致编译时出现问题, 避免出现BUG, 我们按照之前的调用, 尝试 <code>.clear()</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">error[E0502]: cannot borrow `s` <span class="keyword">as</span> mutable because it is also borrowed <span class="keyword">as</span> immutable</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">17</span>:<span class="number">5</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">15</span> |     <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line">   |                           -- immutable borrow occurs here</span><br><span class="line"><span class="number">16</span> | </span><br><span class="line"><span class="number">17</span> |     s.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">   |     ^^^^^^^^^ mutable borrow occurs here</span><br><span class="line"><span class="number">18</span> | </span><br><span class="line"><span class="number">19</span> |     <span class="built_in">println!</span>(<span class="string">"the first word is: {}"</span>, word);</span><br><span class="line">   |                                       ---- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0502`.</span><br><span class="line">error: could not compile `ownership`.</span><br></pre></td></tr></tbody></table></figure>
<p>会在编译器就报错, 防止出现BUG</p>
<p><strong>字符串字面值其实就是slice</strong></p>
<p>原来在Rust中, 直接给变量赋值字符串</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"s"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这里, s类型就是 <code>&amp;str</code>, 他是一个指向程序特定内部位置的slice, 所以他是不可变的, 因为就是不可变引用</p>
<p><strong>字符串slice作为参数</strong></p>
<p>修改后的获取单词函数定义是</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> {}</span><br></pre></td></tr></tbody></table></figure>
<p>而更好的方式是定义为</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> {}</span><br></pre></td></tr></tbody></table></figure>
<p>这样的目的是提高兼容性, 上面说了, 使用<code>let s = "s";</code> 类型是 <code>&amp;str</code>, 所以新写法可以兼容这种字符串, 当然对于<code>String</code>类型, 我们可以通过转化成<code>slice</code>来使用</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first_word 中传入 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值就是字符串 slice，</span></span><br><span class="line">    <span class="comment">// 这样写也可以，即不使用 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// &amp;str 也可以继续的生成 slice</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>其他类型的slice</strong></p>
<p>字符串slice里面存放的是字符串, 其实其他类型也是可以的</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = &amp;a[..<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>那么这个slice的类型就是 <code>&amp;[i31]</code>, 使用方法与字符串slice并无区别, 你可以对索引集合使用slice, 具体的信息会在之后详解</p>
<h2 id="总结">总结</h2>
<p>所有权到这里就结束了, 所有权, 借用和slice可以让Rust程序变得更加的安全, 当你耐心的看到这里, 可能你对Rust的独特的编程思想有了大致的理解</p>
<p>Rust设置了诸多限制, 并且希望你写出故意设卡(qia)的代码, 目的是让程序更加安全, 在编译期就把可能出现的问题暴露出来, 让你去主动解决, 而不是在运行时, 或者是生产环境中才出现问题. 这需要开发者时刻留意遵循Rust的规范, 但是这一切都是值得的.</p>
<p>而Rust的所有权系统, 让你无需关注垃圾的回收, 当然搭配作用域/引用/借用一起使用需要开发者关注变量的使用和作用域</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Rust程序设计语言(4)</p><p><a href="https://www.chnmig.com/2021/09/04/rust_programming_language(4)/">https://www.chnmig.com/2021/09/04/rust_programming_language(4)/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ChnMig</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-09-04</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-09-04</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/09/04/rust_programming_language(3)/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Rust程序设计语言(3)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/04/two_auth/"><span class="level-item">浅谈双重认证</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#什么是所有权"><span class="level-left"><span class="level-item">2</span><span class="level-item">什么是所有权</span></span></a></li><li><a class="level is-mobile" href="#栈-stack-与堆-heap"><span class="level-left"><span class="level-item">3</span><span class="level-item">栈(stack)与堆(heap)</span></span></a></li><li><a class="level is-mobile" href="#所有权的基本规则"><span class="level-left"><span class="level-item">4</span><span class="level-item">所有权的基本规则</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#变量作用域"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">变量作用域</span></span></a></li></ul></li><li><a class="level is-mobile" href="#String类型"><span class="level-left"><span class="level-item">5</span><span class="level-item">String类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内存与分配"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">内存与分配</span></span></a></li></ul></li><li><a class="level is-mobile" href="#所有权与函数"><span class="level-left"><span class="level-item">6</span><span class="level-item">所有权与函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#返回值与作用域"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">返回值与作用域</span></span></a></li></ul></li><li><a class="level is-mobile" href="#引用和借用"><span class="level-left"><span class="level-item">7</span><span class="level-item">引用和借用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#可变引用"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">可变引用</span></span></a></li><li><a class="level is-mobile" href="#垂悬引用"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">垂悬引用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#slices"><span class="level-left"><span class="level-item">8</span><span class="level-item">slices</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字符串slice"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">字符串slice</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">9</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a><p class="is-size-7"><span>&copy; 2022 ChnMig</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Contact me" href="mailto:ChnMig@Outlook.com"><i class="far fa-envelope"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ChnMig"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>