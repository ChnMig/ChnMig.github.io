<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Rust程序设计语言(5) - ChnMig的个人网站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ChnMig的个人网站"><meta name="msapplication-TileImage" content="/images/logo.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ChnMig的个人网站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Rust的结构体和枚举使用"><meta property="og:type" content="blog"><meta property="og:title" content="Rust程序设计语言(5)"><meta property="og:url" content="https://www.chnmig.com/2021/09/07/rust_programming_language(5)/"><meta property="og:site_name" content="ChnMig的个人网站"><meta property="og:description" content="Rust的结构体和枚举使用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.chnmig.com/img/og_image.png"><meta property="article:published_time" content="2021-09-06T16:00:00.000Z"><meta property="article:modified_time" content="2021-09-06T16:00:00.000Z"><meta property="article:author" content="ChnMig"><meta property="article:tag" content="Rust"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.chnmig.com/2021/09/07/rust_programming_language(5)/"},"headline":"Rust程序设计语言(5)","image":["https://www.chnmig.com/img/og_image.png"],"datePublished":"2021-09-06T16:00:00.000Z","dateModified":"2021-09-06T16:00:00.000Z","author":{"@type":"Person","name":"ChnMig"},"publisher":{"@type":"Organization","name":"ChnMig的个人网站","logo":{"@type":"ImageObject","url":"https://www.chnmig.com/images/logo.gif"}},"description":"Rust的结构体和枚举使用"}</script><link rel="canonical" href="https://www.chnmig.com/2021/09/07/rust_programming_language(5)/"><link rel="icon" href="/images/logo.ico"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?5306a4ae74c103fc71e3fb36eb8f9609";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">类别</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="http://tongji.baidu.com/web/welcome/ico?s=5306a4ae74c103fc71e3fb36eb8f9609">访问统计</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-06T16:00:00.000Z" title="2021/9/7 上午12:00:00">2021-09-07</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span><span class="level-item">39 分钟读完 (大约5832个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Rust程序设计语言(5)</h1><div class="content"><h2 id="结构体使用结构体来组织关联数据">结构体使用结构体来组织关联数据</h2>
<blockquote>
<p>golang里有同样的类型, 学到这里感觉有点舒服了</p>
<p>struct, 是一个自定义的数据类型, 其中可包含若干个值, 从而形成适合你业务的组合, 比如go的struct(结构体)</p>
</blockquote>
<h3 id="定义和实例化">定义和实例化</h3>
<p>结构体的每一个部分可以是不同的类型, 跟元组不同的是, 结构体需要对每一个数据进行命名, 这是为了定义这个值, 也是为了给这个值声明意义. 因为有了这些名字, 使得结构体比元组更加灵活, 不需要依赖顺序来方式实例中的某一个值, 而是通过其名字.</p>
<p>定义结构体的关键字是 <code>struct</code>, 后面是这个结构体的名字, 一般情况下结构体的名字都应该能体现出这个结构体的作用, 在 <code>{}</code> 中每一个部分, 都被称为一个<code>字段(field)</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> {</span><br><span class="line">    name: <span class="built_in">String</span>,  <span class="comment">// 用户名</span></span><br><span class="line">    email: <span class="built_in">String</span>, <span class="comment">// 邮箱</span></span><br><span class="line">    age: <span class="built_in">u64</span>,      <span class="comment">// 年龄</span></span><br><span class="line">    active: <span class="built_in">bool</span>,  <span class="comment">// 活跃状态</span></span><br><span class="line">}  <span class="comment">// 结构体 User, 代表用户信息</span></span><br></pre></td></tr></tbody></table></figure>
<p>要使用结构体, 我们就需要实例化, 创建实例时需要指定要实例化的结构体是哪个, 并在 <code>{}</code> 内使用 <code>key: value</code> 的形式对某个字段赋值, 注意这里的字段顺序可以与定义结构体时的字段顺序不同</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User {</span><br><span class="line">    name: <span class="built_in">String</span>::from(<span class="string">"user1"</span>),</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    active: <span class="literal">false</span>,</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"user1@outlook.com"</span>)</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>我们也可以在实例化后修改字段的值, 此时这个实例应当是可变的</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User {</span><br><span class="line">    name: <span class="built_in">String</span>::from(<span class="string">"user1"</span>),</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    active: <span class="literal">false</span>,</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"user1@outlook.com"</span>)</span><br><span class="line">};  <span class="comment">// mut 可变</span></span><br><span class="line">user1.age = <span class="number">24</span>  <span class="comment">// 通过 .key 的方式来找到值</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可以将实例作为表达式的返回值</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(name: <span class="built_in">String</span>, email: <span class="built_in">String</span>) -&gt; User{</span><br><span class="line">    User{</span><br><span class="line">        name: name,</span><br><span class="line">        email: email,</span><br><span class="line">        active: <span class="literal">false</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    }</span><br><span class="line">}  <span class="comment">// 返回结构体 User 的实例</span></span><br></pre></td></tr></tbody></table></figure>
<p>注意, 当变量或者参数名和类型与结构体的字段完全一致时, 可以使用简略的写法</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(name: <span class="built_in">String</span>, email: <span class="built_in">String</span>) -&gt; User{</span><br><span class="line">    <span class="keyword">let</span> active = <span class="literal">false</span>;</span><br><span class="line">    User{</span><br><span class="line">        name,  <span class="comment">// name: name, User的字段name与参数name一致</span></span><br><span class="line">        email,  <span class="comment">// email: email, User的字段email与参数email一致</span></span><br><span class="line">        active,  <span class="comment">// active: active, User的字段active与变量active一致</span></span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们也可以借用已经存在的实例的某些字段创建新的实例</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User {</span><br><span class="line">    name: <span class="built_in">String</span>::from(<span class="string">"user1"</span>),</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    active: <span class="literal">false</span>,</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"user1@outlook.com"</span>)</span><br><span class="line">};  <span class="comment">// user1</span></span><br><span class="line"><span class="keyword">let</span> user2 = User {</span><br><span class="line">    name: user1.name,  <span class="comment">// 借用user1的字段</span></span><br><span class="line">    age: user1.age,  <span class="comment">// 借用user1的字段</span></span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"user2@outlook.com"</span>),</span><br><span class="line">    active: <span class="literal">true</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>如果剩下的字段值都使用老的实例的值, 还可以使用简略的写法</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User {</span><br><span class="line">    name: <span class="built_in">String</span>::from(<span class="string">"user1"</span>),</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    active: <span class="literal">false</span>,</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"user1@outlook.com"</span>)</span><br><span class="line">};  <span class="comment">// user1</span></span><br><span class="line"><span class="keyword">let</span> user2 = User {</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"user2@outlook.com"</span>),</span><br><span class="line">    ..user1  <span class="comment">// name/age/active 都使用user1</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="元组结构体">元组结构体</h3>
<p>有时我们想给某个元组定义一个名字, 让这个元组结构可以复用并且与普通元组分开, 此时你可以使用 元组结构体,</p>
<p>元组结构体不同于普通的结构体, 他没有具体的每个字段的名字, 只有字段的类型, 但是整个元组结构体拥有一个名字</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);  <span class="comment">// 元组结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);  <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>上面的 Color 和 Point 虽然都是 i32, 长度为3 的元组, 但是因为不是一个结构体所以无法混用</p>
<p>同时因为没有字段的名字, 想要访问其中某一个值, 可以通过索引来获取</p>
<h3 id="结构体的生命周期">结构体的生命周期</h3>
<p>你可能注意到了, 我们定义的结构体, 并没有使用引用, 比如使用 <code>String</code> 而不是<code>&amp;str</code>, 是因为这设计到了<code>生命周期</code>的概念, 这个是之后的内容, 目前我们需要让这个结构体内的字段的所有权在自己手中, 以便正常运行, 如果你使用了引用, 目前是无法编译的</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> {</span><br><span class="line">    name: &amp;<span class="built_in">str</span>,  <span class="comment">// 用户名</span></span><br><span class="line">    email: <span class="built_in">String</span>, <span class="comment">// 邮箱</span></span><br><span class="line">    age: <span class="built_in">u64</span>,      <span class="comment">// 年龄</span></span><br><span class="line">    active: <span class="built_in">bool</span>,  <span class="comment">// 活跃状态</span></span><br><span class="line">}  <span class="comment">// 结构体 User, 代表用户信息</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:3:15</span><br><span class="line">  |</span><br><span class="line">3 |         name: &amp;str,  // 用户名</span><br><span class="line">  |               ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="built_in">help</span>: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">2 |     struct User&lt;<span class="string">'lifetime&gt; {</span></span><br><span class="line"><span class="string">3 |         name: &amp;'</span>lifetime str,  // 用户名</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `t_struct`.</span><br></pre></td></tr></tbody></table></figure>
<p>等到之后, 我们会讲到怎样解决这个问题</p>
<h3 id="使用结构体编写示例代码">使用结构体编写示例代码</h3>
<p>我们使用之前学的知识, 编写一段代码, 他的功能是求出长方形的面积</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> width1 = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> height1 = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"area={}"</span>, area(width1, height1))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(width: <span class="built_in">u32</span>, height: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>{</span><br><span class="line">    width * height</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码能够完成我们的需求, 但是仔细想, 一个长方形, 长和宽应该是绑定的关系, 如何体现绑定关系呢? 我们将长和宽使用元组绑定到一起</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> rect1 = (<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"area={}"</span>, area(rect1))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(dimensions: (<span class="built_in">u32</span>, <span class="built_in">u32</span>)) -&gt; <span class="built_in">u32</span>{</span><br><span class="line">    dimensions.<span class="number">0</span> * dimensions.<span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样就增加了一些结构性. 但是问题出现了, 使用元组的方式, 我们没法知道哪一个是长, 哪一个是宽, 假如说我们需要根据长宽不同进行不同操作, 比如在屏幕中绘制, 那就可能让调用者产生疑问, 不知道参数的意义</p>
<p>于是我们使用结构体来进行代码的编写</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> rectange1 = Rectangle{</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">        height: <span class="number">30</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"area={}"</span>, area(&amp;rectange1))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> {</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rectangle: &amp;Rectangle) -&gt; <span class="built_in">u32</span>{</span><br><span class="line">    rectangle.height * rectangle.width</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里的函数 <code>area</code> 为了防止所有权的转让, 我们使用了引用的方式</p>
<h3 id="通过派生-trait-增加功能">通过派生 trait 增加功能</h3>
<p>有时候我们想打印一个结构体实例的内容, 使用<code>println!</code>是不行的, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> rectange1 = Rectangle{</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">        height: <span class="number">30</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rec = {}"</span>, rectange1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rectangle` doesn<span class="string">'t implement `std::fmt::Display`</span></span><br><span class="line"><span class="string"> --&gt; src/main.rs:6:26</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">6 |     println!("rec = {}", rectange1);</span></span><br><span class="line"><span class="string">  |                          ^^^^^^^^^ `Rectangle` cannot be formatted with the default formatter</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">  = help: the trait `std::fmt::Display` is not implemented for `Rectangle`</span></span><br><span class="line"><span class="string">  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead</span></span><br><span class="line"><span class="string">  = note: required by `std::fmt::Display::fmt`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error: aborting due to previous error</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0277`.</span></span><br><span class="line"><span class="string">error: could not compile `t_struct`.</span></span><br></pre></td></tr></tbody></table></figure>
<p>这是因为, <code>println!</code> 宏默认使用类型的<code>Display</code>格式输出, 意思是打印出来的输出, 之前所有的基本类型都实现了<code>Display</code>, 但是因为结构体, rust并不知道你想要输出什么, 所以没有提供<code>Display</code>实现</p>
<p>但是rust给了我们建议, 查看输出, 有一行</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">note: <span class="keyword">in</span> format strings you may be able to use `{:?}` (or {:<span class="comment">#?} for pretty-print) instead</span></span><br></pre></td></tr></tbody></table></figure>
<p>似乎是告诉我们应该这样输出, 于是我们将打印修改为</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"rec = {:?}"</span>, rectange1);</span><br></pre></td></tr></tbody></table></figure>
<p>运行后发现还是不行, 但是又给了一个提示</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: `Rectangle` doesn<span class="string">'t implement `std::fmt::Debug`</span></span><br><span class="line"><span class="string"> --&gt; src/main.rs:6:28</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">6 |     println!("rec = {:?}", rectange1);</span></span><br><span class="line"><span class="string">  |                            ^^^^^^^^^ `Rectangle` cannot be formatted using `{:?}`</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">  = help: the trait `std::fmt::Debug` is not implemented for `Rectangle`</span></span><br><span class="line"><span class="string">  = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`</span></span><br><span class="line"><span class="string">  = note: required by `std::fmt::Debug::fmt`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">error: aborting due to previous error</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0277`.</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">= <span class="built_in">help</span>: the trait `std::fmt::Debug` is not implemented <span class="keyword">for</span> `Rectangle`</span><br><span class="line">= note: add `<span class="comment">#[derive(Debug)]` or manually implement `std::fmt::Debug`</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里告诉我们rust确实有打印, 但是是Debug模式, 需要我们显式的开启, 我们将代码修改为</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> rectange1 = Rectangle{</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">        height: <span class="number">30</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rec = {:?}"</span>, rectange1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> {</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.40s</span><br><span class="line">     Running `target/debug/t_struct`</span><br><span class="line">rec = Rectangle { width: 20, height: 30 }</span><br></pre></td></tr></tbody></table></figure>
<p>可以打印出结构体数据了</p>
<p>我们回看新加入的注释, <code>#[derive(Debug)]</code>, 实际上是为结构体 <code>Rectangle</code> 加入了 <code>Debug</code> 的 <code>derive</code>, rust中还有很多这样的用法, 我们之后再说</p>
<h2 id="方法语法">方法语法</h2>
<p>当我们写python的时候, 总会使用到类/方法, 使用类生成对象, 调用对象的方法, 让这个方法与类有紧密的联系</p>
<p>再比如Go, 也有类似的概念, 其实rust也是有的, 依附于结构体<code>struct</code>, 可能更像<code>go</code>, 被称之为结构体的 方法</p>
<h3 id="定义方法">定义方法</h3>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> rectange1 = Rectangle{</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">        height: <span class="number">30</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"area={}"</span>, rectange1.area())  <span class="comment">// 调用结构体定义的方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> {  </span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle{  <span class="comment">// impl 结构体名称</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> {  <span class="comment">// 定义方法 area</span></span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其中, <code>impl</code> 是关键字, 意为定义结构体的方法, 在其中定义了方法<code>area</code>, 注意参数变成了 <code>&amp;self</code>, 学过其他语言的一把都知道这个是代表实例自身, 因为这里我们不想获取实例的所有权, 而是只想获取长和宽, 所以使用了 <code>&amp;</code>, 如果想要在一个方法中修改实例, 可以将参数修改为 <code>&amp;mut self</code></p>
<p>将参数设置为 <code>self</code> 是不常见的, 这代表获取了实例的所有权, 通常只有将<code>self</code> 转换成别的实例时才适用.</p>
<p>调用结构体方法的时候使用 <code>实例.方法</code> 即可, 参数<code>&amp;self</code> 是自己会传递的, 无需手动的写入</p>
<p>在<code>C/C++</code>中, 参数self为指针时, 调用其方法需要<code>-&gt;</code>, 而<code>.</code>是不为指针时调用的方式, 在Rust中会自己为你识别, 而不必关注参数是 <code>slef/ &amp;self/ &amp;mut self</code></p>
<h3 id="带有更多参数的方法">带有更多参数的方法</h3>
<p>很多时候调用方法时肯定需要传入更多参数, 这些参数与实例本身并无联系</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> rectange1 = Rectangle{</span><br><span class="line">        width: <span class="number">20</span>,</span><br><span class="line">        height: <span class="number">30</span></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">let</span> rectange2 = Rectangle{</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span></span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"area={}"</span>, rectange1.area());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r2 can_hold r1 = {}"</span>, rectange1.can_hold(&amp;rectange2))  <span class="comment">// 调用, 额外参数手动指定</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> {  </span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle{</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> {</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> { <span class="comment">// 接受一个额外参数 other 类型是 &amp;Rectangle</span></span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这时候在 <code>self</code> 之后追加即可, 传入参数时需要手动传递, 一样无需传入<code>self</code></p>
<h3 id="关联函数">关联函数</h3>
<p><code>impl</code>还可以定义不需要<code>slef</code>作为参数的函数, 这种被称作 关联函数, 他们与结构体相关联, 但是因为不依赖<code>self</code>, 所以依旧是函数而不是方法, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> sq = Rectangle::square(<span class="number">20</span>);  <span class="comment">// 通过 :: 调用, 因为不依赖实例, 所以不需要通过实例去调用, 直接使用结构体</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> {  </span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle {</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle {  <span class="comment">// 不依赖实例本身</span></span><br><span class="line">        Rectangle { width: size, height: size }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>::</code>的语法是不是很熟悉? 更多的使用方法之后会详解</p>
<h3 id="多个impl块">多个impl块</h3>
<p>每个结构体都允许有多个impl块, 比如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> {  </span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle {</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle {  <span class="comment">// 不依赖实例本身</span></span><br><span class="line">        Rectangle { width: size, height: size }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle {</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> { <span class="comment">// 接受一个额外参数 other 类型是 &amp;Rectangle</span></span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle{</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> {</span><br><span class="line">        <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样是可以正常使用的, 但是一般不建议这样做, 因为没有意义, 可能在特殊的需求下有用, 我们之后会说</p>
<h2 id="枚举与模式匹配">枚举与模式匹配</h2>
<p>枚举(enumerations/ enums)开发者应该都很熟悉, 枚举让你可以通过列举可能的 成员(variants) 来定义一个类型</p>
<h3 id="定义枚举">定义枚举</h3>
<p>通过一个场景来理解枚举, 我们知道, IP地址目前主要有两种, IPv4 和 IPv6, 这两个都属于IP, 假设我们的程序有可能会且只会处理这两种IP, 那么我们可以将两个归属为一起, 当代码在处理IP时将其当做一样的来处理, 我们可以使用 枚举 来做.</p>
<p>定义一个枚举 <code>IpAddrKind</code> 来整合这两种类型, 分别为 <code>v4</code> 和 <code>v6</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> {</span><br><span class="line">    <span class="comment">// 枚举名</span></span><br><span class="line">    v4, <span class="comment">// ipv4</span></span><br><span class="line">    v6, <span class="comment">// ipv6</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在, 对于程序来讲, <code>IpAddrKind</code>是一个可以使用的数据类型了</p>
<h3 id="枚举值">枚举值</h3>
<p>使用定义的枚举</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> four = IpAddrKind::v4;</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::v6;</span><br></pre></td></tr></tbody></table></figure>
<p>枚举的每一个成员都在其枚举的命名空间中, 使用 <code>::</code> 呼出, v4和v6都属于<code>IpAddrKind</code>, 所以可以当做一个类型处理</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> {</span><br><span class="line">    <span class="comment">// 枚举名</span></span><br><span class="line">    v4, <span class="comment">// ipv4</span></span><br><span class="line">    v6, <span class="comment">// ipv6</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">a</span></span>(ip: IpAddrKind){</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> four = IpAddrKind::v4;</span><br><span class="line">    <span class="keyword">let</span> six = IpAddrKind::v6;</span><br><span class="line">    a(four);</span><br><span class="line">    a(six)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果我们想要将IP地址和IP类型形成关联关系, 我们可能优先想到使用结构体</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> {</span><br><span class="line">    <span class="comment">// 枚举名</span></span><br><span class="line">    v4, <span class="comment">// ipv4</span></span><br><span class="line">    v6, <span class="comment">// ipv6</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> {  <span class="comment">// ip地址结构体</span></span><br><span class="line">    address: <span class="built_in">String</span>,  <span class="comment">// ip</span></span><br><span class="line">    kind: IpAddrKind  <span class="comment">// 类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> address1 = IpAddr{</span><br><span class="line">        kind: IpAddrKind::v4,</span><br><span class="line">        address: <span class="built_in">String</span>::from(<span class="string">"123.234.111.222"</span>)</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">let</span> address2 = IpAddr{</span><br><span class="line">        kind: IpAddrKind::v6,</span><br><span class="line">        address: <span class="built_in">String</span>::from(<span class="string">"::1"</span>)</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其实在枚举<code>IpAddrKind</code>时, 我们就已经知道了是<code>v4</code>还是<code>v6</code>, 而在结构体<code>IpAddr</code>中只多出来了字段<code>address</code>, 那么我们可以给枚举设置<code>value</code>, 来让代码更简单</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> {</span><br><span class="line">    <span class="comment">// 枚举名</span></span><br><span class="line">    v4(<span class="built_in">String</span>), <span class="comment">// ipv4, String类型</span></span><br><span class="line">    v6(<span class="built_in">String</span>), <span class="comment">// ipv6, String类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> address1 = IpAddr::v4(<span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line">    <span class="keyword">let</span> address2 = IpAddr::v6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为IP地址实在是太常见了, 很多时候我们都会用到, 所以Rust内置了数据结构专门存放IP地址, <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">IpAddr in std::net - Rust (rust-lang.org)</a>, 内部是这样定义的</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ipv4Addr</span></span> {</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ipv6Addr</span></span> {</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> {</span><br><span class="line">    V4(Ipv4Addr),</span><br><span class="line">    V6(Ipv6Addr),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将枚举的<code>value</code>设置成结构体, 而这个结构体可以存放任何数据, 这样来增加兼容性</p>
<p>因为我们的例子中都没有引用标准库中的定义, 所以即使我们自己定义了<code>IpAddr</code>枚举, 也不会产生冲突</p>
<p>下面我们再看一个新的枚举</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> {</span><br><span class="line">    Quit,</span><br><span class="line">    Move { x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> },</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个枚举<code>Message</code> 下面有4个成员, <code>Quit</code>没有关联任何数据, <code>Move</code>对应一个匿名结构体, <code>Write</code>关联一个元组<code>String</code>, <code>ChangeColor</code>关联一个元组</p>
<p>如果我们单纯使用结构体也可以达到效果</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuitMessage</span></span>; <span class="comment">// 类单元结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MoveMessage</span></span> {</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WriteMessage</span></span>(<span class="built_in">String</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChangeColorMessage</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>); <span class="comment">// 元组结构体</span></span><br></pre></td></tr></tbody></table></figure>
<p>问题是, 这样的话就没有将这几个Message形成关联关系, 如果使用枚举, 因为枚举本身是一种类型, 就能将这些Message以成员的方式合到一起</p>
<p>对于枚举类型, 我们也可以通过使用<code>impl</code>关键字来为枚举类型定义方法(和结构体类似)</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Message {</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) {</span><br><span class="line">        <span class="comment">// 方法call</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">m.call();  <span class="comment">// 调用</span></span><br></pre></td></tr></tbody></table></figure>
<p>具体的调用, self方式, 可以参照上方的结构体impl</p>
<h4 id="option枚举">option枚举</h4>
<p><code>Option</code>是标准库定义的另一个枚举, 他的应用很广泛, 他代表了一个值要么有值要么没值. 你可能现在不明白有什么作用</p>
<p>Rust中没有其他语言有的<code>空值</code>功能, <code>空值(Null)</code>也是一个值, 他代表了没有值. 在其他语言中, 变量都有两种状态: 空值和非空值</p>
<p>Tony Hoare，null 的发明者，在他 2009 年的演讲 “Null References: The Billion Dollar Mistake” 中曾经说到：</p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
<p>我称之为我十亿美元的错误。当时，我在为一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所有引用的使用都应该是绝对安全的。不过我未能抵抗住引入一个空引用的诱惑，仅仅是因为它是这么的容易实现。这引发了无数错误、漏洞和系统崩溃，在之后的四十多年中造成了数十亿美元的苦痛和伤害。</p>
</blockquote>
<p>空值的问题主要在于, 当你想像使用非空值一样使用空值, 就会出现某种形式上的错误, 因为空和非空无处不在, 所以很容易出现这种问题</p>
<p>rust中没有空值, 他有一个在编码时可以存在或者不存在的概念的枚举, 这个就是<code>Option</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; {</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为<code>Option</code>太多常用, 所以不需引用标准库也直接存在, <code>Option</code>下拥有两个成员, <code>Some(T)</code>和<code>None</code>, <code>&lt;T&gt;</code>是我们还没有讲到的功能, 他指的是一个泛类型参数, 目前你可以理解成可以包含任何类型的数据, 我们之后会详细讲解</p>
<p>因为对Option做了特殊处理, 所以Option下面的成员Some和None也可以直接使用, 无需<code>Option::Some</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">"a string"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>如果你使用成员<code>None</code>, 则需要告诉Rust <code>Option</code> 是什么类型, 因为Rust无法自己知道<code>None</code>是什么类型</p>
<p>并且, 因为你通过<code>Option</code>创建的值是<code>Option</code>类型, 他无法直接与普通的类型进行操作</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> sum = x + y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>会报错</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: cannot add `std::option::Option&lt;i8&gt;` to `i8`</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> src/main.rs:5:17</span></span><br><span class="line">  |</span><br><span class="line">5 |     let sum = x + y;</span><br><span class="line">  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`</span><br><span class="line">  |</span><br><span class="line">  = help: the trait `std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is not implemented for `i8`</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `t_enum`.</span><br></pre></td></tr></tbody></table></figure>
<p>告诉你无法将 <code>i8</code> 与 <code>Option&lt;i8&gt;</code> 进行相加, 因为他们的类型不同, 而对于<code>i8</code>这种类型, Rust可以保证他一定是有值的, <code>Option&lt;i8&gt;</code> 也有可能是为<code>None</code>的, Rust为了避免这个错误不允许直接计算.</p>
<p>而要想进行操作, 必须将 <code>Option&lt;T&gt;</code> 转换成 <code>T</code> , 在这个过程中就会让我们预先的处理空值的问题.</p>
<p>当我们发现一个变量为<code>Option&lt;T&gt;</code>是, 牢记可能是空值, 而其他的普通类型, 他一定是非空, 就不用考虑空值的问题</p>
<p>怎么将<code>Option&lt;T&gt;</code>转换成<code>T</code>, 在之后会告诉你, 你也可以查看<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/option/enum.Option.html">Option in std::option - Rust (rust-lang.org)</a></p>
<h3 id="match控制流运算符">match控制流运算符</h3>
<p>类似<code>Golang</code>有<code>switch</code>语法, <code>Python</code>可以使用<code>else if</code> ,达到对某个值进行多个分支判断的逻辑, <code>Rust</code>里当然也是有的, <code>match</code>, Rust会在编译期检查所有可能的情况你都做了处理, 当匹配到符合条件的分支时, 就进入对应<code>模式</code>的代码中处理</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span>{  <span class="comment">// 枚举</span></span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> {</span><br><span class="line">    <span class="keyword">match</span> coin {  <span class="comment">// match</span></span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面是一个枚举和以枚举成员当做模式的<code>match</code>表达式</p>
<p>这里的函数<code>value_in_cents</code> 接收一个枚举的实例, 然后进入<code>match</code>表达式, <code>match</code>关键字之后跟一个表达式, 在这里跟的是<code>coin</code>的实例. 没错, <code>match</code>之后可以跟任何类型.</p>
<p>而<code>{}</code>中的则是这个<code>match</code>的分支, 对于分支来讲, 有两个部分组成, 一个模式和一些代码. 比如第一个分支 <code>Coin::Penny =&gt; 1</code> , 这里的<code>Coin::Penny</code>就是模式, <code>=&gt;</code> 后跟的就是代码, 当匹配到模式之后, 会运行定义的代码</p>
<p>一个<code>match</code>有多个分支, 在匹配时, 会从上到下匹配, 直到匹配成功后就退出<code>match</code></p>
<p>匹配到的代码如果很短, 通常不使用大括号, 如果有多行代码则需要使用, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> {</span><br><span class="line">    <span class="keyword">match</span> coin {  <span class="comment">// match</span></span><br><span class="line">        Coin::Penny =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Penny"</span>);  <span class="comment">// 打印</span></span><br><span class="line">            <span class="number">1</span>  <span class="comment">// 返回</span></span><br><span class="line">        },</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="绑定值的模式">绑定值的模式</h3>
<p>枚举可能是有值的, <code>match</code> 同样也可以获取到枚举实例的值</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span>  <span class="comment">// debug</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> {</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> {</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime(<span class="built_in">u8</span>),</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们为枚举<code>Coin</code>的成员<code>Quarter</code> 设置值为另一个枚举</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> {</span><br><span class="line">    <span class="keyword">match</span> coin {</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from {:?}!"</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在 <code>match</code> 时, 如果是 <code>Quarter</code> 则打印其值</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span>  <span class="comment">// debug</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> {</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> {</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime(<span class="built_in">u8</span>),</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u8</span> {</span><br><span class="line">    <span class="keyword">match</span> coin {</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime(v) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}"</span>, v);</span><br><span class="line">            <span class="number">8</span></span><br><span class="line">        },</span><br><span class="line">        Coin::Quarter(state) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from {:?}!"</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){</span><br><span class="line">    <span class="keyword">let</span> d = Coin::Dime(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> q = Coin::Quarter(UsState::Alaska);</span><br><span class="line">    <span class="keyword">let</span> dp = value_in_cents(d);</span><br><span class="line">    <span class="keyword">let</span> qp = value_in_cents(q);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>在这里使用<code>cargo run</code> 会出现几个报警, 这是因为没有将一些枚举使用起来, 这里不作理会</p>
</blockquote>
<p>使用<code>()</code>的方式可以接受处理枚举中包含值的情况</p>
<h3 id="匹配-Option-T">匹配 <code>Option&lt;T&gt;</code></h3>
<p><code>match</code>同样可以处理<code>Option&lt;T&gt;</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; {</span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){</span><br><span class="line">    <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">    <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为<code>Optione&lt;T&gt;</code>可能存在为<code>None</code>的情况, 所以通过<code>match</code>进行分别处理, 这里的<code>x</code> 就是为<code>None</code>时不做任何处理, 有值时进行 +1 处理</p>
<h3 id="匹配是穷尽的">匹配是穷尽的</h3>
<p>Rust的匹配是穷尽的, 你必须为<code>match</code>设置能覆盖所有情况的分支, 否则会编译失败</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; {</span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; <span class="literal">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){</span><br><span class="line">    <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">error[E0004]: non-exhaustive patterns: `None` not covered</span><br><span class="line"> --&gt; src/main.rs:2:11</span><br><span class="line">  |</span><br><span class="line">2 |     match x {</span><br><span class="line">  |           ^ pattern `None` not covered</span><br><span class="line">  |</span><br><span class="line">  = <span class="built_in">help</span>: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms</span><br><span class="line"></span><br><span class="line">warning: unused variable: `six`</span><br><span class="line"> --&gt; src/main.rs:9:9</span><br><span class="line">  |</span><br><span class="line">9 |     <span class="built_in">let</span> six = plus_one(five);</span><br><span class="line">  |         ^^^ <span class="built_in">help</span>: consider prefixing with an underscore: `_six`</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="comment">#[warn(unused_variables)]` on by default</span></span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0004`.</span><br><span class="line">error: could not compile `t_enum`.</span><br></pre></td></tr></tbody></table></figure>
<p>这里就是没有处理为<code>None</code>的情况, Rust会避免出现这种问题</p>
<h3 id="通配符"><code>_</code>通配符</h3>
<p>其他语言类似的分支处理, 通常会有一个default, 如果都匹配不上, 则会进入default分支, 通常default分支是写在最后的</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> some_u8_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">match</span> some_u8_value {</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"five"</span>),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">"seven"</span>),</span><br><span class="line">        _ =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"kkkkk"</span>)</span><br><span class="line">        },</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Rust有一个<code>_</code>, 作用是通配符, 能匹配所有的情况</p>
<p>比如这里, 如果<code>some_u8_value</code>不是<code>1/3/5/7</code>的其中一个, 则最后会匹配到<code>_</code>分支</p>
<p><code>_</code>分支需要写在最后, 因为他是通配的, 假如写在第一位, 那么所有的值都能匹配进<code>_</code>, 这样就会导致逻辑出现问题</p>
<h2 id="if-let简单控制流"><code>if let</code>简单控制流</h2>
<p>如果有需求, 如果值为3则进行操作, 其他则不处理</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){</span><br><span class="line">    <span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">match</span> some_u8_value {</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>实际上, 如果使用<code>match</code>的话, 为了适应无穷性, 必须进行通配符适配, 难免会增加样板代码, 不简洁</p>
<p>Rust提供了<code>if let</code>, 来处理只匹配一个模式忽略其他模式的情况</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){</span><br><span class="line">    <span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>if let</code> 后跟一个由<code>=</code>分割的模式和表达式, 比如这里, <code>Some(3)</code>就是模式, 表达式是</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当模式匹配后进行表达式的运行, 不匹配则不运行, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){</span><br><span class="line">    <span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value {  <span class="comment">// 不运行</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"three"</span>);  </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>相比普通的<code>match</code> 更加简单, 但是, 这种写法会失去编译时的穷尽检查, 让代码可能会超出你期望的方式运行, 因此使不使用需要自己衡量</p>
<p><code>if let</code> 也可以加 <code>else</code> , 作用与通配符<code>_</code>一致, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){</span><br><span class="line">    <span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"other"</span>)  <span class="comment">// 打印</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也可以和多个 <code>if let</code> 一起使用</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> some_u8_value = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_u8_value {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">4</span>) = some_u8_value {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"four"</span>)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"other"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>需要说明的是, 如果多个分支了, 最好还是使用 <code>match</code>, 这样反而会提高代码简洁性</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Rust程序设计语言(5)</p><p><a href="https://www.chnmig.com/2021/09/07/rust_programming_language(5)/">https://www.chnmig.com/2021/09/07/rust_programming_language(5)/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ChnMig</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-09-07</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-09-07</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/09/09/dramatiq_pit/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Dramatiq遇到的坑</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/05/grpc_use_http2/"><span class="level-item">为什么gRPC使用HTTP2而不是WebSocket</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#结构体使用结构体来组织关联数据"><span class="level-left"><span class="level-item">1</span><span class="level-item">结构体使用结构体来组织关联数据</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定义和实例化"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">定义和实例化</span></span></a></li><li><a class="level is-mobile" href="#元组结构体"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">元组结构体</span></span></a></li><li><a class="level is-mobile" href="#结构体的生命周期"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">结构体的生命周期</span></span></a></li><li><a class="level is-mobile" href="#使用结构体编写示例代码"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">使用结构体编写示例代码</span></span></a></li><li><a class="level is-mobile" href="#通过派生-trait-增加功能"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">通过派生 trait 增加功能</span></span></a></li></ul></li><li><a class="level is-mobile" href="#方法语法"><span class="level-left"><span class="level-item">2</span><span class="level-item">方法语法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定义方法"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">定义方法</span></span></a></li><li><a class="level is-mobile" href="#带有更多参数的方法"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">带有更多参数的方法</span></span></a></li><li><a class="level is-mobile" href="#关联函数"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">关联函数</span></span></a></li><li><a class="level is-mobile" href="#多个impl块"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">多个impl块</span></span></a></li></ul></li><li><a class="level is-mobile" href="#枚举与模式匹配"><span class="level-left"><span class="level-item">3</span><span class="level-item">枚举与模式匹配</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定义枚举"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">定义枚举</span></span></a></li><li><a class="level is-mobile" href="#枚举值"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">枚举值</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#option枚举"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">option枚举</span></span></a></li></ul></li><li><a class="level is-mobile" href="#match控制流运算符"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">match控制流运算符</span></span></a></li><li><a class="level is-mobile" href="#绑定值的模式"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">绑定值的模式</span></span></a></li><li><a class="level is-mobile" href="#匹配-Option-T"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">匹配 Option&lt;T&gt;</span></span></a></li><li><a class="level is-mobile" href="#匹配是穷尽的"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">匹配是穷尽的</span></span></a></li><li><a class="level is-mobile" href="#通配符"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">_通配符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#if-let简单控制流"><span class="level-left"><span class="level-item">4</span><span class="level-item">if let简单控制流</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a><p class="is-size-7"><span>&copy; 2022 ChnMig</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Contact me" href="mailto:ChnMig@Outlook.com"><i class="far fa-envelope"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ChnMig"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.15.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.15.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.15.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.15.1/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>