<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Rust程序设计语言(7) - ChnMig的个人网站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ChnMig的个人网站"><meta name="msapplication-TileImage" content="/images/logo.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ChnMig的个人网站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Rust开发中常见的集合和基本的使用方法"><meta property="og:type" content="blog"><meta property="og:title" content="Rust程序设计语言(7)"><meta property="og:url" content="https://www.chnmig.com/2021/11/26/rust_programming_language(7)/"><meta property="og:site_name" content="ChnMig的个人网站"><meta property="og:description" content="Rust开发中常见的集合和基本的使用方法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.chnmig.com/img/og_image.png"><meta property="article:published_time" content="2021-11-25T16:00:00.000Z"><meta property="article:modified_time" content="2021-11-26T16:00:00.000Z"><meta property="article:author" content="ChnMig"><meta property="article:tag" content="Rust"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.chnmig.com/2021/11/26/rust_programming_language(7)/"},"headline":"Rust程序设计语言(7)","image":["https://www.chnmig.com/img/og_image.png"],"datePublished":"2021-11-25T16:00:00.000Z","dateModified":"2021-11-26T16:00:00.000Z","author":{"@type":"Person","name":"ChnMig"},"publisher":{"@type":"Organization","name":"ChnMig的个人网站","logo":{"@type":"ImageObject","url":"https://www.chnmig.com/images/logo.gif"}},"description":"Rust开发中常见的集合和基本的使用方法"}</script><link rel="canonical" href="https://www.chnmig.com/2021/11/26/rust_programming_language(7)/"><link rel="icon" href="/images/logo.ico"><link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/5.12.1/css/all.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?8c2572cbfe4082d1fcd1327e4614cf34";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://lib.baomitu.com/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://lib.baomitu.com/outdated-browser/1.1.5/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://lib.baomitu.com/pace/1.2.4/pace.min.js"></script><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">类别</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://tongji.baidu.com/web/welcome/ico?s=8c2572cbfe4082d1fcd1327e4614cf34">访问统计</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-25T16:00:00.000Z" title="2021/11/26 00:00:00">2021-11-26</time>发表</span><span class="level-item"><time dateTime="2021-11-26T16:00:00.000Z" title="2021/11/27 00:00:00">2021-11-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span><span class="level-item">32 分钟读完 (大约4793个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Rust程序设计语言(7)</h1><div class="content"><h2 id="前言-15">前言</h2>
<blockquote>
<p>最近真的有点焦虑啊, 难受了</p>
</blockquote>
<p>Rust 的标准库中有一些我们常用的数据结构, 帮助我们更快更好的开发代码, 这种数据结构被称为<code>集合</code>, 大部分其他的数据结构, 比如<code>int</code>大多数只能代表一个值, 而集合可以有多个值</p>
<p>当然我们之前提到的 数组, 元组, 也是可以存储多个值, 但是他们是将数据存储在 栈 上的, 之前我们说过, 栈上的数据是需要在分配时就指定其大小, 所以对于动态的可变的数据集合, 最好还是存在堆上, 集合就是这样, 所以一般而言, 使用本篇介绍的集合结构的时候通常比较多, 本篇介绍3个在 Rust程序中被广泛使用的集合</p>
<ul>
<li>vector可以一个接一个的存储一系列数量可变的值</li>
<li>字符串(string)是字符的集合</li>
<li>哈希 map(hash map)可以将值和特定的键绑定, 和 <code>python</code> 的 <code>dict</code> 以及 <code>golang</code>的 <code>map</code> 类似</li>
</ul>
<h2 id="vector">vector</h2>
<p>vector 类型是<code>Vec&lt;T&gt;</code>, vector 的特点是他的多个值都在内存中彼此相邻的排列在一起, 这样会提高查找和操作的速度, 一个 vec 下的所有值的类型必须相同</p>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec in std::vec - Rust (rust-lang.org)</a></p>
<h3 id="新建">新建</h3>
<p>可以使用<code>Vec::new</code>来新建一个空的<code>Vec</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();  <span class="comment">// 新建一个 Vec, Vec 内部的值类型是 i32, 现在还没有具体的值</span></span><br></pre></td></tr></tbody></table></figure>
<p>这一句的作用是新建一个空的 Vec 类型, 此时因为没有给 Vec 设置指定的值, 所以 Rust 是不知道这个 Vec 需要存储的值的类型, 这里我们在新建时就使用<code>Vec&lt;i32&gt;</code>来设置里面存储的值的类型</p>
<p>还有一种方法</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// 新建一个 Vec. 在创建时就插入3个值 1, 2, 3</span></span><br></pre></td></tr></tbody></table></figure>
<p>注意到, <code>vec!</code>这是一个宏, 这个宏会根据我们提供的值来创建 Vector, 同时自己判断值的类型并给这个 vec 进行设置, 这里就是自己推断出是 i32 类型</p>
<h3 id="更新">更新</h3>
<p>使用<code>push</code>里可以项 vec 里增加值</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();  <span class="comment">// 新建一个 Vec, Vec 内部的值类型是 i32, 现在还没有具体的值</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v1 = <span class="built_in">Vec</span>::new();  <span class="comment">// 空的 vec, 类型还没有指定</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v2 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>];  <span class="comment">// vec</span></span><br><span class="line">v.push(<span class="number">3</span>);  <span class="comment">// 新增</span></span><br><span class="line">v1.push(<span class="number">3</span>);  <span class="comment">// 这里是先获取到值的类型, 设置 vec 的类型, 再新增到 v1</span></span><br><span class="line">v2.push(<span class="number">3</span>);  <span class="comment">// 新增</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>push</code>可以更新 vec 的值, 准确说是追加</p>
<p>这里的 v1 , 在新建时没有指定类型, 而是在 push 时靠 rust 自己判断, 也是可以的</p>
<h3 id="释放">释放</h3>
<p><code>vector</code>在其离开作用域时会被释放掉</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理变量 v</span></span><br><span class="line"></span><br><span class="line">} <span class="comment">// &lt;- 这里 v 离开作用域并被丢弃</span></span><br></pre></td></tr></tbody></table></figure>
<p>当 vector 被丢弃, 里面的值也会被丢弃</p>
<h3 id="读取">读取</h3>
<p>读取 vector 的值可以使用索引和<code>get</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];  <span class="comment">// 获取索引2的值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The third element is {}"</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) {  <span class="comment">// 使用 get 获取索引2的值, 没有就是 None, 这里使用 match 判断</span></span><br><span class="line">    <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">"The third element is {}"</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"There is no third element."</span>),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于直接获取索引的方式, 如果索引超出了范围, 比如只有3个值, 结果你获取索引3, 就会导致程序发生 panic, 直接崩溃</p>
<p>使用<code>get</code>, 如果超出索引, 只会返回<code>None</code>, 所以一般使用 get 来防止程序崩溃</p>
<p>下面再看一个代码</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];  <span class="comment">// 可变的 vec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];  <span class="comment">// 借用 v 的第0个值</span></span><br><span class="line"></span><br><span class="line">v.push(<span class="number">6</span>);  <span class="comment">// 给 v 追加值6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"The first element is: {}"</span>, first);  <span class="comment">// 触发了 panic</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个代码实际上会报错</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  t_vec git:(master) ✗ cargo run </span><br><span class="line">   Compiling t_vec v0.1.0 (/Users/Work/Code/Rust/student/t_vec)</span><br><span class="line">warning: unused variable: `first`</span><br><span class="line"> --&gt; src/main.rs:4:9</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> first = &amp;v[0];</span><br><span class="line">  |         ^^^^^ <span class="built_in">help</span>: consider prefixing with an underscore: `_first`</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="comment">#[warn(unused_variables)]` on by default</span></span><br><span class="line"></span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.32s</span><br><span class="line">     Running `target/debug/t_vec`</span><br></pre></td></tr></tbody></table></figure>
<p>之前在所有权那里, 你已经知道了, 可变引用和不可变是无法同时存在的, 这里的 first 是不可变引用, 随后 v 自己进行了追加操作, 而后再打印 first (不可变引用)就触发了冲突, 为什么对 v 进行 push 会对所有权进行转移? 这是因为 vector 之前说过, 里面的每个值在内存中是相邻的, 但是系统的内存分配并不受 rust 控制, 会出现这种情况, 本来这个 vec 长度为3, 于是 rust 在内存中存储了长度为3的数据, 此时别的软件也向系统申请了内存, 在你的数据之后, 与你的数据相邻, 此时你获取了索引为0的地址, 而后进行 push 操作, 新增一个值, 此时因为内存中你的相邻处已经被其他值占领, 于是rust 只能再请求一个新的长度为4的地址,把4个值重新放入新的地址保证相邻, 你再去访问之前的索引为0的地址, 此时这个地址的所有权就不在你的手上了, 所以 rust 不允许你进行操作了.</p>
<h3 id="遍历">遍历</h3>
<p>如果想要依次访问 vector 中的每一个元素, 我们可以对这个 vec 进行遍历</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也可以遍历时对齐进行修改</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v {</span><br><span class="line">    *i += <span class="number">50</span>;  <span class="comment">// 值增加50</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="搭配枚举使用">搭配枚举使用</h3>
<p>vector 还有一个方便的特点是, 他也可以存储相同枚举的值, 因为他认为枚举也是同一个类型, 如果我们想要在一个 vec 中存储不同类型的值, 可以将这些类型设置为同一个枚举的成员</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> {</span><br><span class="line">    Int(<span class="built_in">i32</span>),</span><br><span class="line">    Float(<span class="built_in">f64</span>),</span><br><span class="line">    Text(<span class="built_in">String</span>),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">"blue"</span>)),</span><br><span class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">];  <span class="comment">// 可行, 此时他的类型是枚举 SpreadsheetCell</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="其他">其他</h3>
<p>vector 还有很多其他的方法, 比如<code>pop</code>可以删除最后一位值, 具体的可以查看 api 文档</p>
<h2 id="字符串">字符串</h2>
<p>我们之前使用过字符串, 而本章我们会深入的了解字符串</p>
<h3 id="什么是字符串">什么是字符串</h3>
<blockquote>
<p>你真的了解字符串吗?</p>
</blockquote>
<p>rust 中只有一种字符串类型, 那就是<code>str</code>, 对于字符串slice, 他通常是 str 的借用, 也就是<code>&amp;str</code></p>
<p><code>string</code>类型是标准库提供的, 并没有写进核心语言部分, 他是可以增长的, 可以变动的, 有所有权的, 编码是 UTF-8的字符串类型</p>
<h3 id="新建-2">新建</h3>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::new();</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码是新建了一个空的字符串 s, 然后我们可以给 s 填充数据, 但是通常我们会直接初始化失败时指定数据, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">"initial contents"</span>;  <span class="comment">// 字符串字面值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = data.to_string();  <span class="comment">// 使用 to_string 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法也可直接用于字符串字面值：</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">"initial contents"</span>.to_string();  <span class="comment">// 更加简单的写法</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"initial contents"</span>);  <span class="comment">// 更加简单的写法2</span></span><br></pre></td></tr></tbody></table></figure>
<p>只要某个类型实现了<code>Display</code>类型, 他就可以使用 <code>to_string</code> 方法来转换成字符串</p>
<p>对于这两种简单写法, 并没有什么优劣, 所以按需使用</p>
<p>rust 中的字符串编码为<code>utf-8</code>, 所以他能放入任何可以正确编码的数据</p>
<h3 id="更新-2">更新</h3>
<p>string的大小可以增加, 内容也可以修改</p>
<p><strong>使用<code>push_str</code>和<code>push</code>来追加字符串</strong></p>
<p>使用<code>push_str</code>来追加字符串 slice</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line">s.push_str(<span class="string">"bar"</span>);  <span class="comment">// s 为 foobar</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里对 s 使用<code>push_str</code>, 对 s 进行字符串的追加, 同时, 为了保证所有权不转移, <code>push_str</code>使用的是字符串 slice</p>
<p>使用<code>push</code>来追加字符(不是字符串)</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"lo"</span>);</span><br><span class="line">s.push(<span class="string">'l'</span>);  <span class="comment">// s = lol</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>使用 + 运算符或者 fromat! 宏拼接字符串</strong></p>
<p>你还可以使用<code>+</code>方便的组合字符串</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"Hello, "</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"world!"</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里的 s3 会成为 <code>Hello, world!</code> , 注意代码 <code>s1 + &amp;s2</code>, 这是因为<code>+</code>使用的函数定义为</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, s: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> {</span><br></pre></td></tr></tbody></table></figure>
<p>其中, self 是 s1, s 为 <code>&amp;s2</code>, 这里要求参数是引用, 避免参数 s 的所有权发生转移. 其次, 我们注意这个参数类型是 str 的引用, 而 s2是 String 类型, 为什么能编译运行呢?</p>
<p>这是因为<code>&amp;String</code>可以被强转成<code>&amp;str</code>, 在调用+时, Rust 使用了强制转换, 将其变成&amp;str</p>
<p>这里说的 s1的所有权被移动了, 是因为参数<code>self</code>获取了所有权, 此时所有权到了<code>add</code>中, 所以下面使用 s1会造成错误</p>
<p>还可以使用宏<code>format!</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"tic"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"tac"</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">"toe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">"{}-{}-{}"</span>, s1, s2, s3);</span><br></pre></td></tr></tbody></table></figure>
<p>类似于 golang 的 fmt.Printf, 就是格式化字符串</p>
<h3 id="索引字符串">索引字符串</h3>
<p>很多类型都可以使用索引来访问其中某个元素, 但是对于字符串, 则是不行的, 字符串并不支持使用索引语法</p>
<p><strong>内部实现</strong></p>
<p><code>String</code>是一个<code>Vec&lt;u8&gt;</code>的封装, 比如字符串<code>Hola</code>在Rust 中的长度是四个字节, 这是正确的, 因为每个字母的 utf8 编码都占用1格子姐, 那么字符串<code>дравствуйте</code>则不同, 字符串<code>дравствуйте</code>的长度为22, 这是因为<code>дравствуйте</code>的每一个字符需要两个字节存储, 他是unicode 编码, 但是按照索引来获取, 是按照字节去寻址, 那么问题就出现了, 你获取<code>дравствуйте</code>的索引0, 不是<code>д</code>, 而是<code>д</code>的一部分, 这就不是你想要获取到的结果了</p>
<p>所以 rust 为了避免出现问题, 将这个功能屏蔽了</p>
<p>其实 rust 也可以分辨出哪些存储多少字节, 而在你获取索引时对不同情况做特殊的处理, 但是这样的话势必会造成性能的损耗, rust 还需要多次的判断和遍历才能获取到你想要的结果, 而 Rust 期望获取值的时间为<code>(O(1))</code></p>
<p><strong>使用字符串 slice</strong></p>
<p>如果我们就是想要使用索引, 这里有一个危险的方法</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">"дравствуйте"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];  <span class="comment">// др</span></span><br></pre></td></tr></tbody></table></figure>
<p>获取<code>дравствуйте</code>的前4个字节, 之前说过俄语是两个字节为一个字符, 所以这里是前两个字符</p>
<p>如果你获取的是 <code>[0..1]</code>, 因为顾头不顾尾原则, 实际上获取的是<code>д</code>的一部分, 那么此时会导致<code>Panic</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="string">'main'</span> panicked at <span class="string">'byte index 1 is not a char boundary; it is inside '</span>З<span class="string">' (bytes 0..2) of `дравствуйте`'</span>, src/libcore/str/mod.rs:2188:4</span><br></pre></td></tr></tbody></table></figure>
<p>所以非常不推荐使用这个方法</p>
<p><strong>遍历字符串</strong></p>
<p>Rust 提供了一种方法可以让你遍历字符串, 这是安全的, 而且是按照字符遍历而不是字节</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"дравствуйте"</span>);</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s.chars(){</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, c)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">д</span><br><span class="line">р</span><br><span class="line">а</span><br><span class="line">в</span><br><span class="line">с</span><br><span class="line">т</span><br><span class="line">в</span><br><span class="line">у</span><br><span class="line">й</span><br><span class="line">т</span><br><span class="line">е</span><br></pre></td></tr></tbody></table></figure>
<p>而当你想遍历每一个原始字节, 使用<code>.bytes()</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"дравствуйте"</span>);</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s.bytes(){</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, c)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">208</span><br><span class="line">180</span><br><span class="line">209</span><br><span class="line">128</span><br><span class="line">208</span><br><span class="line">176</span><br><span class="line">208</span><br><span class="line">178</span><br><span class="line">209</span><br><span class="line">129</span><br><span class="line">209</span><br><span class="line">130</span><br><span class="line">208</span><br><span class="line">178</span><br><span class="line">209</span><br><span class="line">131</span><br><span class="line">208</span><br><span class="line">185</span><br><span class="line">209</span><br><span class="line">130</span><br><span class="line">208</span><br><span class="line">181</span><br></pre></td></tr></tbody></table></figure>
<p>这里的每个数字都是每个字节的 ascii 对照</p>
<h2 id="哈希-map">哈希 map</h2>
<p>哈希 map 其他语言也有, 比如 golang 的 map, python 的 dict, 在 Rust 中他是<code>HashMap&lt;k, v&gt;</code>, 他的结构是一个键类型<code>k</code>对应一个值类型<code>v</code>, 他通过哈希函数来实现两者的映射管理, 你可以很方便的通过某个 k 找到对应的 v</p>
<h3 id="新建-3">新建</h3>
<p>使用<code>new</code>创建一个空的<code>HashMap</code>, 使用<code>insert</code>来增加元素</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();  <span class="comment">// hashmap</span></span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);  <span class="comment">// Blue: 10</span></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);  <span class="comment">// Yellow: 50</span></span><br></pre></td></tr></tbody></table></figure>
<p>因为 hashmap 相对于 vector 和 string 来说并不是那么常用, 所以并没有默认就导入, 所以需要通过 <code>use std::collections::HashMap;</code> 来导入到当前的代码中</p>
<p>我们之前说过集合都是将数据存放在堆上的 所以可以方便的进行扩容, 而与 vector 相同的是, 哈希 map 是同质的, 所有的键都必须是相同的类型, 值也是</p>
<p>另一种构建哈希 map 的方式调用一个 vector 的<code>collect</code>方法, 这个 vector 必须是元组类型, 例如</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams  = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();</span><br></pre></td></tr></tbody></table></figure>
<p>这里是使用 <code>zip</code> 将两个 vector 组合, 再使用<code>collect</code>将其转换成一个 hashmap</p>
<p><code>HashMap&lt;_, _&gt;</code> 是必须要标记的, 他代表 <code>collect</code> 输出的结构. 必须要显式的指定才可以, 其中的<code>_</code>代表占位</p>
<h3 id="所有权">所有权</h3>
<p>hashmap 也有所有权, 对于像<code>i32</code>这种实现了<code>Copy</code>的 trait 的类型, 其值可以拷贝进哈希 map. 对于像<code>string</code>的拥有所有权的值, 其值将被移动到哈希 map 中, 成为这个值的所有者</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> field_name = <span class="built_in">String</span>::from(<span class="string">"Favorite color"</span>);</span><br><span class="line"><span class="keyword">let</span> field_value = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">map.insert(field_name, field_value);  <span class="comment">// 插入</span></span><br><span class="line"><span class="comment">// 这里 field_name 和 field_value 不再有效，</span></span><br><span class="line"><span class="comment">// 尝试使用它们看看会出现什么编译错误！</span></span><br></pre></td></tr></tbody></table></figure>
<p>而将值的引用插入到哈希 map 中时, 这些值本身不会被移动到 map 中</p>
<h3 id="访问哈希-map-值">访问哈希 map 值</h3>
<p><strong>get</strong></p>
<p>使用 <code>get</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);  <span class="comment">// 插入</span></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"><span class="keyword">let</span> score = scores.get(&amp;team_name);  <span class="comment">// 获取key Blue 的值</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果 key blue 不存在, 则会返回<code>None</code></p>
<p><strong>循环</strong></p>
<p>使用 for 循环来遍历键值对</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}: {}"</span>, key, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>特别注意, 因为是 hash 的方式, 所以 hashmap key是无序的</p>
<h3 id="更新哈希-map">更新哈希 map</h3>
<p><strong>覆盖</strong></p>
<p>对于已经存在的 key, 我们可以直接覆盖这个 key 下的值, 直接使用<code>insert</code>即可</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{:?}"</span>, scores);  <span class="comment">// 25</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>只新建不覆盖</strong></p>
<p>你可以能注意, 使用<code>insert</code>会直接覆盖值, 那么如果我们想只在这个 key 不存在时才插入的话, 配合使用<code>entry</code>即可</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);  <span class="comment">// 不存在再插入</span></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{:?}"</span>, scores);</span><br></pre></td></tr></tbody></table></figure>
<p>entry 返回了一个枚举<code>Entry</code>, 其有一个方法<code>or_insert</code>在建对应的值存在时就返回这个值的可变引用, 如果不存在就将参数作为新值插入并返回可变引用</p>
<p><strong>根据旧值更新</strong></p>
<p>比如对值进行+1而不关注这个值本来的值</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() {  <span class="comment">// 遍历每个字符</span></span><br><span class="line">    <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);  <span class="comment">// 这个字符作为 key 不存在就 set 成0</span></span><br><span class="line">    *count += <span class="number">1</span>;  <span class="comment">// +1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{:?}"</span>, map);</span><br></pre></td></tr></tbody></table></figure>
<p>之前说过, <code>entry</code>不管怎样都会返回值的可变引用, 所以我们直接修改这个引用的值即可</p>
<p><strong>获取可被修改的值</strong></p>
<p>有时候hashmap 重点值存储的可能是 vector 这种集合, 而我们想要获取值并进行 push 或者其他的追加操作, 可以使用<code>get_mut</code></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> company = HashMap::new();</span><br><span class="line">company.insert(<span class="string">"c1"</span>, <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">let</span> c1 = company.get_mut(<span class="string">"c1"</span>);  <span class="comment">// 获取值的可变引用</span></span><br><span class="line">c1.unwrap().push(<span class="number">3</span>)  <span class="comment">// unwrap 是将类型剥离出来, </span></span><br></pre></td></tr></tbody></table></figure>
<p>使用<code>get_mut</code>可以获得值的可变引用, 以便我们直接对其进行修改</p>
<p>同时, <code>unwrap</code>也必不可少, 不使用<code>unwrap</code>时, 运行报错</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no method named `push` found <span class="keyword">for</span> enum `std::option::Option&lt;&amp;std::vec::Vec&lt;{<span class="built_in">integer</span>}&gt;&gt;` <span class="keyword">in</span> the current scope</span><br></pre></td></tr></tbody></table></figure>
<p>此时可以看出来, c1的类型变成了 <code>std::option::Option&lt;&amp;std::vec::Vec&lt;{integer}&gt;&gt;</code>, 被包裹在了Option 中, 我们必须要调用<code>unwrap</code>将其剥离出来, 类型变回<code>&amp;std::vec::Vec&lt;{integer}&gt;</code> 即可</p>
<h2 id="练习题">练习题</h2>
<h3 id="求平均数">求平均数</h3>
<p>给定一系列数字，使用 vector 并返回这个列表的平均数（mean, average）、中位数（排列数组后位于中间的值）和众数（mode，出现次数最多的值；这里哈希 map 会很有帮助）</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">average</span></span>(v: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">f64</span>&gt;) -&gt; <span class="built_in">f64</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> v{</span><br><span class="line">        sum += i</span><br><span class="line">    }</span><br><span class="line">    sum / v.len() <span class="keyword">as</span> <span class="built_in">f64</span>  <span class="comment">// len 返回长度, 类型是 usize, 通过 as 转换成 f64</span></span><br><span class="line">    <span class="comment">// / 是除</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> v0 = <span class="built_in">vec!</span>[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">5.0</span>];</span><br><span class="line">    <span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[-<span class="number">1.0</span>, -<span class="number">2.0</span>, -<span class="number">3.0</span>];</span><br><span class="line">    <span class="keyword">let</span> v0average = average(&amp;v0);</span><br><span class="line">    <span class="keyword">let</span> v1average = average(&amp;v1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"v0 res = {}"</span>, v0average);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"v1 res = {}"</span>, v1average)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里有之前没有写到博客里的 vector 的 len 方法, 返回长度</p>
<h3 id="字符串转换">字符串转换</h3>
<p>将字符串转换为 Pig Latin，也就是每一个单词的第一个辅音字母被移动到单词的结尾并增加 “ay”，所以 “first” 会变成 “irst-fay”。元音字母开头的单词则在结尾增加 “hay”（“apple” 会变成 “apple-hay”）。牢记 UTF-8 编码</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">pig_lation</span></span>(g: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> {  <span class="comment">// 因为 str 必须要在初始化时就要知道其大小, 所以返回 string</span></span><br><span class="line">    <span class="comment">// 转换成 string</span></span><br><span class="line">    <span class="keyword">let</span> general = g.to_string();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> is_vowel = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> vowel = <span class="built_in">vec!</span>[<span class="string">'a'</span>, <span class="string">'i'</span>, <span class="string">'y'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>];</span><br><span class="line">    <span class="comment">// 获取首字母, 查看是元音还是辅音</span></span><br><span class="line">    <span class="comment">// 不能粗暴的直接获取索引0, 需兼容其他语言</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> general.chars(){</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> &amp;vowel{</span><br><span class="line">            <span class="keyword">if</span> i.to_string() == k.to_string() {</span><br><span class="line">                is_vowel = <span class="literal">true</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> is_vowel{</span><br><span class="line">        <span class="comment">// 首字母是元音</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"{}-hey"</span>, general) </span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> p = <span class="built_in">String</span>::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> is_first = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> first_word = <span class="built_in">String</span>::new();</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> general.chars(){</span><br><span class="line">            <span class="keyword">if</span> is_first{</span><br><span class="line">                <span class="comment">// 第一次</span></span><br><span class="line">                first_word = i.to_string();</span><br><span class="line">                is_first = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                p = p+&amp;i.to_string()</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"{}-{}ay"</span>, p, first_word)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() {</span><br><span class="line">    <span class="keyword">let</span> t0 = <span class="string">"apple"</span>;</span><br><span class="line">    <span class="keyword">let</span> t1 = <span class="string">"first"</span>;</span><br><span class="line">    <span class="keyword">let</span> t2 = <span class="string">"苹果"</span>;</span><br><span class="line">    <span class="keyword">let</span> r0 = pig_lation(t0);</span><br><span class="line">    <span class="keyword">let</span> r1 = pig_lation(t1);</span><br><span class="line">    <span class="keyword">let</span> r2 = pig_lation(t2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r0 = {}"</span>, r0);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r1 = {}"</span>, r1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r2 = {}"</span>, r2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="部门控制">部门控制</h3>
<p>使用哈希 map 和 vector，创建一个文本接口来允许用户向公司的部门中增加员工的名字。例如，“Add Sally to Engineering” 或 “Add Amir to Sales”。接着让用户获取一个部门的所有员工的列表，或者公司每个部门的所有员工按照字典序排列的列表。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::{io, collections::HashMap}; <span class="comment">// 引入标准库</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>(){</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CRM"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> company = HashMap::new();</span><br><span class="line">    <span class="keyword">loop</span>{</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"输入所在部门-&gt;"</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> class = <span class="built_in">String</span>::new(); <span class="comment">// 创建一个字符串变量 class</span></span><br><span class="line">        io::stdin() <span class="comment">// 调用函数stdin</span></span><br><span class="line">            .read_line(&amp;<span class="keyword">mut</span> class) <span class="comment">// 调用stdin的方法read_line获取输入值</span></span><br><span class="line">            .expect(<span class="string">"读取失败"</span>); <span class="comment">// 如果获取错误打印警告</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"输入用户名-&gt;"</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> name = <span class="built_in">String</span>::new(); <span class="comment">// 创建一个字符串变量 name</span></span><br><span class="line">        io::stdin() <span class="comment">// 调用函数stdin</span></span><br><span class="line">            .read_line(&amp;<span class="keyword">mut</span> name) <span class="comment">// 调用stdin的方法read_line获取输入值</span></span><br><span class="line">            .expect(<span class="string">"读取失败"</span>); <span class="comment">// 如果获取错误打印警告</span></span><br><span class="line">        <span class="keyword">let</span> ns = company.get_mut(&amp;class);  <span class="comment">// 获取可变引用</span></span><br><span class="line">        <span class="keyword">if</span> ns == <span class="literal">None</span>{</span><br><span class="line">            company.insert(<span class="built_in">format!</span>(<span class="string">"{}"</span>, class), <span class="built_in">vec!</span>[<span class="built_in">format!</span>(<span class="string">"{}"</span>, name)]);  <span class="comment">// 防止所有权转移, 使用 format 重新制造一个 str</span></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            ns.unwrap().push(name)  <span class="comment">// 直接 push</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> company.get_mut(&amp;class).unwrap(){</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}"</span>, i)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>Rust程序设计语言(7)</p><p><a href="https://www.chnmig.com/2021/11/26/rust_programming_language(7)/">https://www.chnmig.com/2021/11/26/rust_programming_language(7)/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ChnMig</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-26</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-11-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Rust/">Rust</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/12/21/skip_gitbook_lock/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">记一次破解 gitbook_lock 密码的过程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/11/11/rust_programming_language(6)/"><span class="level-item">Rust程序设计语言(6)</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言-15"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#vector"><span class="level-left"><span class="level-item">2</span><span class="level-item">vector</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#新建"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">新建</span></span></a></li><li><a class="level is-mobile" href="#更新"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">更新</span></span></a></li><li><a class="level is-mobile" href="#释放"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">释放</span></span></a></li><li><a class="level is-mobile" href="#读取"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">读取</span></span></a></li><li><a class="level is-mobile" href="#遍历"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">遍历</span></span></a></li><li><a class="level is-mobile" href="#搭配枚举使用"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">搭配枚举使用</span></span></a></li><li><a class="level is-mobile" href="#其他"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">其他</span></span></a></li></ul></li><li><a class="level is-mobile" href="#字符串"><span class="level-left"><span class="level-item">3</span><span class="level-item">字符串</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是字符串"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">什么是字符串</span></span></a></li><li><a class="level is-mobile" href="#新建-2"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">新建</span></span></a></li><li><a class="level is-mobile" href="#更新-2"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">更新</span></span></a></li><li><a class="level is-mobile" href="#索引字符串"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">索引字符串</span></span></a></li></ul></li><li><a class="level is-mobile" href="#哈希-map"><span class="level-left"><span class="level-item">4</span><span class="level-item">哈希 map</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#新建-3"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">新建</span></span></a></li><li><a class="level is-mobile" href="#所有权"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">所有权</span></span></a></li><li><a class="level is-mobile" href="#访问哈希-map-值"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">访问哈希 map 值</span></span></a></li><li><a class="level is-mobile" href="#更新哈希-map"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">更新哈希 map</span></span></a></li></ul></li><li><a class="level is-mobile" href="#练习题"><span class="level-left"><span class="level-item">5</span><span class="level-item">练习题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#求平均数"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">求平均数</span></span></a></li><li><a class="level is-mobile" href="#字符串转换"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">字符串转换</span></span></a></li><li><a class="level is-mobile" href="#部门控制"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">部门控制</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a><p class="is-size-7"><span>&copy; 2022 ChnMig</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Contact me" href="mailto:ChnMig@Outlook.com"><i class="far fa-envelope"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ChnMig"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><script src="https://lib.baomitu.com/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://lib.baomitu.com/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://lib.baomitu.com/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://lib.baomitu.com/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.1/katex.min.css"><script src="https://lib.baomitu.com/KaTeX/0.15.1/katex.min.js" defer></script><script src="https://lib.baomitu.com/KaTeX/0.15.1/contrib/auto-render.min.js" defer></script><script src="https://lib.baomitu.com/KaTeX/0.15.1/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://lib.baomitu.com/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://lib.baomitu.com/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>