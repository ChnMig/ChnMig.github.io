<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>uber go code 规范(指导原则) - ChnMig的个人网站</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ChnMig的个人网站"><meta name="msapplication-TileImage" content="/images/logo.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ChnMig的个人网站"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="这里是 uber 团队出的 go 代码规范指南的中文版, 注意只是指南"><meta property="og:type" content="blog"><meta property="og:title" content="uber go code 规范(指导原则)"><meta property="og:url" content="https://www.chnmig.com/2021/04/18/uber_guide_principles/"><meta property="og:site_name" content="ChnMig的个人网站"><meta property="og:description" content="这里是 uber 团队出的 go 代码规范指南的中文版, 注意只是指南"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.chnmig.com/img/og_image.png"><meta property="article:published_time" content="2021-04-17T16:00:00.000Z"><meta property="article:modified_time" content="2021-06-12T16:00:00.000Z"><meta property="article:author" content="ChnMig"><meta property="article:tag" content="Golang"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://www.chnmig.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.chnmig.com/2021/04/18/uber_guide_principles/"},"headline":"uber go code 规范(指导原则)","image":["https://www.chnmig.com/img/og_image.png"],"datePublished":"2021-04-17T16:00:00.000Z","dateModified":"2021-06-12T16:00:00.000Z","author":{"@type":"Person","name":"ChnMig"},"publisher":{"@type":"Organization","name":"ChnMig的个人网站","logo":{"@type":"ImageObject","url":"https://www.chnmig.com/images/logo.gif"}},"description":"这里是 uber 团队出的 go 代码规范指南的中文版, 注意只是指南"}</script><link rel="canonical" href="https://www.chnmig.com/2021/04/18/uber_guide_principles/"><link rel="icon" href="/images/logo.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?8c2572cbfe4082d1fcd1327e4614cf34";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">类别</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" target="_blank" rel="noopener" href="https://tongji.baidu.com/web/welcome/ico?s=8c2572cbfe4082d1fcd1327e4614cf34">访问统计</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-17T16:00:00.000Z" title="2021/4/18 00:00:00">2021-04-18</time>发表</span><span class="level-item"><time dateTime="2021-06-12T16:00:00.000Z" title="2021/6/13 00:00:00">2021-06-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span><span class="level-item">1 小时读完 (大约8932个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">uber go code 规范(指导原则)</h1><div class="content"><h2 id="前言-21">前言</h2>
<p>从接触 Golang 到现在, 感觉到的很深的一点是, go 的代码无论是大佬还是菜鸟写出的代码, 都有着大体统一的 格式/流程, 这也是 Go 被开发者喜爱的一个原因, 但是还有一些, 比如变量的命名方式等, 可以称之为 风格 的东西, 却不尽相同, 我在开发中, 其实也希望有一个相对权威的指导意见, 后来就找到了 uber 团队出品的开发规范.<br>
uber 是众多公司中, 比较早使用 go 语言的了, 其本身也开源了一些优质的模块, 有机会的话希望也能向大家展示一下, 而在 uber 内部开发中, 经过持续的迭代, 开源了自己的代码规范, 这里给大家解读一下<br>
需要特别指出的是, 下面的内容并不是一定需要遵守, 这里你可以选择自己认为正确的可行的规范.<br>
团队内使用统一的风格, 可以提高代码的可读性<br>
本篇记录原则部分</p>
<h2 id="原则">原则</h2>
<blockquote>
<p>原则部分, 在 uber 内部是必须遵守的, 其目的是提高代码的健壮性, 让一些可能的错误能在编写时就暴露出来</p>
</blockquote>
<h2 id="结构体中包含接口指针">结构体中包含接口指针</h2>
<p>接口可以包含任何类型的值, 但是, 将结构体的某个值的类型设置为接口的指针则会出现问题, 例如:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brace <span class="keyword">interface</span>{} <span class="comment">// 空接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Round <span class="keyword">struct</span> { <span class="comment">// 结构体</span></span><br><span class="line">	prev  Brace  <span class="comment">// 值 prev 的类型为接口值</span></span><br><span class="line">	prev_ *Brace <span class="comment">// 值 prev_ 的类型为接口指针</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span>{} <span class="comment">// 空结构体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> r Round</span><br><span class="line">	<span class="keyword">var</span> s Square</span><br><span class="line">	r.prev = s   <span class="comment">// OK: 这里 ok</span></span><br><span class="line">	r.prev_ = &amp;s <span class="comment">// ERR: 想要将 s 的指针赋值给 prev_, 会报错</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>开发者很少需要在结构体中设置某个值的类型为接口的指针, 而应该将接口作为值进行传递, 类似于上面的 <code>prev</code>, 如果你真的需要将接口指针设置为结构体的某个值, 也不需要将其类型设置为指针, 例如:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brace <span class="keyword">interface</span>{} <span class="comment">// 空接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Round <span class="keyword">struct</span> { <span class="comment">// 结构体</span></span><br><span class="line">	prev  Brace <span class="comment">// 值 prev 的类型为接口值</span></span><br><span class="line">	prev_ Brace <span class="comment">// 值 prev_ 的类型为接口值</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span>{} <span class="comment">// 空结构体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> r Round</span><br><span class="line">	<span class="keyword">var</span> s Square</span><br><span class="line">	r.prev = s   <span class="comment">// OK: 这里 ok</span></span><br><span class="line">	r.prev_ = &amp;s <span class="comment">// OK: 想要将 s 的指针赋值给 prev_, 可以赋值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而一般情况下, 我们对结构体的方法的结构体部分传参, 大多数都是结构体的指针()指针方法, 此时可以使用结构体指针赋值给接口的方式, 例如:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brace <span class="keyword">interface</span> {</span><br><span class="line">	Length()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Round <span class="keyword">struct</span> { <span class="comment">// 结构体</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Round)</span></span> Length() {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	b := []Brace{&amp;Round{}}  <span class="comment">// OK: *Round 实现了 Brace 接口, 而不是 Round</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="interface-合理性验证">interface 合理性验证</h2>
<p>对于接口的实现, 在我们编写代码时, 可能会因为种种原因没有实现好对应接口, 而这个错误只有在真正调用时才会被发现, 例如:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brace <span class="keyword">interface</span> {</span><br><span class="line">	Length()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Round <span class="keyword">struct</span> { <span class="comment">// 结构体</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Round)</span></span> Long() {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	_ = []Brace{&amp;Round{}} <span class="comment">// ERR: 这里会报错, 因为 &amp;Round 没有实现 Brace</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>所以, 我们可以在编写时使用一个无用的空值, 来让编译器帮助我们判断是否实现了接口, 例如:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brace <span class="keyword">interface</span> {</span><br><span class="line">	Length()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Round <span class="keyword">struct</span> { <span class="comment">// 结构体</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ Brace = &amp;Round{} <span class="comment">// OK: 利用 var 一个无用的值, 让编译器检测 &amp;Round 是否实现了 Brace 接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Round)</span></span> Long() {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Round)</span></span> Length() {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="接收器与接口">接收器与接口</h2>
<p>对于结构体的值来讲, 结构体的指针方法与值方法不能一起调用, 例如:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</span><br><span class="line">	data <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span></span> Read() <span class="type">string</span> { <span class="comment">// 值方法</span></span><br><span class="line">	<span class="keyword">return</span> s.data</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span></span> Write(str <span class="type">string</span>) { <span class="comment">// 指针方法</span></span><br><span class="line">	s.data = str</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	sVals := <span class="keyword">map</span>[<span class="type">int</span>]S{<span class="number">1</span>: {data: <span class="string">"A"</span>}}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// OK: 你只能通过值调用 Read</span></span><br><span class="line">	sVals[<span class="number">1</span>].Read()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ERR: 这里会出现问题, 因为方法为指针方法</span></span><br><span class="line">	sVals[<span class="number">1</span>].Write(<span class="string">"test"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而对于结构体的指针来讲, 可以调用值方法和指针方法, 例如:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</span><br><span class="line">	data <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span></span> Read() <span class="type">string</span> { <span class="comment">// 值方法</span></span><br><span class="line">	<span class="keyword">return</span> s.data</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span></span> Write(str <span class="type">string</span>) { <span class="comment">// 指针方法</span></span><br><span class="line">	s.data = str</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	sPtrs := <span class="keyword">map</span>[<span class="type">int</span>]*S{<span class="number">1</span>: {data: <span class="string">"A"</span>}} <span class="comment">// 存储结构体的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// OK: 通过指针既可以调用 Read(值方法)，也可以调用 Write 方法(指针方法)</span></span><br><span class="line">	sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">	sPtrs[<span class="number">1</span>].Write(<span class="string">"test"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>同样的道理, 对于接口来讲, 也可以使用指针接收器来实现接口</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> {</span><br><span class="line">	f()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span></span> f() {} <span class="comment">// 值方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span></span> f() {} <span class="comment">// 指针方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	s1Val := S1{}  <span class="comment">// 结构体值</span></span><br><span class="line">	s1Ptr := &amp;S1{} <span class="comment">// 结构体指针</span></span><br><span class="line">	s2Val := S2{}  <span class="comment">// 结构体值</span></span><br><span class="line">	s2Ptr := &amp;S2{} <span class="comment">// 结构体指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i F   <span class="comment">// 接口</span></span><br><span class="line">	i = s1Val <span class="comment">// OK: S1的值实现了值方法</span></span><br><span class="line">	i = s1Ptr <span class="comment">// OK: S1的指针实现了值方法</span></span><br><span class="line">	i = s2Ptr <span class="comment">// OK: S2的指针实现了指针方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ERR: 不行, 因为S2是指针方法</span></span><br><span class="line">	i = s2Val</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="零值-Mutex">零值 Mutex</h2>
<p>对于sync 的锁包, <code>sync.Mutex</code>和<code>sync.RWMuntex</code>, 他的零值也是有效的, 不需要通过<code>new</code>关键字来生成指针</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	mu := <span class="built_in">new</span>(sync.Mutex) <span class="comment">// ERR: 生成 Mutex 的指针, 多此一举</span></span><br><span class="line">	mu.Lock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> mu1 sync.Mutex <span class="comment">// OK: Mutex 的零值也可以正常使用, 正确的用法</span></span><br><span class="line">	mu1.Lock()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>如果将 Mutex 作为结构体中的一部分, 那么其应该作为值类型, 而不是指针类型.<br>
并且, 结构体的 Mutex 应该由包内部控制, 不要被外部修改, 所以不要把 mutex 直接嵌入到结构体中(匿名字段的方式<a target="_blank" rel="noopener" href="https://go.dev/ref/spec#Struct_types">Go 编程语言规范 - Go 编程语言</a>).<br>
错误示例:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> {</span><br><span class="line">	sync.Mutex <span class="comment">// 没有 key, 在 struct 中视为匿名字段和提升字段, 提升字段会导致暴露方法给外部调用者</span></span><br><span class="line">	data       <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span></span> *SMap {</span><br><span class="line">	<span class="keyword">return</span> &amp;SMap{</span><br><span class="line">		<span class="comment">// 因为 Mutex 零值直接可以使用, 所以初始化时不需要初始化 Mutex</span></span><br><span class="line">		data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> {</span><br><span class="line">	m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m.data[k]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>正确示例:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> {</span><br><span class="line">	mu sync.Mutex <span class="comment">// 设置为普通字段, 设置为私有的, 防止外部调用, 只能让模块内部调用</span></span><br><span class="line">	data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span></span> *SMap {</span><br><span class="line">	<span class="keyword">return</span> &amp;SMap{</span><br><span class="line">		<span class="comment">// 因为 Mutex 零值直接可以使用, 所以初始化时不需要初始化 Mutex</span></span><br><span class="line">		data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> {</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m.data[k]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="拷贝-Slices-和-Maps">拷贝 Slices 和 Maps</h2>
<p>Slices 和 Maps 内部保存的事指向底层数据的指针, 因此涉及到他们的复制时, 需要特别的注意</p>
<h3 id="将-Slices-作为函数参数和返回值">将 Slices 作为函数参数和返回值</h3>
<p>当 map 和 slice 作为函数参数使用时, 如果存储了他们的引用, 则外部对他的修改, 也会造成内部的数据错乱</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">struct</span> {</span><br><span class="line">	trips []<span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []<span class="type">int</span>) {</span><br><span class="line">	<span class="comment">// 直接将slice存储进自身</span></span><br><span class="line">	d.trips = trips <span class="comment">// ERR: 存在外部修改可能</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> GetTrips() []<span class="type">int</span> {</span><br><span class="line">	<span class="comment">// 直接返回 slice</span></span><br><span class="line">	<span class="keyword">return</span> d.trips <span class="comment">// ERR: 存在外部修改可能</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	d := Driver{}</span><br><span class="line">	gt := []<span class="type">int</span>{<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">	d.SetTrips(gt)</span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// [0 1 2 3]</span></span><br><span class="line">	gt[<span class="number">0</span>] = <span class="number">5</span>                 <span class="comment">// ERR: 在外部修改了 Driver 的数据, 这是你想要的吗?</span></span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// [5 1 2 3]</span></span><br><span class="line">	rgt := d.GetTrips()       <span class="comment">// 获取内部的 slice</span></span><br><span class="line">	rgt[<span class="number">0</span>] = <span class="number">6</span>                <span class="comment">// ERR: 在外部修改了 Driver 的数据, 这是你想要的吗?</span></span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// [6 1 2 3]</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>我们可以借用<code>copy</code>函数, 进行 copy, 防止引用出现</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">struct</span> {</span><br><span class="line">	trips []<span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []<span class="type">int</span>) {</span><br><span class="line">	d.trips = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(trips)) <span class="comment">// 创建长度为参数长度的新切片</span></span><br><span class="line">	<span class="built_in">copy</span>(d.trips, trips)              <span class="comment">// OK: 使用 copy, 复制值而不是直接引用</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> GetTrips() []<span class="type">int</span> {</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(d.trips)) <span class="comment">// 创建长度为参数长度的新切片</span></span><br><span class="line">	<span class="built_in">copy</span>(res, d.trips)               <span class="comment">// 使用 copy, 复制内部值而不是直接返回内部引用</span></span><br><span class="line">	<span class="keyword">return</span> res                       <span class="comment">// OK: 外部修改不会影响内部</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	d := Driver{}</span><br><span class="line">	gt := []<span class="type">int</span>{<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line">	d.SetTrips(gt)</span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// [0 1 2 3]</span></span><br><span class="line">	gt[<span class="number">0</span>] = <span class="number">5</span>                 <span class="comment">// OK: 在外部修改了 Driver 的数据, 不影响内部</span></span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// [0 1 2 3]</span></span><br><span class="line">	rgt := d.GetTrips()       <span class="comment">// 获取内部的 slice</span></span><br><span class="line">	rgt[<span class="number">0</span>] = <span class="number">6</span>                <span class="comment">// OK: 在外部修改了 Driver 的数据, 不影响内部</span></span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// [0 1 2 3]</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="将-map-作为函数参数和返回值">将 map 作为函数参数和返回值</h3>
<p>同样的, map 也有这个问题</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">struct</span> {</span><br><span class="line">	trips <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) {</span><br><span class="line">	<span class="comment">// 直接将 map 存储进自身</span></span><br><span class="line">	d.trips = trips <span class="comment">// ERR: 存在外部修改可能</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> GetTrips() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> {</span><br><span class="line">	<span class="comment">// 直接返回 map</span></span><br><span class="line">	<span class="keyword">return</span> d.trips <span class="comment">// ERR: 存在外部修改可能</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	d := Driver{}</span><br><span class="line">	gt := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	gt[<span class="string">"0"</span>] = <span class="number">0</span></span><br><span class="line">	gt[<span class="string">"1"</span>] = <span class="number">1</span></span><br><span class="line">	d.SetTrips(gt)</span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// map[0:0 1:1]</span></span><br><span class="line">	gt[<span class="string">"0"</span>] = <span class="number">5</span>               <span class="comment">// ERR: 在外部修改了 Driver 的数据, 这是你想要的吗?</span></span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// map[0:5 1:1]</span></span><br><span class="line">	rgt := d.GetTrips()       <span class="comment">// 获取内部的 map</span></span><br><span class="line">	rgt[<span class="string">"0"</span>] = <span class="number">6</span>              <span class="comment">// ERR: 在外部修改了 Driver 的数据, 这是你想要的吗?</span></span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// map[0:6 1:1]</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>对于 map, 没有内置的 copy 函数, 我们可以手动赋值达到效果</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">struct</span> {</span><br><span class="line">	trips <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) {</span><br><span class="line">	d.trips = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(trips)) <span class="comment">// make</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> trips {                  <span class="comment">// 使用循环来赋值</span></span><br><span class="line">		d.trips[k] = v</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> GetTrips() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> {</span><br><span class="line">	res := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(d.trips))</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> d.trips {</span><br><span class="line">		res[k] = v</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	d := Driver{}</span><br><span class="line">	gt := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	gt[<span class="string">"0"</span>] = <span class="number">0</span></span><br><span class="line">	gt[<span class="string">"1"</span>] = <span class="number">1</span></span><br><span class="line">	d.SetTrips(gt)</span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// map[0:0 1:1]</span></span><br><span class="line">	gt[<span class="string">"0"</span>] = <span class="number">5</span>               <span class="comment">// OK: 在外部修改了 Driver 的数据, 这是你想要的吗?</span></span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// map[0:0 1:1]</span></span><br><span class="line">	rgt := d.GetTrips()       <span class="comment">// 获取内部的 map</span></span><br><span class="line">	rgt[<span class="string">"0"</span>] = <span class="number">6</span>              <span class="comment">// OK: 在外部修改了 Driver 的数据, 这是你想要的吗?</span></span><br><span class="line">	fmt.Println(d.GetTrips()) <span class="comment">// map[0:0 1:1]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用-defer-释放资源">使用 defer 释放资源</h2>
<p>defer 在函数返回之前执行, 所以我们可以利用 defer 进行资源的释放<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(count <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	mu := sync.Mutex{}</span><br><span class="line">	mu.Lock()</span><br><span class="line">	count++</span><br><span class="line">	mu.Unlock() <span class="comment">// ERR: 手动关闭, 很容易遗忘, 且针对多个分支处理, 容易遗忘</span></span><br><span class="line">	<span class="comment">// 当有多个 return 分支时，很容易遗忘 unlock</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(count <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	mu := sync.Mutex{}</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()  <span class="comment">// OK: 注册 defer, 后续无需操心解锁时机</span></span><br><span class="line">	count++</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>defer 对于程序的开销非常小, 只有确定真的对函数的执行时间控制为纳秒单位时, 才不使用 defer. 普通情况下, 使用 defer 来保持代码整洁性是十分推荐的.</p>
<h2 id="channel-的-size-设置为无缓冲或者1">channel 的 size 设置为无缓冲或者1</h2>
<p>channel 的 size 通常是1或者是无缓冲的, 默认情况下, channel 应该是无缓冲的, 因为 channel 的大小是无法改变的, 所以一般我们尽可能的希望其中不要存储数据, 只作为传输. 可以设置为 1 做一个最小的冗余, 而设置为其他大小时, 必须要考虑是什么让你必须选择有其他缓冲长度的通道? 是否可以通过别的方式解决?<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(count <span class="type">int</span>)</span></span> {</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1024</span>)  <span class="comment">// ERR: 为什么要这样做?</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(count <span class="type">int</span>)</span></span> {</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// OK: 只设置1个冗余</span></span><br><span class="line">	c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)   <span class="comment">// OK: 无缓冲</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="枚举从-1-开始">枚举从 1 开始</h2>
<p>go 中使用枚举的方式是声明一个自定义的类型和一个<code>iota</code>的<code>const</code>组, 因为变量默认值为0, 因此枚举的一组通常以0值开始, 但是有时候, 0 有着特殊的意义, 比如 int 的默认值就为0, 因此将枚举设置为1开始可以防止可能出现的错误值进行枚举<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span> <span class="comment">// int 类型枚举</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Add Operation = <span class="literal">iota</span></span><br><span class="line">	Subtract</span><br><span class="line">	Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o Operation)</span></span> ToString() <span class="type">string</span> {</span><br><span class="line">	res := <span class="string">""</span></span><br><span class="line">	<span class="keyword">switch</span> o {</span><br><span class="line">	<span class="keyword">case</span> Add:</span><br><span class="line">		res = <span class="string">"Add"</span></span><br><span class="line">	<span class="keyword">case</span> Subtract:</span><br><span class="line">		res = <span class="string">"Subtract"</span></span><br><span class="line">	<span class="keyword">case</span> Multiply:</span><br><span class="line">		res = <span class="string">"Multiply"</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> o Operation <span class="comment">// 默认为0</span></span><br><span class="line">	<span class="comment">// 这里因为遗漏, 没有正确的对 o 进行赋值</span></span><br><span class="line">	fmt.Println(o.ToString()) <span class="comment">// ERR: 解出来却是 Add, 只是因为int 默认为0</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong><br>
从1开始</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Operation <span class="type">int</span> <span class="comment">// int 类型枚举</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">	Subtract</span><br><span class="line">	Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o Operation)</span></span> ToString() <span class="type">string</span> {</span><br><span class="line">	res := <span class="string">""</span></span><br><span class="line">	<span class="keyword">switch</span> o {</span><br><span class="line">	<span class="keyword">case</span> Add:</span><br><span class="line">		res = <span class="string">"Add"</span></span><br><span class="line">	<span class="keyword">case</span> Subtract:</span><br><span class="line">		res = <span class="string">"Subtract"</span></span><br><span class="line">	<span class="keyword">case</span> Multiply:</span><br><span class="line">		res = <span class="string">"Multiply"</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> o Operation <span class="comment">// 默认为0</span></span><br><span class="line">	<span class="comment">// 这里因为遗漏, 没有正确的对 o 进行赋值</span></span><br><span class="line">	fmt.Println(o.ToString()) <span class="comment">// OK: 解出来是空, 代表错误了, 避免了 o 是默认值而错误的找到了枚举</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用-time-类型处理时间">使用 time 类型处理时间</h2>
<p><a target="_blank" rel="noopener" href="https://pkg.go.dev/time?utm_source=gopls">time package - time - pkg.go.dev</a><br>
时间的处理与计算总是复杂的, 在开发者的认知中, 可能存在以下错误:</p>
<ul>
<li>一天总有24小时 <a target="_blank" rel="noopener" href="https://www.timeanddate.com/time/earth-rotation.html">地球上的一天有多长？ (timeanddate.com)</a></li>
<li>一年总有365天 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Year">年份 - 维基百科，自由的百科全书 (wikipedia.org)</a></li>
<li><a target="_blank" rel="noopener" href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">更多-&gt;程序员相信时间的谬误</a><br>
不要试图自己实现时间的计算逻辑, 时间的计算实际上是很复杂的, 而 golang 内置的 time 包已经提供了很丰富的方法, 而且可以保证准确性.</li>
</ul>
<h3 id="使用time-Time表示某个瞬间时间">使用<code>time.Time</code>表示某个瞬间时间</h3>
<p>使用<code>time.Time</code>类型表示某一刻的时间, 在 时间比较/计算 时使用内置的方法<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断时间是否在某个时间段内</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop <span class="type">int</span>)</span></span> <span class="type">bool</span> {</span><br><span class="line">	<span class="keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断时间是否在某个时间段内</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop time.Time)</span></span> <span class="type">bool</span> { <span class="comment">// time.Time 类型</span></span><br><span class="line">	<span class="comment">// start.Before(now) 判断 start 是否在 now 之前</span></span><br><span class="line">	<span class="comment">// start.Equal(now) 判断 now 是否与 start 相同</span></span><br><span class="line">	<span class="comment">// now.Before(stop) 判断 now 是否在 stop 之前</span></span><br><span class="line">	<span class="keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用time-Duration表达时间段">使用<code>time.Duration</code>表达时间段</h3>
<p>使用<code>time.Duration</code>来表达某个时间段, 而不是其他数据类型<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="type">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="comment">// sleep delay 毫秒</span></span><br><span class="line">		time.Sleep(time.Duration(delay) * time.Millisecond)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	poll(<span class="number">10</span>) <span class="comment">// 调用者只能通过注释和查看源代码来确认参数 delay 代表毫秒还是秒</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">		time.Sleep(delay)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	poll(<span class="number">10</span> * time.Second) <span class="comment">// 调用者自己决定 sleep 多久</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="时间加减">时间加减</h3>
<p>时间的加减一定不要自己实现, 需要考虑的情况太多了<br>
对于日期的加减, 我们可以使用 <code>time.Time</code>的<code>AddDate</code>方法, 而对于时间的加减, 使用<code>Time.Add</code><br>
<strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	t := time.Now() <span class="comment">// 获取当前时间</span></span><br><span class="line">	fmt.Println(t)</span><br><span class="line">	newDay := t.AddDate(<span class="number">0</span> <span class="comment">/* years */</span>, <span class="number">1</span> <span class="comment">/* months */</span>, <span class="number">1</span> <span class="comment">/* days */</span>) <span class="comment">// +1月+1天</span></span><br><span class="line">	fmt.Println(newDay)</span><br><span class="line">	newDay1 := t.AddDate(<span class="number">0</span> <span class="comment">/* years */</span>, <span class="number">-1</span> <span class="comment">/* months */</span>, <span class="number">1</span> <span class="comment">/* days */</span>) <span class="comment">// +1月-1天</span></span><br><span class="line">	fmt.Println(newDay1)</span><br><span class="line">	maybeNewDay := t.Add(<span class="number">24</span> * time.Hour) <span class="comment">// +24h</span></span><br><span class="line">	fmt.Println(maybeNewDay)</span><br><span class="line">	maybeNewDay1 := t.Add(<span class="number">-24</span> * time.Second) <span class="comment">// -24s</span></span><br><span class="line">	fmt.Println(maybeNewDay1)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>输出结果:</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-05-17 16:27:33.394981 +0800 CST m=+0.000059114</span><br><span class="line">2022-06-18 16:27:33.394981 +0800 CST</span><br><span class="line">2022-04-18 16:27:33.394981 +0800 CST</span><br><span class="line">2022-05-18 16:27:33.394981 +0800 CST m=+86400.000059114</span><br><span class="line">2022-05-17 16:27:09.394981 +0800 CST m=-23.999940886</span><br></pre></td></tr></tbody></table></figure>
<h3 id="在对外部的系统中使用time-Time和time-Duration">在对外部的系统中使用<code>time.Time</code>和<code>time.Duration</code></h3>
<p>尽可能的在与外部系统的交互中使用<code>time.Time</code>和<code>time.Duration</code>, 例如:</p>
<ul>
<li>Command-line 标志:&nbsp;<a target="_blank" rel="noopener" href="https://golang.org/pkg/flag/"><code>flag</code></a>&nbsp;通过&nbsp;<a target="_blank" rel="noopener" href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a>&nbsp;支持&nbsp;<code>time.Duration</code></li>
<li>JSON:&nbsp;<a target="_blank" rel="noopener" href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a>&nbsp;通过其&nbsp;<a target="_blank" rel="noopener" href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code>&nbsp;method</a>&nbsp;方法支持将&nbsp;<code>time.Time</code>&nbsp;编码为&nbsp;<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3339">RFC 3339</a>&nbsp;字符串</li>
<li>SQL:&nbsp;<a target="_blank" rel="noopener" href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a>&nbsp;支持将&nbsp;<code>DATETIME</code>&nbsp;或&nbsp;<code>TIMESTAMP</code>&nbsp;列转换为&nbsp;<code>time.Time</code>，如果底层驱动程序支持则返回</li>
<li>YAML:&nbsp;<a target="_blank" rel="noopener" href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a>&nbsp;支持将&nbsp;<code>time.Time</code>&nbsp;作为&nbsp;<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3339">RFC 3339</a>&nbsp;字符串，并通过&nbsp;<a target="_blank" rel="noopener" href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a>&nbsp;支持&nbsp;<code>time.Duration</code><br>
对于<code>time.Time</code>, 其他语言一般也都会支持解析, 因为他是统一的标准, 而对于<code>time.Duration</code>, 如果不支持, 请使用<code>int</code>或者<code>float64</code>, 并且在字段名称中包含单位.<br>
例如, <code>json</code>不支持<code>time.Duration</code>, 因此使用<code>int</code>替代, 并且将单位包含在名称中, 提高可读性<br>
<strong>错误示例</strong></li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> {</span><br><span class="line">	StartTime time.Time <span class="string">`json:"start_time"`</span></span><br><span class="line">	Timeout   <span class="type">int</span>       <span class="string">`json:"timeout"`</span> <span class="comment">// 这里是秒还是毫秒?</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	t := Task{</span><br><span class="line">		StartTime: time.Now(),</span><br><span class="line">		Timeout:   <span class="type">int</span>((time.Second * <span class="number">30</span>).Seconds()),</span><br><span class="line">	}</span><br><span class="line">	s, err := json.Marshal(t)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	}</span><br><span class="line">	log.Println(<span class="type">string</span>(s))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022/05/17 17:05:42 {<span class="string">"start_time"</span>:<span class="string">"2022-05-17T17:05:42.356961+08:00"</span>,<span class="string">"timeout"</span>:30}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> {</span><br><span class="line">	StartTime     time.Time <span class="string">`json:"start_time"`</span></span><br><span class="line">	TimeoutSecond <span class="type">int</span>       <span class="string">`json:"timeout_second"`</span> <span class="comment">// 字段名就可以明白是秒</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	t := Task{</span><br><span class="line">		StartTime:     time.Now(),</span><br><span class="line">		TimeoutSecond: <span class="type">int</span>((time.Second * <span class="number">30</span>).Seconds()),</span><br><span class="line">	}</span><br><span class="line">	s, err := json.Marshal(t)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	}</span><br><span class="line">	log.Println(<span class="type">string</span>(s))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022/05/17 17:07:26 {<span class="string">"start_time"</span>:<span class="string">"2022-05-17T17:07:26.147585+08:00"</span>,<span class="string">"timeout_second"</span>:30}</span><br></pre></td></tr></tbody></table></figure>
<p>当在这些交互中不能使用&nbsp;<code>time.Time</code>&nbsp;时, 除非达成一致, 否则使用&nbsp;<code>string</code>&nbsp;和&nbsp;<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3339">RFC 3339</a>&nbsp;中定义的格式时间戳. 默认情况下, <a target="_blank" rel="noopener" href="https://golang.org/pkg/time/#Time.UnmarshalText"><code>Time.UnmarshalText</code></a>&nbsp;使用此格式, 并可通过&nbsp;<a target="_blank" rel="noopener" href="https://golang.org/pkg/time/#RFC3339"><code>time.RFC3339</code></a>&nbsp;在&nbsp;<code>Time.Format</code>&nbsp;和&nbsp;<code>time.Parse</code>&nbsp;中使用</p>
<p>需要注意的是, <code>"time"</code>&nbsp;包不支持解析闰秒时间戳<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/8728">8728</a>, 也不在计算中考虑闰秒<a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/15190">15190</a>, 如果比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p>
<h2 id="Errors">Errors</h2>
<p>对于 error 的使用, 有几种方式, 有各自的优缺点, 在选择之前, 先考虑具体的情况:</p>
<ul>
<li>对于调用者, 是否需要匹配错误信息以便处理? 如果需要, 则必须通过声明顶级的错误变量或者自定义类型来支持<code>errors.Is</code>或<code>errors.As</code>函数</li>
<li>错误消息是静态的字符串, 还是存储有上下文信息的动态字符串? 如果是静态字符串, 可以使用<code>errors.New</code>, 如果是动态, 必须使用<code>fmt.Errorf</code>或者自定义的错误类型</li>
<li>错误是否是我们的下游返回的错误? 如果是, 参阅之后的<strong>错误包装</strong>部分</li>
</ul>
<table>
<thead>
<tr>
<th>是否需要错误匹配</th>
<th>错误类型</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>NO</td>
<td>静态</td>
<td><a target="_blank" rel="noopener" href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a></td>
</tr>
<tr>
<td>NO</td>
<td>动态</td>
<td><a target="_blank" rel="noopener" href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a></td>
</tr>
<tr>
<td>YES</td>
<td>静态</td>
<td><a target="_blank" rel="noopener" href="https://golang.org/pkg/errors/#New"><code>errors.New</code></a> 或者自定义顶级错误</td>
</tr>
<tr>
<td>YES</td>
<td>动态</td>
<td>自定义错误类型</td>
</tr>
<tr>
<td><strong>不需要错误匹配的静态错误</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是你写的一个包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">"could not open"</span>) <span class="comment">// new 一个静态的错误返回</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 假设这是调用者</span></span><br><span class="line">	<span class="keyword">if</span> err := Open(); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>不需要错误匹配的动态错误</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是你写的一个包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="type">string</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"file %q not found"</span>, file) <span class="comment">// 返回 format 后的错误</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 假设这是调用者</span></span><br><span class="line">	<span class="keyword">if</span> err := Open(<span class="string">"demo.txt"</span>); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// Can't handle the error.</span></span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>需要错误匹配的静态错误</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是你写的一个包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>) <span class="comment">// 定义一个静态错误类型, 需要是可以导出的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">return</span> ErrCouldNotOpen <span class="comment">// 返回指定的错误类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 假设这是调用者</span></span><br><span class="line">	<span class="keyword">if</span> err := Open(); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">if</span> errors.Is(err, ErrCouldNotOpen) { <span class="comment">// errors.Is 判断错误是否是指定的错误类型</span></span><br><span class="line">			<span class="comment">// handle the error</span></span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>需要错误匹配的动态错误</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是你写的一个包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NotFoundError <span class="keyword">struct</span> { <span class="comment">// 定义一个结构体, 为错误使用, 需要设置为外部可使用</span></span><br><span class="line">	File <span class="type">string</span> <span class="comment">// 动态部分</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NotFoundError)</span></span> Error() <span class="type">string</span> { <span class="comment">// error 方法, 传出 format 后的错误信息</span></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.File) <span class="comment">// 动态信息 format</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="type">string</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">return</span> &amp;NotFoundError{File: file} <span class="comment">// return时发现是 error类型, 会自动调 Error 方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 假设这是调用者</span></span><br><span class="line">	<span class="keyword">if</span> err := Open(<span class="string">"demo.txt"</span>); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">var</span> notFound *NotFoundError</span><br><span class="line">		<span class="keyword">if</span> errors.As(err, &amp;notFound) { <span class="comment">// errors.As 判断错误是否是这个结构体的方法</span></span><br><span class="line">			<span class="comment">// handle the error</span></span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="错误包装">错误包装</h3>
<p>当这个错误是我们的下游返回的错误, 我们需要将错误返回给更上级时, 我们有三种选择:</p>
<ul>
<li>按照原样返回错误</li>
<li>使用 fmt.Errorf 搭配 %w 将错误添加进上下文后返回</li>
<li>使用 fmt.Errorf 搭配 %v 将错误添加进上下文后返回<br>
如果你没有需要添加的其他上下文, 则直接原样返回错误即可, 这样保留了原始错误类型和消息, 适合上游进行错误追踪, 非常适合底层的错误<br>
否则, 则需要尽可能的在错误消息里添加上下文, 这样可以防止模糊的错误信息, 比如<code>connection refused</code>之类的, 他应该是更详细的, 例如<code>call service foo: connection refused</code><br>
此时你需要使用<code>fmt.Errorf</code>来生成一个包含上下文的错误, 那么如何选择<code>%w</code>和<code>%v</code>?</li>
<li>如果调用者可以访问底层的错误, 使用<code>%w</code>, <code>%w</code>可以在传递之后, 外部的调用者依旧可以使用<code>errors.Is</code>来进行错误的匹配, 更多情况下, <code>%w</code>更推荐使用</li>
<li><code>%v</code>会将下游错误进行混淆,导致上游无法进行错误匹配, 如果可以修改, 将他切换到<code>%w</code><br>
在生成错误信息时, 记得避免加上<code>failed to</code> 之类的描述来保证错误信息的简洁, 因为他在返回时, 就已经默认是错误信息, 不需要特别的指出, 另外当错误通过堆栈一层层向上返回时, 加入过多的描述会导致错误信息错乱不堪, 无法辨认</li>
</ul>
<h3 id="v导致的错误示例"><code>%v</code>导致的错误示例:</h3>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是最下游的一个包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>) <span class="comment">// 定义一个静态错误类型, 需要是可以导出的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">return</span> ErrCouldNotOpen <span class="comment">// 返回指定的错误类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是中层的包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">if</span> err := Open(); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"open: %v"</span>, err) <span class="comment">// 返回给上层, %v 将错误信息覆盖</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 假设这是调用者</span></span><br><span class="line">	<span class="keyword">if</span> err := Demo(); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">if</span> errors.Is(err, ErrCouldNotOpen) { <span class="comment">// errors.Is 判断错误是否是指定的错误类型, %v 覆盖了错误类型, 导致判断失败, Panic</span></span><br><span class="line">			<span class="comment">// handle the error</span></span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是最下游的一个包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>) <span class="comment">// 定义一个静态错误类型, 需要是可以导出的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">return</span> ErrCouldNotOpen <span class="comment">// 返回指定的错误类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是中层的包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">if</span> err := Open(); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// 加入的上下文只有 open: 让调用者知道是 open 时的错误即可</span></span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"open: %w"</span>, err) <span class="comment">// 返回给上层, %v 将错误信息带入返回</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 假设这是调用者</span></span><br><span class="line">	<span class="keyword">if</span> err := Demo(); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">if</span> errors.Is(err, ErrCouldNotOpen) { <span class="comment">// errors.Is 判断错误是否是指定的错误类型, 判断成功</span></span><br><span class="line">			<span class="comment">// handle the error</span></span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是, 如果错误信息需要传送到另一个系统, 例如日志收集, 就需要明确告诉这是个错误信息<br>
另外, 遇到错误, 不要选择忽略他<a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">不要只是检查错误，而是优雅地处理它们|戴夫·切尼 (cheney.net)</a>  // TODO, 这里有空翻译一下</p>
<h3 id="错误命名">错误命名</h3>
<p>对于存储为全局变量的错误类型, 根据是否需要导出, 统一加入前缀<code>Err</code>或者<code>err</code></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 导出以下两个错误，以便此包的用户可以将它们与 errors.Is 进行匹配。</span></span><br><span class="line">	<span class="comment">// 统一使用 Err 作为前缀</span></span><br><span class="line"></span><br><span class="line">	ErrBrokenLink   = errors.New(<span class="string">"link is broken"</span>)</span><br><span class="line">	ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个错误没有被导出，因为我们不想让它成为我们公共 API 的一部分。 我们可能仍然在带有错误的包内使用它。</span></span><br><span class="line">	<span class="comment">// 统一使用 err 作为前缀</span></span><br><span class="line"></span><br><span class="line">	errNotFound = errors.New(<span class="string">"not found"</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>对于自定义的错误类型, 统一加入后缀<code>Error</code></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样，这个错误被导出，以便这个包的用户可以将它与 errors.As 匹配。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NotFoundError <span class="keyword">struct</span> {</span><br><span class="line">	File <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NotFoundError)</span></span> Error() <span class="type">string</span> {</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.File)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且这个错误没有被导出，因为我们不想让它成为公共 API 的一部分。 我们仍然可以在带有 errors.As 的包中使用它。</span></span><br><span class="line"><span class="keyword">type</span> resolveError <span class="keyword">struct</span> {</span><br><span class="line">	Path <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *resolveError)</span></span> Error() <span class="type">string</span> {</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"resolve %q"</span>, e.Path)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="断言处理失败">断言处理失败</h2>
<p>go 的类型断言会在失败时, 以单一返回值形式返回 panic, 因此, 使用 <code>, ok</code> 方式防止 panic<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">interface</span>{}</span><br><span class="line">	s = <span class="number">1</span></span><br><span class="line">	t := s.(<span class="type">string</span>)  <span class="comment">// panic</span></span><br><span class="line">	fmt.Println(t)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">interface</span>{}</span><br><span class="line">	s = <span class="number">1</span></span><br><span class="line">	t, ok := s.(<span class="type">string</span>) <span class="comment">// !ok, 不会 panic</span></span><br><span class="line">	<span class="keyword">if</span> !ok {</span><br><span class="line">		log.Fatalln(<span class="string">"error"</span>)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(t)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="不要使用-panic">不要使用 panic</h2>
<p>在生产环境运行的代码必须避免出现 panic, panic 会导致整个程序崩溃, 如果发生错误, 函数必须捕捉并返回错误, 让调用方来进行处理<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="type">string</span>)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> {</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"an argument is required"</span>)  <span class="comment">// panic, 程序崩溃</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  run(os.Args[<span class="number">1</span>:])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="type">string</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> {</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"an argument is required"</span>)  <span class="comment">// 不符合预期的逻辑, 捕捉以 error 方式返回, 而不是 panic</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">if</span> err := run(os.Args[<span class="number">1</span>:]); err != <span class="literal">nil</span> {  <span class="comment">// 调用方处理错误</span></span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>panic/recover</code>不是经常使用的错误处理策略, 仅仅在发生不可恢复的事情(比如空指针)时才 panic, 有一个例外: 程序的初始化时发生某些致命错误可能会 panic(比如数据库连接解析错误)<br>
即使在测试代码中, 也不要使用 panic, 应该使用<code>t.Fatal</code>或者<code>t.FailNow</code>来确保失败被标记<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"failed to set up test"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">  t.Fatal(<span class="string">"failed to set up test"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用-go-uber-org-atomic">使用 <a target="_blank" rel="noopener" href="http://go.uber.org/atomic">go.uber.org/atomic</a></h2>
<p>go 语言内置了一部分原始数据类型的原子操作功能, 实现在包 &nbsp;<a target="_blank" rel="noopener" href="https://golang.org/pkg/sync/atomic/">sync/atomic</a> 中, 原子操作可以防止资源竞争导致可能出现的错误, 但是开发者很容易忘记使用这些原子操作.<br>
<a target="_blank" rel="noopener" href="https://godoc.org/go.uber.org/atomic">go.uber.org/atomic</a>&nbsp;通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型</p>
<h2 id="避免可变的全局变量">避免可变的全局变量</h2>
<p>//  TODO<br>
<a target="_blank" rel="noopener" href="https://github.com/uber-go/guide/blob/master/style.md#avoid-mutable-globals">guide/style.md at master · uber-go/guide (github.com)</a></p>
<h2 id="避免在公共结构中嵌入类型">避免在公共结构中嵌入类型</h2>
<p>直接在公共结构体中嵌入类型会导致这个类型的实现细节暴露出去, 导致分层失败, 同时还会对以后可能的迭代产生阻碍, 同时不利于文档的编写<br>
假设有一个结构体 <code>AbstractList</code>, 实现了<code>Add</code>和<code>Remove</code>方法</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Add(s <span class="type">string</span>) {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Remove(s <span class="type">string</span>) {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Clean() {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>当开发者需要在上游的结构体中使用该类型时, 注意不要直接嵌入这个类型, 例如<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Add(s <span class="type">string</span>) {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Remove(s <span class="type">string</span>) {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Clean() {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="comment">// ConcreteList 是公开的结构体</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> {</span><br><span class="line">	*AbstractList  <span class="comment">// 直接嵌入类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	c := ConcreteList{}</span><br><span class="line">	c.Add(<span class="string">"1"</span>)  <span class="comment">// 外部可以直接调用 *AbstractList 的方法, 导致分层失败</span></span><br><span class="line">	c.Remove(<span class="string">"1"</span>)</span><br><span class="line">	c.Clean()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong><br>
正确的做法应该是作为结构体的某一个字段使用</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Add(s <span class="type">string</span>) {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Remove(s <span class="type">string</span>) {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Clean() {</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="comment">// ConcreteList 是公开的结构体</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> {</span><br><span class="line">	list *AbstractList <span class="comment">// 直接嵌入类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分层</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Add(s <span class="type">string</span>) {</span><br><span class="line">	<span class="comment">// 做一些其他事情, 例如校验</span></span><br><span class="line">	l.list.Add(s)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分层</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Remove(s <span class="type">string</span>) {</span><br><span class="line">	<span class="comment">// 做一些其他事情, 例如校验</span></span><br><span class="line">	l.list.Remove(s)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	c := ConcreteList{}</span><br><span class="line">	c.Add(<span class="string">"1"</span>) <span class="comment">// 调用的是 *ConcreteList 本身的方法</span></span><br><span class="line">	c.Remove(<span class="string">"1"</span>)</span><br><span class="line">	c.Clean()  <span class="comment">// 调用失败, 因为我不希望你使用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分层可以为之后可能出现的其他逻辑留下空间, 避免之后新的需求到来之时对现有的代码进行结构上的破坏性改动, 同时也可以避免将某些其他的方法暴露出来<br>
即使<code>AbstractList</code>是接口, 也应该保持同样的做法, 道理是一样的</p>
<h2 id="避免使用内置的名称">避免使用内置的名称</h2>
<p>Go&nbsp;<a target="_blank" rel="noopener" href="https://golang.org/ref/spec">语言规范</a>&nbsp;概述了几个内置的， 不应在 Go 项目中使用的&nbsp;<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Predeclared_identifiers">预先声明的标识符</a>。<br>
根据上下文的不同，将这些标识符作为名称重复使用， 将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。 在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">error</span> <span class="type">string</span>  <span class="comment">// 覆盖了 error</span></span><br><span class="line"><span class="comment">// `error` 本身的作用域隐式覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里 error 也被覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(<span class="type">error</span> <span class="type">string</span>)</span></span> {</span><br><span class="line">    <span class="comment">// `error` 作用域隐式覆盖</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// 虽然这些字段在技术上不构成隐式覆盖，但`error`或`string`字符串在使用中可能会出现覆盖</span></span><br><span class="line">    <span class="type">error</span>  <span class="type">error</span></span><br><span class="line">    <span class="type">string</span> <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> Error() <span class="type">error</span> {</span><br><span class="line">    <span class="comment">// `error` 和 `f.error` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="type">error</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> String() <span class="type">string</span> {</span><br><span class="line">    <span class="comment">// `string` and `f.string` 在视觉上是相似的</span></span><br><span class="line">    <span class="keyword">return</span> f.<span class="type">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorMessage <span class="type">string</span></span><br><span class="line"><span class="comment">// `error` 不会被覆盖</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleErrorMessage</span><span class="params">(msg <span class="type">string</span>)</span></span> {</span><br><span class="line">    <span class="comment">// `error` 不会被覆盖</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// `error` and `string` 现在是明确的。</span></span><br><span class="line">    err <span class="type">error</span></span><br><span class="line">    str <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> Error() <span class="type">error</span> {</span><br><span class="line">    <span class="keyword">return</span> f.err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> String() <span class="type">string</span> {</span><br><span class="line">    <span class="keyword">return</span> f.str</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意, 编译器在使用预先分隔的标识符时不会生成错误, 但是诸如<code>go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题</p>
<h2 id="避免使用-init">避免使用 <code>init()</code></h2>
<p>开发者的代码中应该避免使用<code>init()</code>, 当你认为<code>init()</code>是必须需要的, 你应该先确认:</p>
<ul>
<li>函数内的处理结果无论程序环境或调用如何, 都是完全确定的</li>
<li>避免依赖于其他init()函数的顺序或结果. 虽然此刻多个init()顺序是明确的, 但代码可能被更改, 因此init()函数之间的关系可能会使代码变得脆弱和容易出错.
<ul>
<li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等</li>
</ul>
</li>
<li>避免I/O，包括文件系统、网络和系统调用<br>
<strong>错误示例</strong></li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package a</span></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> _defaultFoo Foo</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// init 中初始化变量</span></span><br><span class="line">    _defaultFoo = Foo{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// package b</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> _config Config</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="comment">// 获取当前目录</span></span><br><span class="line">    cwd, _ := os.Getwd()</span><br><span class="line">    <span class="comment">// 读取目录下文件</span></span><br><span class="line">    raw, _ := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">"config"</span>, <span class="string">"config.yaml"</span>),</span><br><span class="line">    )</span><br><span class="line">    yaml.Unmarshal(raw, &amp;_config)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _defaultFoo = Foo{</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 使用函数来进行初始化</span></span><br><span class="line"><span class="keyword">var</span> _defaultFoo = defaultFoo()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defaultFoo</span><span class="params">()</span></span> Foo {</span><br><span class="line">    <span class="keyword">return</span> Foo{</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 开发者手动调用相关函数而不是让其自动执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span></span> Config {</span><br><span class="line">    cwd, err := os.Getwd()</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    raw, err := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, <span class="string">"config"</span>, <span class="string">"config.yaml"</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">    <span class="keyword">var</span> config Config</span><br><span class="line">    yaml.Unmarshal(raw, &amp;config)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>考虑到上述情况，在某些情况下，init()可能更可取或是必要的，可能包括：</p>
<ul>
<li>不能表示为单个赋值的复杂表达式。</li>
<li>可插入的钩子，如database/sql、编码类型注册表等。</li>
<li>对 Google Cloud Functions 和其他形式的确定性预计算的优化, 例如<code>regexp.MustCompile</code>(编译正则表达式)</li>
</ul>
<h2 id="切片追加时优先指定容量">切片追加时优先指定容量</h2>
<p>在切片需要追加时, 尽可能的预先估算出最大容量, 并在 make 时就指定其容量<br>
目的是减少切片动态扩容带来的时间损耗<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	s := time.Now()</span><br><span class="line">	size := <span class="number">100000000</span></span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(data))</span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++ {</span><br><span class="line">		data = <span class="built_in">append</span>(data, k)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(data))</span><br><span class="line">	fmt.Println(time.Since(s)) <span class="comment">// 所需时长</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">114748416</span><br><span class="line">1.532827648s</span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	s := time.Now()</span><br><span class="line">	size := <span class="number">100000000</span></span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, size) <span class="comment">// 指定容量为 size</span></span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(data))</span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++ {</span><br><span class="line">		data = <span class="built_in">append</span>(data, k)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="built_in">cap</span>(data))</span><br><span class="line">	fmt.Println(time.Since(s)) <span class="comment">// 所需时长</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100000000</span><br><span class="line">100000000</span><br><span class="line">333.793275ms</span><br></pre></td></tr></tbody></table></figure>
<h2 id="主函数的退出方式">主函数的退出方式</h2>
<p>go 程序使用<code>os.Exit</code>或者<code>log.Fatal</code>来进行立即退出, 永远记住, 不要使用<code>panic</code>来进行退出<br>
并且, 只在<code>main()</code>中调用<code>os.Exit</code>和<code>log.Fatal</code>, 对于其他函数的退出, 要将错误信息返回出来<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	body := readFile(<span class="string">"a.txt"</span>)</span><br><span class="line">	fmt.Println(body)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"假如这里进行一些其他清理操作"</span>)</span><br><span class="line">	}()</span><br><span class="line">	f, err := os.Open(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	}</span><br><span class="line">	b, err := ioutil.ReadAll(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// 发送错误, 使用 log.Fatal 退出</span></span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>运行后, 发现, defer 中注册的操作无法执行</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2022/06/13 19:21:11 open a.txt: no such file or directory</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br></pre></td></tr></tbody></table></figure>
<p>在其他函数中通过以上两种方式直接退出程序有几个隐患:</p>
<ul>
<li>不明显的控制流: 任何函数都可以导致程序退出, 因此很难对处理逻辑进行控制和分析</li>
<li>难以测试: 如果你的test 测试代码调用了函数, 而在函数内导致程序退出, 同样导致整个测试流程退出, 无法继续进行</li>
<li>跳过清理: 一般的, 我们使用 defer 来进行一些资源清理操作, 例如连接的关闭, 文件句柄关闭等, 但是当函数直接退出时, defer 中的代码不会被执行<br>
<strong>正确示例</strong></li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// 主函数进行退出</span></span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"资源回收"</span>)</span><br><span class="line">	}()</span><br><span class="line">	args := os.Args[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> {</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"missing file"</span>)</span><br><span class="line">	}</span><br><span class="line">	name := args[<span class="number">0</span>]</span><br><span class="line">	f, err := os.Open(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	b, err := ioutil.ReadAll(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">资源回收</span><br><span class="line">2022/06/13 19:30:29 missing file</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br></pre></td></tr></tbody></table></figure>
<h3 id="一次性退出">一次性退出</h3>
<p>如果可以的话, 在每个<code>main()</code>中最多调用一次<code>os.Exit</code>或者<code>log.Fatal</code>, 如果有多个错误场景, 应该将程序结束, 此时应该将逻辑单独放置在单独的错误函数中, 通过返回错误来让 main 来进行退出, 这样会缩短 main 函数, 同时将关键业务逻辑放置在了单独的, 可以进行测试的函数中<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	args := os.Args[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> {</span><br><span class="line">		log.Fatal(<span class="string">"missing file"</span>)</span><br><span class="line">	}</span><br><span class="line">	name := args[<span class="number">0</span>]</span><br><span class="line">	f, err := os.Open(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// fatal</span></span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"清理"</span>)</span><br><span class="line">	}()</span><br><span class="line">	b, err := ioutil.ReadAll(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// defer 同样并不会被执行</span></span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	fmt.Println(b)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> {  <span class="comment">// 统一进行判断</span></span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> {</span><br><span class="line">	args := os.Args[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> {</span><br><span class="line">		<span class="comment">// err 0</span></span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"missing file"</span>)</span><br><span class="line">	}</span><br><span class="line">	name := args[<span class="number">0</span>]</span><br><span class="line">	f, err := os.Open(name)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// err 1</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	b, err := ioutil.ReadAll(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// err 2</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="在序列化的结构体中使用-tag">在序列化的结构体中使用 tag</h3>
<p>任何序列化到 json/YAML 或者其他支持基于 tag 来进行字段命名的格式, 都应该使用 tag 来进行注释<br>
因为, 结构的序列化方式, 是不同系统之间交流的约定, 而对字段的修改会导致破坏约定. 使用加入 tag 的方式, 可以使约定更加明确和易读. 并且在重构和重命名字段时, 只要不动 tag, 就无需重新约定结构<br>
<strong>错误示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">type</span> Stock <span class="keyword">struct</span> {</span><br><span class="line">		<span class="comment">// json 在没有 tag 时默认按照字段名</span></span><br><span class="line">		<span class="comment">// 当后续字段名有调整导致 json 结构发生变化</span></span><br><span class="line">		Price <span class="type">int</span></span><br><span class="line">		Name  <span class="type">string</span></span><br><span class="line">	}</span><br><span class="line">	bytes, err := json.Marshal(Stock{</span><br><span class="line">		Price: <span class="number">137</span>,</span><br><span class="line">		Name:  <span class="string">"UBER"</span>,</span><br><span class="line">	})</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bytes))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>正确示例</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">type</span> Stock <span class="keyword">struct</span> {</span><br><span class="line">		<span class="comment">// json 根据 json tag 来进行命名</span></span><br><span class="line">		<span class="comment">// 当后续字段名调整, 只要 tag 不动, 则无需重新约定 json 结构</span></span><br><span class="line">		Price <span class="type">int</span>    <span class="string">`json:"price"`</span></span><br><span class="line">		Name  <span class="type">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	}</span><br><span class="line">	bytes, err := json.Marshal(Stock{</span><br><span class="line">		Price: <span class="number">137</span>,</span><br><span class="line">		Name:  <span class="string">"UBER"</span>,</span><br><span class="line">	})</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bytes))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>uber go code 规范(指导原则)</p><p><a href="https://www.chnmig.com/2021/04/18/uber_guide_principles/">https://www.chnmig.com/2021/04/18/uber_guide_principles/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ChnMig</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-04-18</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-06-13</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Golang/">Golang</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/06/16/gin_router/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">gin 框架的路由源代码解析</span></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言-21"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#原则"><span class="level-left"><span class="level-item">2</span><span class="level-item">原则</span></span></a></li><li><a class="level is-mobile" href="#结构体中包含接口指针"><span class="level-left"><span class="level-item">3</span><span class="level-item">结构体中包含接口指针</span></span></a></li><li><a class="level is-mobile" href="#interface-合理性验证"><span class="level-left"><span class="level-item">4</span><span class="level-item">interface 合理性验证</span></span></a></li><li><a class="level is-mobile" href="#接收器与接口"><span class="level-left"><span class="level-item">5</span><span class="level-item">接收器与接口</span></span></a></li><li><a class="level is-mobile" href="#零值-Mutex"><span class="level-left"><span class="level-item">6</span><span class="level-item">零值 Mutex</span></span></a></li><li><a class="level is-mobile" href="#拷贝-Slices-和-Maps"><span class="level-left"><span class="level-item">7</span><span class="level-item">拷贝 Slices 和 Maps</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#将-Slices-作为函数参数和返回值"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">将 Slices 作为函数参数和返回值</span></span></a></li><li><a class="level is-mobile" href="#将-map-作为函数参数和返回值"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">将 map 作为函数参数和返回值</span></span></a></li></ul></li><li><a class="level is-mobile" href="#使用-defer-释放资源"><span class="level-left"><span class="level-item">8</span><span class="level-item">使用 defer 释放资源</span></span></a></li><li><a class="level is-mobile" href="#channel-的-size-设置为无缓冲或者1"><span class="level-left"><span class="level-item">9</span><span class="level-item">channel 的 size 设置为无缓冲或者1</span></span></a></li><li><a class="level is-mobile" href="#枚举从-1-开始"><span class="level-left"><span class="level-item">10</span><span class="level-item">枚举从 1 开始</span></span></a></li><li><a class="level is-mobile" href="#使用-time-类型处理时间"><span class="level-left"><span class="level-item">11</span><span class="level-item">使用 time 类型处理时间</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用time-Time表示某个瞬间时间"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">使用time.Time表示某个瞬间时间</span></span></a></li><li><a class="level is-mobile" href="#使用time-Duration表达时间段"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">使用time.Duration表达时间段</span></span></a></li><li><a class="level is-mobile" href="#时间加减"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">时间加减</span></span></a></li><li><a class="level is-mobile" href="#在对外部的系统中使用time-Time和time-Duration"><span class="level-left"><span class="level-item">11.4</span><span class="level-item">在对外部的系统中使用time.Time和time.Duration</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Errors"><span class="level-left"><span class="level-item">12</span><span class="level-item">Errors</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#错误包装"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">错误包装</span></span></a></li><li><a class="level is-mobile" href="#v导致的错误示例"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">%v导致的错误示例:</span></span></a></li><li><a class="level is-mobile" href="#错误命名"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">错误命名</span></span></a></li></ul></li><li><a class="level is-mobile" href="#断言处理失败"><span class="level-left"><span class="level-item">13</span><span class="level-item">断言处理失败</span></span></a></li><li><a class="level is-mobile" href="#不要使用-panic"><span class="level-left"><span class="level-item">14</span><span class="level-item">不要使用 panic</span></span></a></li><li><a class="level is-mobile" href="#使用-go-uber-org-atomic"><span class="level-left"><span class="level-item">15</span><span class="level-item">使用 go.uber.org/atomic</span></span></a></li><li><a class="level is-mobile" href="#避免可变的全局变量"><span class="level-left"><span class="level-item">16</span><span class="level-item">避免可变的全局变量</span></span></a></li><li><a class="level is-mobile" href="#避免在公共结构中嵌入类型"><span class="level-left"><span class="level-item">17</span><span class="level-item">避免在公共结构中嵌入类型</span></span></a></li><li><a class="level is-mobile" href="#避免使用内置的名称"><span class="level-left"><span class="level-item">18</span><span class="level-item">避免使用内置的名称</span></span></a></li><li><a class="level is-mobile" href="#避免使用-init"><span class="level-left"><span class="level-item">19</span><span class="level-item">避免使用 init()</span></span></a></li><li><a class="level is-mobile" href="#切片追加时优先指定容量"><span class="level-left"><span class="level-item">20</span><span class="level-item">切片追加时优先指定容量</span></span></a></li><li><a class="level is-mobile" href="#主函数的退出方式"><span class="level-left"><span class="level-item">21</span><span class="level-item">主函数的退出方式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#一次性退出"><span class="level-left"><span class="level-item">21.1</span><span class="level-item">一次性退出</span></span></a></li><li><a class="level is-mobile" href="#在序列化的结构体中使用-tag"><span class="level-left"><span class="level-item">21.2</span><span class="level-item">在序列化的结构体中使用 tag</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.gif" alt="ChnMig的个人网站" height="28"></a><p class="is-size-7"><span>&copy; 2022 ChnMig</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Contact me" href="mailto:ChnMig@Outlook.com"><i class="far fa-envelope"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ChnMig"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>