---
title: 为什么gRPC使用HTTP2而不是WebSocket
date: 2021-09-05            
updated: 2021-09-05         
comments: true              
toc: true                   
excerpt: 在跟同事聊天(摸鱼)的时候, 谈到 gRPC 使用 HTTP2 的好处, 然后同事抛出来一个问题, 为什么不使用 websocket , 于是在我查找了相关资料后有了这一篇博客
tags:                       
- Golang
categories:                 
- 编程
---

在跟同事聊天(摸鱼)的时候, 谈到`gRPC`使用`HTTP2`的好处, 然后同事抛出来一个问题, 为什么不使用`websocket`, 于是在我查找了相关资料后有了这一篇博客

## 什么是RPC

本文的主要目的不是讲什么是RPC, 什么是gRPC, 但还是稍微带一点(怎么可能是为了凑字数:kissing:)

RPC其实就是**远程过程调用(Remote Procedure Call)**的缩写, 是属于计算机通信协议的一种. 其实从名字也能看出来, 就是在一台计算机的程序去调用另一个地址空间(可能是本机的不同虚拟空间, 也可能是不同计算机)的程序, 而作为开发者来讲, 无需关注这部分细节. RPC是一种 服务端-客户端(Client/Server)模式, 通过客户端发送请求到接受回应这个过程来进行信息交互.

因为是调用另一个地址空间的程序, 所以需要进行信息的传递和发送接收, 抽象出来流程大致如下

``` shell
客户端: 本地调用 --> 参数封装 --> 发送调用信息
服务端: 接收调用信息 --> 解除封装  --> 调用本地服务  --> 获取结果 --> 封装结果 --> 发送结果
客户端: 接收结果 --> 解除封装 --> 本地返回结果
```

因为是跨空间调用, 为了保证运行正常, 肯定要约定好内容的格式/规范, 就跟你让别人帮忙买彩票, 对面是个不懂汉语的外国人, 他就不知道你想要他干嘛, 就会导致无法正确执行下去. 这里面可分为两部分

- 内容组织约定: 分为调用语法和内容解压缩两个部分, 比如我要调用你的哪个功能, 给你的信息是怎样的结构等
- 网络传输: 涉及到真正的互联网传输, 就比较复杂了, 怎么区分二进制的哪一部分是RPC调用, 哪一部分是消息体, 这些解析都要通过协议去实现和约束. 怎样去传输信息, 就比如`ONC RPC`, `RESTFULL HTTP JSON`, `gRPC` 等等

> wiki: [远程过程调用 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/遠程過程調用)

## 什么是gRPC

gRPC也是RPC的一种, 是`google`使用`C++`开发的一款跨语言, 二进制编码的数据序列化协议, 他有几个显著特点

- gRPC使用 `protobuf` 来进行数据的编码与内容的定义, 数据压缩率很高, 直接提高了传输的效率.
- gRPC使用 `HTTP2` 进行网络传输
- gRPC的爸爸是`google`, 所以他有很好的 社区支持, 版本迭代, 生态, 插件 等等

>gRPC官网: [gRPC](https://gRPC.io/)
>
>protobuf: [protocolbuffers/protobuf: Protocol Buffers - Google's data interchange format (github.com)](https://github.com/protocolbuffers/protobuf)

## HTTP2是什么

HTTP2是2015年IESG批准的新的HTTP协议, 使用了类似SPDY协议的方案. 

HTTP2的优点(相比1.1)有:

- 真正的多路复用: 虽然1.1中就有了`keep_alive`, 但是本质上只是保持不断TCP链接, 而并发时还会申请多个`keep_alive`, 导致资源损耗, 而且当`keep_alive`链接存在的数量超过限值时, 其他的新请求就会阻塞直到空出位置, 而2则是真正的多路复用, 将指向同一个域名的请求都由一个TCP链接发送, 防止资源损耗
- HTTP2传输数据使用的是二进制数据, 因此可以通过数据封装(二进制帧)来实现多个请求通过同一个链接发送和接收, 也就实现了多路复用
- HTTP2协议中针对每个请求, 可以放置优先值, 双方可以通过优先值来决定不同的处理策略. 
- 服务器主动推送: 服务端可以主动推送给客户端数据, 而不是被动的返回数据
- 更小的数据: 因为是二进制数据, 所以使用压缩算法(HPACK)可以减少数据的大小

> wiki: [HTTP/2 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/HTTP/2)

## 为什么使用HTTP2

看过上面, 可能你的脑中就有了模糊的答案, 我们再翻翻gRPC的最早一篇博客[gRPC 的动机和设计原则 | gRPC](https://grpc.io/blog/principles/), 里面记录了gRPC的设计原则, 大致如下:

- 服务不是对象, 消息不是引用: 微服务的概念
- 覆盖广和简单性: gRPC需要在每个流行的平台上可以使用, 而且足够简单的使用, 没有很高的硬件要求
- 免费开放: 所有人免费使用基本的功能
- 互操作性和范围: 必须能在常见的互联网基础设施上运行
- 通用和高性能: 应适用于广泛的用例, 同时不会牺牲性能
- 分层: 代码分层, 版本迭代不影响基础使用
- 多种数据类型: 不同的服务需要使用不同的消息类型和编码，如协议缓冲区、JSON、XML和Thrift；协议和实现必须允许这样做。同样，对有效载荷压缩的需求也因用例和有效载荷类型而异：协议应允许可插拔的压缩机制。
- 同步和异步: 同时支持异步和同步处理客户端和服务器交换的消息序列。这对于在某些平台上扩展和处理流是至关重要的。
- 取消和超时: 取消允许服务器在客户行为良好时回收资源。当跟踪因果链时，取消可能会级联。客户端可能指示呼叫超时，这允许服务根据客户的需求调整其行为.
- 限流: 在必要时可以对请求进行限流
- 等等...

我们发现, HTTP2 符合 gRPC 的要求:

- 覆盖广: 在标准推出后, HTTP2 就被主流浏览器和网关等支持, 最小可用的硬件标准十分的低, 手机端/电脑端/服务器端/iot端 受网络的推动, HTTP2发展普及很快
- 简单性: 大量的网络框架和组件/网关等支持简单的开启HTTP2, 开发者无需关注更底层的socket处理, 专心业务. 
- 免费开放: 是开放的标准, 任何人都可以使用
- 天然支持物联网/手机/浏览器: 互联网推动
- 高性能: 相比1.1有长足的进步
- 流控: HTTP2维持一个TCP连接, 所以对流控制比较简单
- 安全性: 天然支持SSL
- 鉴权成熟: 从HTTP1发展出的鉴权系统很完善, 可以使用到2上

当然, 与人无完人一样, HTTP2也有其缺点:

- 传输还不够高效: 虽然有HPACK, 但是对于RPC来讲, 还可以更加的简单快速, 比如将某个功能标记为一个int数字, 客户端直接传入数字即可标识调用服务端的哪个功能 
- gRPC使用HTTP2需要解码两次, 一次是`HEADERS`一次是`DATA`
- HTTP2标准是本身只有一个TCP, 但是其实gRPC的实现会有多个TCP

在速度上, 有更加快速的协议, 但是综合考虑后还是HTTP2更加适合, 相信很多书都会强调一个观点`适合的才是最好的`

## 为什么不使用websocket

websocket看似也是流式传输, 也可以做到一个websocket传输所有信息, 为什么不选择websocket?

stackOverflow有一个提问类似: [http2 - Does HTTP/2 make websockets obsolete? - Stack Overflow](https://stackoverflow.com/questions/28582935/does-http-2-make-websockets-obsolete)

其实还是适不适合的问题, websocket和HTTP2是有所不同的, HTTP2的推出也不是为了替代或者超越websocket, 他们是不同的作用领域, 相比于websocket, HTTP2在通用性上更加适合gRPC

[Will WebSocket survive HTTP/2? (infoq.com)](https://www.infoq.com/articles/websocket-and-http2-coexist/)

**适合的才是最好的**





















