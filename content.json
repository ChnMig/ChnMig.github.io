{"pages":[{"title":"关于我","text":"格言 知识 知识就是力量, 是成功不可或缺的基础 实践 实践出真知, 否则永远是纸上谈兵, 现实往往更为复杂 灵感 灵感就在那一瞬间, 努力抓住它 机遇 人生充满机遇, 但是机会总是留给有准备的人","link":"/about/index.html"}],"posts":[{"title":"个人常用的gitignore文件模板","text":"作用 git提交时忽略的文件 文件名 .gitignore Python 1234567891011121314151617181920212223242526272829303132333435# Byte-compiled / optimized / DLL files__pycache__/*.py[cod]*$py.class# Distribution / packaging.Pythonenv/build/dist/*.log# pyenv.python-version# dotenv.env# virtualenv.venv/venv/ENV/# VSCode settings.vscode# IDEA files.idea# OSX dir files.DS_Store# Sublime Text settings*.sublime-workspace*.sublime-project Go 1234567891011121314151617181920212223242526# Buildbulid/*.exe# dotenv.env# venv/vendor/# Log*.log# VSCode settings.vscode# IDEA files.idea# OSX dir files.DS_Store# Sublime Text settings*.sublime-workspace*.sublime-project","link":"/2021/09/04/commonly_used_gitignore/"},{"title":"使用Cron定时任务模块","text":"使用Cron定时任务模块 新项目是Golang作为开发语言, 遇到了些新的坑, 也学到了新的知识, 收获颇丰 本章介绍在Go中使用Cron定时任务模块来实现逻辑 在项目中, 我们往往需要定时执行一些逻辑, 举个例子, 财务系统每月需要自动的总结报表发生到指定邮箱, 生成饼图存储等逻辑, 作为服务方, 我们必须维护一个定时任务系统来做到定时触发任务执行 下面介绍Go项目中很出名的定时任务模块, Cron 他的star目前有7.2k(截止到本章发出) 下面我们来了解如何使用, 以Demo为例 123456789101112131415161718192021222324252627282930313233package taskimport ( \"fmt\" \"remoteAdmin/tools\" \"github.com/robfig/cron/v3\")var myCron *cron.Cron// InitAndStart init cron taskfunc InitAndStart() { myCron = cron.New() defer myCron.Stop().Done() // c.AddFunc // https://en.wikipedia.org/wiki/Cron userOfflineDetectionTaskID, err := myCron.AddFunc(fmt.Sprintf(\"*/%v * * * *\", tools.EnvConfig.Cron.UserOffineRestartMinutes), userOfflineDetection) if err != nil { tools.Log.Panic(\"Cron AddFuncPanic\", zap.Error(err)) } tools.Log.Info(fmt.Sprintf(\"Successfully Add userOfflineDetection To Cron, ID: %v\", userOfflineDetectionTaskID)) // start myCron.Start()}// userOfflineDetection User offline detectionfunc userOfflineDetection() { fmt.Println(\"DEMO\")} 这里我是讲其作为一个模块来使用, 因为在实际使用中需要执行的定时任务不止一个, 而且代码逻辑可能比较长, 所以我将 cron 对象单独 var 出来供其他函数使用 代码的入口在 InitAndStart 函数, 在一切的开始, 我们需要先 New 出 *cron.Cron 寄存器才可以, 使用 cron.New() 生成一个任务的寄存器对象 我们希望在主程序运行结束时能主动的将寄存器停止, 所以在 New 完后立刻使用 defer 注册关闭逻辑 .Stop().Done() 是通知下游要关闭寄存器了, 等待下游手上的任务全部处理完毕即结束 随后就是注册任务了, 使用 AddFunc函数来注册任务, 他接受两个参数, 参数一指定了该函数什么时候去触发执行, 参数二就是其要执行的函数了 关于参数一, 采用的是和unix的任务定时任务一样的格式, 比如我写的代表每tools.EnvConfig.Cron.UserOffineRestartMinutes分钟执行一次, 具体的规则可查看 wiki (需FQ) 此处我注册的30秒执行一次 userOfflineDetection 函数 同时 cron 可同时注册很多个定时任务, 只需使用 AddFunc 注册即可 myCron.Start() 则启动寄存器, 如果这个Goroutine中已经启动了 Cron, 则不进行任何操作 需要注意的是, 在寄存器启动后你仍然可以使用 AddFunc 来注册新的定时任务, 也是可以正常的注册的, 例如 12myCron.Start()myCron.AddFunc(\"* 1 * * *\", userOfflineDetection) 如果你想要对每一个注册过的定时任务进行控制, 还记得AddFunc返回的结果吗, 其参数1是这个任务的ID, 参数二为可能的err错误 以上为 Cron 的基本用法, 希望对你有所帮助","link":"/2021/09/04/cron/"},{"title":"Golang交叉编译","text":"前言 什么是交叉编译? 交叉编译指在某个平台编译另一平台能使用的文件 本文列出交叉编译的命令, 全程干货, 不多BB 正文 本文参考官方文档 12https://golang.google.cn/doc/install/source#introductionhttps://golang.google.cn/doc/install/source#environment 一条基本的编译命令结构如下(mac/linux) 1GOOS=linux GOARCH=amd64 go build main.go windows版比较特殊(目的一致,只是win加set) 123set GOOS=linuxset GOARCH=amd64go build main.go 这个命令有两个参数(main.go不做解释了) GOOS --&gt; GO,OS 生成文件执行的平台 GOPACH --&gt; GO,PACH 平台的架构 以上这条命令就是生成在amd64架构的linux上的可执行文件 注意的是, 如果你是在同等架构和系统上编译,例如在linux上编译linux的文件,则什么都不用带,go会自己判断 GOOS和GOARCH都有多个选项,可组合,对照如下 $GOOS $GOARCH aix ppc64 android 386 android amd64 android arm android arm64 darwin amd64 darwin arm64 dragonfly amd64 freebsd 386 freebsd amd64 freebsd arm illumos amd64 js wasm linux 386 linux amd64 linux arm linux arm64 linux ppc64 linux ppc64le linux mips linux mipsle linux mips64 linux mips64le linux riscv64 linux s390x netbsd 386 netbsd amd64 netbsd arm openbsd 386 openbsd amd64 openbsd arm openbsd arm64 plan9 386 plan9 amd64 plan9 arm solaris amd64 windows 386 windows amd64 当然,有些架构编译可能会出现错误,因为对他的支持还不完善,具体请看最上方的官方文档","link":"/2021/09/04/cross_compilation/"},{"title":"默认参数的坑","text":"在 https://docs.python.org/3/tutorial/controlflow.html#default-argument-values 中,有这样一段话 Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls: 大致意思为 重要警告：默认值仅计算一次。 当默认值是可变对象（例如列表，字典或大多数类的实例）时，这会有所不同。 例如，以下函数累积在后续调用中传递给它的参数： 下面给出了一个例子 1234567def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3)) 打印出来的结果是 123[1][1, 2][1, 2, 3] 这是因为, 作为默认参数, python在启动时就会将变量 L 建立, 我们在函数 f 内对 L 处理就会导致后来调用的 L 已经是修改过的 L 了, 我们可以通过打印 L 的内存地址来验证 123456789def f(a, L=[]): print(id(L)) L.append(a) print(id(L)) return Lprint(f(1))print(f(2))print(f(3)) 结果是 12345678945132896004513289600[1]45132896004513289600[1, 2]45132896004513289600[1, 2, 3] 当然, python的文档中也给出了一个推荐的方法 If you don’t want the default to be shared between subsequent calls, you can write the function like this instead: 12345def f(a, L=None): if L is None: L = [] L.append(a) return L 即: 将 L 默认为 None, 当该参数未传时, 将 L 设置为空列表, 在Python启动时 L 会设置为 None, 而当我们调用而不传参数 L 时, 在函数 f 内部重新给 L 赋值, 此时 L 为函数 f 内的一个私有变量, 其不会影响到参数 L 本身, 同样的我们可以通过打印内存地址来验证 1234567891011def f(a, L=None): print(id(L)) if L is None: L = [] print(id(L)) L.append(a) return Lprint(f(1))print(f(2))print(f(3)) 输出 12345678944673957764469232960[1]44673957764469232960[2]44673957764469232960[3] 当然我们也可以在不更改函数 f 的情况下, 在每次调用 f 的时候都传输参数 L, 如果想让他为一个空列表那就传一个空列表同样能解决问题, 因为你每次指定了值, 便会在传入时修改 L 的值 123456789def f(a, L=[]): print(id(L)) L.append(a) print(id(L)) return Lprint(f(1, []))print(f(2, []))print(f(3, [])) 输出 12345678944741681924474168192[1]44741681924474168192[2]44741681924474168192[3]","link":"/2021/09/04/default_param/"},{"title":"Dramatiq遇到的坑","text":"Dramatiq Bogdanp/dramatiq: A fast and reliable background task processing library for Python 3. (github.com) 是一个Python3的任务队列框架, 比较轻量化, 使用RabbitMQ或Redis作为存储介质, 当时看有2.xk的start就使用了, 结果在使用中发现了几个问题, 这里记录一下. 任务\"不发送\" 测试时, 发现总有些任务会遗留在管道中, work好像不接收, 也没有执行, 当重启work后就立刻接受了. 当时使用的存储介质是redis, 查看了源代码后发现问题 因为redis本身没有ack机制, dramatiq就自己实现了ACK, 在接受到任务后, 执行任务, 执行完成后放入到另一个xx.ack管道中同时删除原有管道的这一条数据.(消费者端实现ACK) 那么问题就出现了, 首先, 如果一个任务运行需要1小时, 那么在这1小时中, 查看redis会发现一直在原有管道中, 不知道是否是正在执行. 另外, 如果在这个任务执行中, 因为某些原因导致当前进程崩溃了, 如果没有来得及将中断的任务重新放入管道中(dramatiq虽然有处理措施, 但是毕竟是Python的多进程方式, 并不是很能保证可靠性), 就会造成这个任务\"丢失\" 最后决定更换存储介质为RabbitMQ, Dramatiq在使用RabbitMQ作为broker时使用的是RabbitMQ自带的ACK机制, 更加的成熟 ACK错误 客户端报错 1Consumer encountered a connection error: (406, 'PRECONDITION_FAILED - delivery acknowledgement on channel 1 timed out...... 更换为RabbitMQ之后, 发现消费者会报ACK错误, 在RabbitMQ中体现为生产者获取了任务后没有返回ACK, 在超时后被RabbitMQ重新放回任务队列 在上一次排查问题的过程中, 我发现消费者需要等待代码执行完毕后再ACK, 这本身也是没有问题的, 我搭配Dramatiq自身的超时来设置RabbitMQ的ACK超时, 比如这个任务可能会执行2小时, 我设置Dramatiq的超时为2.5小时, 设置RabbitMQ的超时为3小时, 这样让程序能自己处理, 但是还是出现问题 后来查看源代码时, 发现, Dramatiq有一个功能是预读, 即每次提前获取n个任务, 放在内存中, 当某一个任务完成后直接从内存中获取新任务, 省去网络io. 那这样就会出现问题, 因为在获取到任务后, RabbitMQ就会认为该任务处于等待ACK的状态, 如果每个任务需要1小时, Dramatiq获取了两个任务, 那么第二个任务就会超时, 当第二个任务执行完成后, Dramatiq进行ACK时就会被RabbitMQ拦截 看了代码后发现这个预读的数量参数可调, 从环境变量中获取, 我们设置 1export dramatiq_queue_prefetch=1 让他只获取一个然后立刻执行这一个即可 心跳超时 修复了ACK之后, 又发现了一个问题, 隔一段时间RabbitMQ就会有错误输出 1[erro] &lt;0.2398.0&gt; missed heartbeats from client, timeout: 60s 这代表的是客户端的心跳出现了问题, 当心跳超时后, RabbitMQ会主动断开与这个客户端的连接 查看项目的日志, 没有发现有任何错误或者警告输出 之前两个问题都是消费者的错误, 于是先排查的消费者, 发现消费者有心跳的维持且正常运行了 又回来看生产者的源代码, 发现**Dramatiq根本没有实现生产者的心跳**, 但是因为每次生产者发送任务时, 发送任务的代码写的是死循环, 连接被RabbitMQ断开后,或者因为别的原因没有被发送, 就再次生成新的连接, 再次发送, 而当发送失败时, 只打了一个Debug档的日志, 可能作者也知道这个问题, 然后就粗暴的使用捕捉错误然后重新建立连接的方式去做了😅 如果要解决, 可以设置心跳为0来去除心跳检测, url连接支持这个参数, 比如 1amqp://worker:BEQFRAmC5@127.0.0.1:5672?heartbeat=0 创建broker失效 我们是将FastApi与Dramatiq结合使用, 当接受到请求后做处理, 然后通过Dramatiq发送出去 为了更好的代码结构, 我们将代码整合了一下, 结果会出现连接不到RabbitMQ的问题 Dramatiq的使用一般是 12345import dramatiq@dramatiq.actor(max_retries=0, queue_name=\"test\", actor_name=\"test\")def scan(work): pass 建立如上的scan函数, 主要是加入装饰器dramatiq.actor 调用时是 12from . import workworker.iot.scan.send(send_info) 设置broker是 12345import dramatiqrabbitmq_broker = RabbitmqBroker(url=RABBITMQ_URL)rabbitmq_broker.add_middleware(ConfigMiddleware())dramatiq.set_broker(rabbitmq_broker) 改动主要是将设置broker的部分放置进了fastapi的启动事件, 原先是放置进了work文件夹的__init__.py里 刚开始以为是不是broker的设置比较晚了, 导致broker没有正常生效 后来发现在Dramatiq中broker是一个Golobal变量, 测试也发现即使在后面set_broker也可以 继续深入, 发现问题所在了 因为dramatiq.actor是作为装饰器使用, 而Python的装饰器内的代码, 实际上在导入时会执行, 举个例子 123456789101112131415161718192021222324252627registry = []def register(func): print('running register(%s)' % func) registry.append(func) return func@registerdef f1(): print('running f1()')@registerdef f2(): print('running f2()')def f3(): print('running f3()')def main(): print('running main()') print('registry -&gt;', registry) f1() f2() f3()if __name__ == '__main__': main() 打印结果为 1234567running register(&lt;function f1 at 0x0000027913AA8708&gt;)running register(&lt;function f2 at 0x0000027913AA8E58&gt;)running main()registry -&gt; [&lt;function f1 at 0x0000027913AA8708&gt;, &lt;function f2 at 0x0000027913AA8E58&gt;]running f1()running f2()running f3() 没错, 假如有个装饰器函数 a, 将函数 b 包裹在 a 中, 也就是 123456def a(): pass@adef b(): pass 在Python导入到这个代码时, 会将被 a 包裹的 b 变成 a(b), 会执行函数 a, 生成一个新的函数 a(b), 然后每次调用 b 时, 实际上在调用这个新的函数 而Dramatiq中, 在装饰器 dramatiq.actor 中的代码进行了初始化操作, 此时就将全局的broker生成了客户端供自己使用, 此时的全局broker还没有人为的设置, 变成了默认的127.0.0.1的RabbitMQ, 而后运行send时直接使用此客户端发送, 因为我们在修改代码后, 将创建broker的部分放置在了引用work之后, 导致了先生成了客户端, 而后来的自定义broker没有正确的被actor使用, 使用的是本地的RabbitMQ, 因为本地没有, 理所当然的就发送失败了 解决方法是排查项目的运行顺序, 在导入work之前先进行set_broker操作, 在work的__init__.py中 12from app.task.broker import setup_broker; setup_broker() # noqafrom . import xx 当导入包时运行__init__.py, 优先set_broker","link":"/2021/09/09/dramatiq_pit/"},{"title":"记一次flask框架返回200前端却拿到了504的问题","text":"问题 今天在调试代码时, 发现了一个诡异的问题, 我之前写了一个接口, 作用是接收上传的文件, 因为这个接口需要一定的权限控制, 所以我写了3个装饰器在上面, 这个项目是用的 flask, 代码类似于 123456@app.route('/upload', methods=['POST'])@login_requireds@verify_requireds@upload_requiredsdef upload_file(): pass 每个装饰器代码类似于 1234567891011def verify_requireds(func): # 阻止未审核的账户进行操作 @functools.wraps(func) def inner(*args, **kwargs): pass if user_dict.get(\"verify\") != 1: response_msg = {\"status\": 300, \"msg\": \"Sorry, Your · account is not audited\", \"msg_zh\": \"该账户未审核\"} return jsonify(response_msg) return func(*args, **kwargs) return inner 而在测试当中, 发现前端的请求一直是 504 错误(浏览器的f12调试显示), 而后端的log显示每次都正常返回了数据 然后就开始了漫长的捉虫 首先通过postman测试发现postman并没有问题, 猜测是不是跨域问题, 我们使用了 flask-cors 来进行跨域设置, 我们是这样设置的 123from flask_cors import CORSCORS(app, support_credentials=True) 为了印证该猜想, 我们开启了 flask-cors 的 debug 模式, 1logging.getLogger('flask_cors').level = logging.DEBUG 看到了options 请求时, debug 打印 1DEBUG Request to '/upload' matches CORS resource '/*'. Using options: {'origins': ['.*'], 'methods': 'DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT', 'allow_headers': ['.*'], 'expose_headers': None, 'supports_credentials': False, 'max_age': None, 'send_wildcard': False, 'automatic_options': True, 'vary_header': True, 'resources': '/*', 'intercept_exceptions': True, 'always_send': True, 'support_credentials': True} 所以初步排除了是跨域导致的问题 后来猜测是不是前端的代码问题, 后来前端 debug 调试发现是浏览器就返回了 504 错误, 就算是BUG也很难去通过前端去解决了 后来无意中发现, 其实并不是每次都返回 504, 当文件足够小时(1k左右), 请求都是正常的, 而文件大时, 则有一定几率会返回正常, 发现了这个现象时, 我们开始考虑是不是后端会 “夯住” 或者前端的连接并没有断开而是一直保持呢? 但是确实postman一切ok, 所以是不是请求有些异常, 而框架并没有很好的处理, postman兼容性很好, 忽略了这个错误呢? 我们使用软件在浏览器的客户端进行了抓包, 发现了问题 我们发现, 其实在前端发出请求后, 后端确实返回了200并且已经被读取, 但是后续又向前端发送了 RST 的数据包 搜了一下 RST 的作用, 其实就是代表服务端告诉客户端, 我要断开链接了, 你的还没发送的数据包直接丢掉吧, 可能就是这样的操作让前端框架以为后端断开链接了, 报了 504/502 错误 其实正常情况下, 触发 RST 的情况也只有去访问一个不存在的端口或服务时才会有, 所以前端框架这样统一判断也情有可原, 而且 RST 的滥用也可能引发安全问题 https://baike.baidu.com/item/RST%E6%94%BB%E5%87%BB 再结合之前发现的, 很小的文件几乎每次都正常, 我们大致找到了原因 因为我们现有的逻辑, 在装饰器执行过程中, 还没有获取 file 文件, 如果装饰器直接拦截, 此时可能 file 还没有完全接收完毕, 此时 flask 会发送 RST 告诉客户端抛弃发送, 而前端就会报错, 而小文件发送特别快, 不存在数据未发送完成的情况, 所以小文件是 ok 的 所以解决办法就非常简单了, 在装饰器前再加一个装饰器, 这个装饰器的作用是获取 file 文件, 顺便做一下如果没有 file 文件返回一个错误, 确保在服务端返回之前已经完全接收到了 file 文件即可. 我们增加一个 file 装饰器 123456789def file_requireds(func): # 对文件进行校验 @functools.wraps(func) def inner(*args, **kwargs): files = request.files.get('file') if not files: return jsonify({\"status\": 300, \"msg\": \"not find file\", \"msg_zh\": \"没有文件\"}) return func(*args, **kwargs) return inner 加入到接口的装饰器大军中 123456@app.route('/upload', methods=['POST'])@file_requireds@login_requireds@verify_requireds@upload_requiredsdef upload_file(): 再测试就完全可以了, 抓包也一切正常了 此例警醒我以后接受文件相关的接口一定要将文件全部获取到再进行操作, 或者是前端考虑解决办法","link":"/2021/09/04/flask_upload_file_504/"},{"title":"好的礼仪","text":"前言 这几天老妈的单位在搞线上培训, 要听课, 她自己不想看, 我就趁着周末在家用电脑给她挂一下, 课程包括了生产安全, 防疫知识, excel 操作, 社保 等视频, 最后一部分是讲怎样做好自己的礼仪, 看了两节觉得挺对的, 我个人觉得也是有必要简单的了解一下相关的知识, 所以这里简单的记录一下总结, 本身课就三个小时, 所以本篇内容不多 来源 这个课是截取的视频, 不知道来源, 讲解人是 逯瑶 (bjwbh.cn), 简历看起来很厉害 什么是礼仪 尊重, 适合 礼仪是让人得到尊重, 礼仪需要适合自己和对方, 而不是刻意的去装 礼仪不是用来装的, 而是去用的 孔子的论语中有说 恭而无礼则劳，慎而无礼则葸，勇而无礼则乱，直而无礼则绞, 强调了礼仪需要掌握对的方法, 否则会适得其反 作者认为 人生就是一场成交, 人生无处不成交, 这里的成交并不是指的双方进行交易, 而是广义的成交, 指双方达成了共识. 婴儿在生下来之后第一件事就是哭, 目的是找到其母亲, 告诉她我很健康, 这就是人生的第一场成交 如果一个人, 周围人给他的评价都是好的, 正面的, 说明这个人有很强的成交能力, 这就是成功的, 所以, 学习礼仪是让双方达成协议, 促成成交 学好礼仪, 可以加强个人品牌的塑造和营销 五感开关 要想成交, 必须要先给对方留下印象, 人每天会做很多事情, 大脑会抛弃掉大部分记忆, 为什么有些记忆是很深刻的呢? 在脑白金疯狂打广告的时候, 相信经历过的人都对其印象深刻, 甚至现在还忘不了. 这是一个成功的营销, 成功的让用户记住了自己. 人的脑袋分为左右, 左脑是理性脑, 存放浅层的记忆. 右脑是感性脑, 存放深度的记忆. 当某件事情被分到左脑存放时, 多半是不会被记住的. 举个例子, 一个销售面对客户推销商品. 当销售一直在说话, 而客户很少说话的时候, 一般成功率都不高, 因为销售的话已经被客户放到了左脑进行处理. 同样的, 为什么很多人不听老妈的唠叨, 也是因为是\"唠叨\", 被放进了左脑 想要放到右脑中, 需要打开右脑的\"开关\", 有那些呢? 视觉, 听觉, 嗅觉, 味觉, 触觉. 我们现在想到脑白金, 脑子里会有一个老头一个老太在扭动, 同时\"今年过节不收礼, 收礼只收脑白金\"也出现在脑子里, 这就是视觉和听觉, 一般的对某一件事情印象深刻, 必定是多于其中某一个开关的. 可以回顾一下最近发生的事情记得清楚的是不是这样. 按照占用比例来进行区分的话, 视觉语言占了 55%, 声音表情占了 38%, 文字语言只占 7%. 文字语言 文字是需要通过介质去传播的, 可能是声音, 可能是纸, 可能是微信. 文字语言实际上是很重要的, 是核心部分, 直接体现了你的态度, 逻辑思维等等, 他是起到了画龙点睛的作用, 但是光有文字语言也是不行的, 刚才也说了, 文字语言需要通过介质去传播, 那么剩下的93%就是你需要通过介质去将你的语言, 你的思想表达出来. 作者举了例子, 当你听到你发出去的语音微信, 或者录音的时候, 会惊讶自己的声音怎么与自己设想的不一致, 这是因为你的发声没有受到过专业的训练 同样的一句话, 或者说几个字, 配合发声人的表情, 语调等就会有不同的表现, 同样是几个字 你怎么回来了, 可以表现出 失望/ 惊讶/ 惊喜/ 发怒 等心理, 这是因为你的心理通过 表情/ 动作/ 语调 等介质散发出来的. 视觉语言 有些人, 你与他沟通时, 会觉得他有一种 气场, 这就是通过视觉语言表达的. 视觉语言有三种类型, 仪容/ 仪表/ 仪态 仪容是指的身体所有露出来自己原生态的地方, 比如 头发, 眼睛, 鼻子 等 仪表指的是盖住身体的所有非原生态的地方, 比如 眼镜, 手表, 上衣 等 仪态指的是所有会动的, 比如 走, 跑, 蹲, 笑 作者认为这三个最重要的往往是 仪态, 因为你想表达思想, 最直接的就是仪态 而要提高自己的仪态, 一定记得需要提高自己的意识, 因为 意识决定行动, 行动决定结果 我们需要有 恭敬心, 比如去拜佛的地方, 大家都很安静(除了特别的人), 有很好的氛围, 那为什么大家都不由自主的维持秩序呢? 因为对这里有 恭敬心, 那其实我们应该对万事万物有恭敬心, 而不是在特定的地方. 比如在公共场合, 不抽烟, 垃圾不要随地扔, 这其实就是礼仪, 就是你对有些东西心存恭敬, 为什么垃圾不随地扔, 因为你知道清洁工们很辛苦, 对他心存恭敬, 这是很好的事情, 我们常说 德行, 人有道德, 就会通过行为来释放, 就会让自己的仪态变得更好, 修身齐家治国平天下, 修身是在最前面的, 随后是自己的小家, 后来才是对社会有贡献. 微表情/微动作 掌控我们的微表情, 这属于仪态的一部分, 如何面对有气场的人? 眼睛 首先是眼睛, 眼睛是心灵的窗户, 我们很少与人对视, 而对于有气场的人, 你更难与他对视, 会不知不觉的别开眼睛, 这时候就代表你示弱了. 主要是让我们有了压迫感, 怎么来减轻压迫感呢? 我们可以交谈时盯着他们的小三角区看, 小三角区指的是 两只眼睛与鼻梁 连接形成的倒三角, 这样会缓解一些压力, 提升自己的气场. 同时要注意, 不要频繁的, 或者动作幅度过大的, 将视线离开 大三角区, 大三角区指的是, 头顶到两肩形成的三角形, 尤其是与异性交谈的时候, 如果不遵守, 很可能让对方觉得你有别的想法. 眼睛向下与别人说话, 会让人觉得 轻蔑, 动机不纯 向上让人觉得是 若有所思, 不自信 所以面对领导或者客户时, 千万要记住 而向左右时会让人觉得 不被尊重, 没有关注对方 手 手部动作也是非常重要的, 同样说一句话, 当你说话时竖起大拇指, 就让人觉得是在夸赞, 而竖起食指则让人觉得在指责 在交流时, 食指代表 指责, 挑衅和距离感 在交流时, 掌心对着人代表 高高在上和距离 在交流时, 抱着收代表高傲 我们发现领导在开会坐下时, 有些喜欢叉手抱胸, 这是因为人体有三把锁, 眉锁, 手锁, 脚锁, 这种被称为 封闭式姿势 眉锁往往让人觉得在为事情发愁, 有些人会在思考问题时皱着眉头, 这是不好的, 会让人觉得 形象不佳, 心事重 上手锁(叉手抱胸)则让人感觉不满意, 高高在上, 锁脚同样这样 在心理学中, 手代表对人的认可程度, 脚代表对事情的认可程度. 而一只手横着胸前, 一只手竖着, 这就代表正在思考问题, 正在纠结. 当一对多讲话时, 手放在肚子上, 就代表不自信和紧张 个人修为(修养)越高, 坐着越四平八稳, 没有过多的动作 向人递交资料的时候. 需要注意: 双手递送 书本上的字朝向对方 眼睛要盯着对方的小三角, 对方拿到后再移开 向人递送笔时, 需要注意: 拔下笔帽(如有) 笔尖朝向自己 眼睛盯着对方小三角 如果需要对方签字, 同时注意要解释和指导对方在哪里签, 手指向签字的地方, 注意大拇指收起来, 隐藏在手掌中. 握手 握手是非常重要的, 怎么样握手 距离一米之内, 与别人保持一样的站姿或者坐姿 力量均当或者稍稍用力, 代表热情 两者之间不要有桌子或者椅子的阻隔 如果两者之间隔了一个人, 要先与这个人打招呼握手, 然后再与他打招呼握手 和他打招呼要考虑其他人的感受 与对方握手不要是\"空心\"的, 就是你和对方的手掌心直接是空的, 这叫留一手, 应该与对方贴合 握手时颠两下, 同时打招呼 握手时另一只手不要插兜或者背后面, 自然垂下即可 一般的, 被尊敬者先伸手, 当拜访时, 是主人先伸手, 离开时, 客人先伸手 职场中领导先伸手 社交时, 女性先伸手 正确坐姿 在交流时. 把肘关节到手指的 2/3 放到桌面上, 显得有亲和力 身体微微前倾 坐下时, 屁股越靠前越显得谦恭, 越靠后越自信 如果要靠后坐, 直接靠到背靠上, 注意不要尾椎骨和椅子直接有空隙, 显得吊儿郎当且对身体不好 男生坐着不要两腿并直合在一起, 显得阴气重 男生两腿分开, 但是不要宽过肩膀 可以一个脚在前一个在后, 不要距离太远, 不要靠在一起(脚锁) 不要出现脚锁, 显得隔阂 餐桌座次 主一: 宴请方 主二: 陪同方, 处理琐事的 按照圆桌举例, 一般主一坐在正对门, 最里面, 主二坐在门口, 背对门, 方便交际 客一坐在主一右手边第一个, 客二坐左手边第一个这样排序 站姿男 抬头, 挺胸, 收腹, 收下巴 大拇指永远不要插进另一只手 方案1 手放两侧, 手开放式 方案2 庄重站姿 仪式感强, 但是显得有距离感 右手半握, 左手搭右手手腕 左手大拇指不要单独张开, 张开显得张扬 左手大拇指不要握着手腕, 握住显得不自信 当可以放松的时候(认识之后), 可双手搭在一起了, 显得放松, 拉近距离 招手 肘关节在肩以上, 显得热情开放, 休闲自由 肘关节在肩膀和肚脐之间, 显得沉稳大气, 优雅端庄 仪容(男) 手指甲不要长, 显得阴气重 头发前不遮眉, 侧不盖耳, 后不及领, 不要夸张","link":"/2021/09/04/good_etiquette/"},{"title":"记一次goroutine与wg一起使用导致的问题","text":"Send Closed Chan 问题概述 代码逻辑是启动时启动多个 channel, channel1 获取数据监听数据处理后发送给 channel2 , channel2 处理后再给 channel3 等等 在 channel1 写完数据后将通道 channel1 关闭, channel1 关闭后 channel2 也关闭, 达到任务执行完毕后通道全部关闭的效果 我之前的代码是 12345678910111213141516171819func StartVerify() { wg := sync.WaitGroup{} for { data, ok := &lt;-TypicalResChan if !ok { wg.Wait() close(VerifyBossDNSChan) break } go func() { wg.Add(1) ok := Verify(data) if ok { VerifyBossDNSChan &lt;- data } wg.Done() }() }} 后来使用中发现有时候会报 send closed channel 的错误,大佬看了一眼就发现了问题 问题剖析 就以上面的举例, 上游向 TypicalResChan 发送数据时, 如果不是 close 请求, 会启动一个 goroutine 去处理逻辑, 而在 启动这个 goroutine 后在内部进行 wg 的 Add 注册, 注意这个过程是有耗时的, 所以问题来了, 当上游向 TypicalResChan 发送 close 时, 进入 !ok 的逻辑, 此时等待 wg 释放, 此时有可能上一个数据接收到后还在启动一个 goroutine ,还没有 Add注册, 此时wg没有监听到这个 goroutine 的注册, 造成不会等待这个 goroutine ,直接就关闭了 TypicalResChan, 而这个 goroutine 执行后向 TypicalResChan 发送数据时 TypicalResChan 已经关闭, 所以会报错导致 panic 另外, 还需要注意的是在 wg 没有注册前就 wait 是不推荐的, 很容易出现问题 还有就是判断通道关闭更推荐使用 range 省去判断 !ok 的步骤保持代码整洁 问题解决 修改成这样即可 123456789101112131415func StartVerify() { wg := sync.WaitGroup{} for data := range TypicalResChan { wg.Add(1) go func(data Result) { defer wg.Done() ok := Verify(data) if ok { VerifyBossDNSChan &lt;- data } }(data) } wg.Wait() close(VerifyBossDNSChan)} 在上游 close 时 range 会自动结束, 而受到正常数据先 Add 防止时间差导致的 Add 失败问题, 在 1.14 后 go 优化了 defer 的逻辑, defer 基本不再有消耗, 所以推荐使用 defer 注册 wg 的关闭, 而在 close 时, for 循环结束, wg 在 wait 后再 close","link":"/2021/09/04/gorouting_and_wg/"},{"title":"为什么gRPC使用HTTP2而不是WebSocket","text":"在跟同事聊天(摸鱼)的时候, 谈到gRPC使用HTTP2的好处, 然后同事抛出来一个问题, 为什么不使用websocket, 于是在我查找了相关资料后有了这一篇博客 什么是RPC 本文的主要目的不是讲什么是RPC, 什么是gRPC, 但还是稍微带一点(怎么可能是为了凑字数😗) RPC其实就是**远程过程调用(Remote Procedure Call)**的缩写, 是属于计算机通信协议的一种. 其实从名字也能看出来, 就是在一台计算机的程序去调用另一个地址空间(可能是本机的不同虚拟空间, 也可能是不同计算机)的程序, 而作为开发者来讲, 无需关注这部分细节. RPC是一种 服务端-客户端(Client/Server)模式, 通过客户端发送请求到接受回应这个过程来进行信息交互. 因为是调用另一个地址空间的程序, 所以需要进行信息的传递和发送接收, 抽象出来流程大致如下 123客户端: 本地调用 --&gt; 参数封装 --&gt; 发送调用信息服务端: 接收调用信息 --&gt; 解除封装 --&gt; 调用本地服务 --&gt; 获取结果 --&gt; 封装结果 --&gt; 发送结果客户端: 接收结果 --&gt; 解除封装 --&gt; 本地返回结果 因为是跨空间调用, 为了保证运行正常, 肯定要约定好内容的格式/规范, 就跟你让别人帮忙买彩票, 对面是个不懂汉语的外国人, 他就不知道你想要他干嘛, 就会导致无法正确执行下去. 这里面可分为两部分 内容组织约定: 分为调用语法和内容解压缩两个部分, 比如我要调用你的哪个功能, 给你的信息是怎样的结构等 网络传输: 涉及到真正的互联网传输, 就比较复杂了, 怎么区分二进制的哪一部分是RPC调用, 哪一部分是消息体, 这些解析都要通过协议去实现和约束. 怎样去传输信息, 就比如ONC RPC, RESTFULL HTTP JSON, gRPC 等等 wiki: 远程过程调用 - 维基百科，自由的百科全书 (wikipedia.org) 什么是gRPC gRPC也是RPC的一种, 是google使用C++开发的一款跨语言, 二进制编码的数据序列化协议, 他有几个显著特点 gRPC使用 protobuf 来进行数据的编码与内容的定义, 数据压缩率很高, 直接提高了传输的效率. gRPC使用 HTTP2 进行网络传输 gRPC的爸爸是google, 所以他有很好的 社区支持, 版本迭代, 生态, 插件 等等 gRPC官网: gRPC protobuf: protocolbuffers/protobuf: Protocol Buffers - Google’s data interchange format (github.com) HTTP2是什么 HTTP2是2015年IESG批准的新的HTTP协议, 使用了类似SPDY协议的方案. HTTP2的优点(相比1.1)有: 真正的多路复用: 虽然1.1中就有了keep_alive, 但是本质上只是保持不断TCP链接, 而并发时还会申请多个keep_alive, 导致资源损耗, 而且当keep_alive链接存在的数量超过限值时, 其他的新请求就会阻塞直到空出位置, 而2则是真正的多路复用, 将指向同一个域名的请求都由一个TCP链接发送, 防止资源损耗 HTTP2传输数据使用的是二进制数据, 因此可以通过数据封装(二进制帧)来实现多个请求通过同一个链接发送和接收, 也就实现了多路复用 HTTP2协议中针对每个请求, 可以放置优先值, 双方可以通过优先值来决定不同的处理策略. 服务器主动推送: 服务端可以主动推送给客户端数据, 而不是被动的返回数据 更小的数据: 因为是二进制数据, 所以使用压缩算法(HPACK)可以减少数据的大小 wiki: HTTP/2 - 维基百科，自由的百科全书 (wikipedia.org) 为什么使用HTTP2 看过上面, 可能你的脑中就有了模糊的答案, 我们再翻翻gRPC的最早一篇博客gRPC 的动机和设计原则 | gRPC, 里面记录了gRPC的设计原则, 大致如下: 服务不是对象, 消息不是引用: 微服务的概念 覆盖广和简单性: gRPC需要在每个流行的平台上可以使用, 而且足够简单的使用, 没有很高的硬件要求 免费开放: 所有人免费使用基本的功能 互操作性和范围: 必须能在常见的互联网基础设施上运行 通用和高性能: 应适用于广泛的用例, 同时不会牺牲性能 分层: 代码分层, 版本迭代不影响基础使用 多种数据类型: 不同的服务需要使用不同的消息类型和编码，如协议缓冲区、JSON、XML和Thrift；协议和实现必须允许这样做。同样，对有效载荷压缩的需求也因用例和有效载荷类型而异：协议应允许可插拔的压缩机制。 同步和异步: 同时支持异步和同步处理客户端和服务器交换的消息序列。这对于在某些平台上扩展和处理流是至关重要的。 取消和超时: 取消允许服务器在客户行为良好时回收资源。当跟踪因果链时，取消可能会级联。客户端可能指示呼叫超时，这允许服务根据客户的需求调整其行为. 限流: 在必要时可以对请求进行限流 等等… 我们发现, HTTP2 符合 gRPC 的要求: 覆盖广: 在标准推出后, HTTP2 就被主流浏览器和网关等支持, 最小可用的硬件标准十分的低, 手机端/电脑端/服务器端/iot端 受网络的推动, HTTP2发展普及很快 简单性: 大量的网络框架和组件/网关等支持简单的开启HTTP2, 开发者无需关注更底层的socket处理, 专心业务. 免费开放: 是开放的标准, 任何人都可以使用 天然支持物联网/手机/浏览器: 互联网推动 高性能: 相比1.1有长足的进步 流控: HTTP2维持一个TCP连接, 所以对流控制比较简单 安全性: 天然支持SSL 鉴权成熟: 从HTTP1发展出的鉴权系统很完善, 可以使用到2上 当然, 与人无完人一样, HTTP2也有其缺点: 传输还不够高效: 虽然有HPACK, 但是对于RPC来讲, 还可以更加的简单快速, 比如将某个功能标记为一个int数字, 客户端直接传入数字即可标识调用服务端的哪个功能 gRPC使用HTTP2需要解码两次, 一次是HEADERS一次是DATA HTTP2标准是本身只有一个TCP, 但是其实gRPC的实现会有多个TCP 在速度上, 有更加快速的协议, 但是综合考虑后还是HTTP2更加适合, 相信很多书都会强调一个观点适合的才是最好的 为什么不使用websocket websocket看似也是流式传输, 也可以做到一个websocket传输所有信息, 为什么不选择websocket? stackOverflow有一个提问类似: http2 - Does HTTP/2 make websockets obsolete? - Stack Overflow 其实还是适不适合的问题, websocket和HTTP2是有所不同的, HTTP2的推出也不是为了替代或者超越websocket, 他们是不同的作用领域, 相比于websocket, HTTP2在通用性上更加适合gRPC Will WebSocket survive HTTP/2? (infoq.com) 适合的才是最好的","link":"/2021/09/05/grpc_use_http2/"},{"title":"自卑与超越 (1)","text":"书籍信息 书名: 自卑与超越 作者: 阿尔弗雷德.阿德勒 出版: 中国妇女出版社 作者生平 作者真的是很传奇的人物, 你也可以自行百度, 这里简述一下 作者 阿尔弗雷德.阿德勒 是奥地利人, 出生于商人家庭, 生活富裕, 家人爱好广泛, 但是作者的哥哥很优秀, 活泼好动, 惹人疼爱. 让作者感到自卑, 认为自己又矮又丑. 但是他友善又随和, 他的父亲宠爱阿德勒, 常常鼓励他 阿德勒, 你不能害怕任何事情, 鼓励阿德勒. 阿德勒从小患有脊柱炎, 导致身体虚弱, 行动缓慢, 在他三岁时他的弟弟在他身边去世, 他小时候被车撞过两次, 导致她对死亡特别恐惧, 5岁时又得了肺炎, 在痊愈后, 他决定当一名医生来帮助他人. 他的妻子是一位俄国人, 比较独立, 而阿德勒相对保守, 所以两人生活并不和谐, 但是还是走到了最后 因为阿德勒待人友善, 不拘小节, 所以朋友很多, 所以认识了弗洛伊德, 是另一位心理学家, 从此进入了心理学 阿德勒的观点是, 由身体缺陷或者其他原因导致的自卑, 不仅可以摧毁一个人, 还能让其自甘堕落或引发疾病. 但是合理的看待, 就可以让自己奋发图强, 积极进取, 弥补缺点, 走向成功 同时, 他认为人类都有一种强烈的愿望, 希望自己变得强大 还认为儿童天生具有自卑感, 因为他们身体弱小, 当儿童利用自卑感逃避生活时, 就会出现神经问题. 自卑不是心理变态, 而是在追求优越时的正常表现. 阿德勒创建了个体心理学, 认为人类的行为都是出于自卑感以及对自卑的克服和超越 第一章: 生活的意义 现实生活是具有意义的, 人在生活中, 并不是单纯的体验环境, 而是以他们对人类的意义去评判事物 如果有人排除事物的意义而只去关注环境, 就会孤立自己, 脱离人类. 人类的存在无法脱离生活的现实, 自我封闭毫无意义 当人遇到挫折时, 总是会问: 人的意义是什么? 活着是为了什么? , 对于这种问题, 其实每个人都有自己的理解和答案, 这个答案不需要口述, 从这个人的言行举止就可以看出来. 你的性格决定了你的态度和生活的观点, 而性格是自己养成的, 是自己对事物的理解. 所以, 对人生意义的理解多少会包含谬误, 但是每个人的理解都不一样, 没有人是真理, 因此不能说谁谁的理解是绝对错误的, 因为对个人而言都是相对正确的, 但是要注意, 只要坚持普遍的标准, 那么我们就能得到科学的理解, 得到相对于人类而言正确的意义. 人生总要面对的三个大的问题, 所有问题都绕不开这三个终极问题 人类的活动范围是有限的, 现阶段人只能生活在地球表面, 生活范围是有限的, 同时又心存希望, 人必须发展才能生存下去, 才能延续. 这是每个人逃不开的问题, 每个人都是人类这个群体的一份子, 人类其实很脆弱, 所以为了生存, 人会去努力强化自身 每个人都是无法独立生存的, 人类是一个整体, 一个人无法存活, 只能走向灭亡, 单独人无法完成目标, 也无法延续生命, 因此人总是需要合作, 我们和他人是互相联系的, 为了生存, 我们必须合作, 所以我们需要让自己的感情与与他人合作相适应 人类有男有女, 这是人类延续必须面对的问题, 无论是谁, 无论男女, 一生中都无法绕开爱和婚姻这个问题, 而每个人在面对这些问题时的选择不同, 他们的选择就是对这个问题的答案. 他们的行动就是他们认为的最佳的解决方法 这三个问题引申出三个问题: 怎样在地球自然环境的限制下生存 在人海中, 如何给自己定位, 相互协助, 发展共赢 如何进行自我调节, 适应两种性别和人类的延续依赖于两性关系的事实 个体心理学将人的所有问题归为三大类: 职业, 交际, 两性 每个人对这三个问题的不同回答精准的揭示了每个人对生活意义的理解. 比如说有一个人, 他缺乏爱情, 在工作中不积极, 不喜欢交朋友, 认为人际交往是令人痛苦的, 这样会我们会认为他成功的几率不高, 他认为: 生命的意义就是让自己免受伤害, 把自己封闭来保证自己的安全 另一个人, 爱情美满, 交际广泛, 朋友多, 善于协作, 工作有成, 那么这个人就是善于成功的, 他认为声明的意义就是懂得发现别人的价值, 让自己发光发热, 为社会做贡献 对人生的意义的理解, 无论是正确还是错误, 都有一定的共同性: 精神病,罪犯,酗酒者,问题少年等失败者, 之所以失败, 是因为缺少友情, 对社会冷漠, 在处理问题时, 对合作缺乏信心, 不寻求他人的帮助, 认为人生是以自我为中心, 他人无法分享自己的成功, 这种心态, 就算取得了自我认为的成功, 实际上也只是虚无的优越感, 这种成功只有对自己才是有意义的, 对他人完全没有意义. 自我意义是没有任何意义的, 真正的意义是与人交往中体现出来的, 同样的, 我们的目的和行为也是这样. 我们每个人都为成功而奋斗, 但是如果不明白成功是建立在为他人做贡献的基础上, 那么就会出现错误, 而且, 自我意义是无法得到别人的认同的, 也就是禁不起实践的检验 真正的人生意义是具有普遍性的, 就是可以与他人共享, 并且大多数人可以接受. 我们可以发现, 在生活中, 对于某个问题好的解决方法同样适用于他人, 当我们将某个人称为 天才/伟人的时候, 必定是这个人对社会有贡献, 对社会有益. 所以, 人生的意义是 对整体作出贡献. 他们都是珍爱他人并且善于合作的人, 即使遇到困难也不会损害他人的利益 可能有人会问, 如果人生的意义在于贡献,关爱和合作, 如果我总是以别人利益为重, 那我自己呢? 我自己的利益谁来保证呢? 谁来回报我呢? 这样的观点是错误的, 因为只有为别人考虑, 为别人做贡献, 才会体现出自己的价值, 同时会提高自己的能力. 因为若要实现目标, 必定会提升自己, 进行实践. 举个例子, 在爱情和婚姻中, 如果我们想要让对方感受到辛福和快乐, 肯定会提升自己, 让自己变得更好, 同时尊重对方, 为对方奉献. 如果自我独立, 只会让自己变得盛气凌人, 令人生厌. 再进一步, 我们还会发现, 人生的真谛在于奉献, 我们可以发现, 所谓的遗产, 就是前人留下的东西, 其中被称赞的遗产, 必定是对他人有好处的, 这些前人就是在奉献. 他们都领悟到了人生意义, 反之, 有些人逝去时什么都没有留下, 这种在历史上没有丝毫痕迹, 就像风一样逝去了. 但凡被大众认可的宗教, 无一例外也是推崇为人类做贡献的, 都推崇普渡众生的思想. 在人一出生的时候就开始了对人类意义的探索. 在小时候, 人对社会没有经验, 不知道人生意义. 但是需要知道的是, 在到我们5岁的时候, 其实我们的行为模式已经养成了, 这样会导致我们已经有了自己的方式去了解人生意义, 这样就可能出现一个问题, 如果我们已经养成了错误的习惯, 就会导致我们可能会通过错误的方法得到错误的人生意义. 但是这并不代表已经无药可救, 只是说如果已经得出了错误的人生意义, 即使他们因此遭受了不幸和痛苦, 也很难去改变, 但是如果你重新思考, 并对自己的认知加以修正, 就会改变现状. 探寻到真正的人生意义, 让自己走的更远. 有人的童年是不快乐的, 痛苦的, 但是会出现两种结果, 一种是千方百计的摆脱困境. 在他的心中, 会有这样的想法: “我一定要努力加油, 改善自己, 让我的孩子不像我一样” 反之则会自甘堕落. “老天爷对我真残忍, 所以我为什么要对别人好呢?” 还有一种则是走向极端, “我童年就这个样, 所以我见不得别人好, 我吃的苦很多, 所以我做什么都是情有可原的” 由此可见, 对人生意义的理解是与个人的行为绑定的, 如果不改变思想, 行为是不会改变的. 每个人的经历并不能决定人生的成败, 但是会对其命运造成影响. 环境并不能决定我们对人生的理解, 单身我们可以通过解读人生境遇来改变自己 成年人中的失败者, 很大部分是因为小时候就没有对人生意义有正确的理解, 并且一直受其影响, 他们无法意识到人生的意义就是为社会做贡献, 除非有人引导, 否则会一直的以自我为中心. 这本来会导致变得自傲, 然而因为小孩子没有安全感, 反而会变得自卑, 因为被排挤变得内向, 认为自己不会对社会造成任何贡献. 而对于身体不健康的孩子也是这样, 但是我们也能够看到, 那些有困难的孩子在克服困难的同事, 也会激发自己巨大的潜能 有不少杰出人才身体上有缺陷, 甚至因此英年早逝, 但是他们留下的贡献是巨大的, 但是这总归是少数, 更多的缺陷者因为没有正确的引导, 变得越来越自卑, 抵触与外界接触. 以自我为中心, 这也让我们明白, 他们因为过度的关注自己的缺陷, 让自己产生了无形的压力. 同时家长对孩子的溺爱也会导致人生意义的曲解, 他们会认为他们的愿望就是法律, 因为他们总能被满足, 而不需要自己付出. 但是当他长大后, 发现他不再是人群中的焦点, 便会不知所措, 觉得别人对他有所亏欠, 同时, 之前习惯了索取而不付出, 导致没有自立的能力, 不知道自己能做该做什么. 不懂的与人相处, 寻求合作. 而是在遇到困难的时候直接求助别人. 被过分的宠爱的小孩子很可能会在长大后变成危险人群, 如果让他们与别人合作, 他会觉得不满, 甚至会恶意的捣毁这件事情, 如果他们得不到别人的呵护和关心, 便会认为他人在背后使坏. 导致与很多人为敌, 如果别人不赞同他的行为方式, 便认为这是欺辱, 这样会导致与周围人都是敌对的. 受人冷落的儿童同样会出现问题, 因为他们不会与别人合作, 不懂得关心, 当他们遇到困难, 就会不愿意求助他人, 导致失败, 同时在看到社会冷漠的一面时, 就会认为社会一贯如此, 他们会怀疑别人, 同时无法相信自己 在小孩子出生后, 母亲的最初任务就是让孩子一出生就感觉到对自己的依赖, 然后帮助孩子慢慢的将这种依赖的范围扩大, 直到周围的环境, 如果不这样, 不让孩子对周围一切感到兴趣, 很可能就会让孩子对社会不感兴趣, 不善于合作. 我们发现, 对于不受重视, 总是孤独的孩子, 通常缺乏对人的依赖感, 也不会与人合作, 导致失败. 上面的说明, 证明了, 对于孩子来讲, 过于被溺爱, 身体残缺, 被忽视, 都会导致心理出现问题. 人在睡梦中压力很小, 所以在梦中性格会毫不犹豫的表现出来, 学会解析梦境很重要, 因为梦中的事情总是最真实的你所做的事情, 梦其实是在告诉你, 看, 这就是你得到的结果 儿童早期的记忆对我们的生活有直接的影响, 因为这是我们对自己和周围环境的最初印象. 也是我们主观印象的开始. 对人生观的建立有重要影响. 性格是可以被改变的, 我们可以通过培养自己的勇气和乐于合作的精神来改善孩子错误的人生观 要培养他们的合作精神, 因为孩子在受宠时总是变得自私与自大, 当他们长大后, 该缺点会愈发的放大, 我们需要让他们知道. 术业有专攻, 没有一个人是全知全能的, 复杂的事情通过合作会有更好的结果. 我们必须要有自己的人生, 这是我们的事情, 我们应该感觉到做起来得心应手, 我们是独立自主的, 我们自强不息, 应当有推陈出新的义务","link":"/2021/09/04/inferiority_and_transcendence(1)/"},{"title":"逻辑学入门(1-22)","text":"书籍信息 书名: 逻辑学入门 作者: 格桑 出版: 中国纺织出版社 序言 逻辑是什么? 很多人对此一知半解, 逻辑可以是思维的规律/规则, 可以是某种理论/观点/行为方式, 也可以是客观事物的规律性, 当然也可以是逻辑学的总称. 本书写的并不是什么大道理, 而是生活中的推导和证明某一件事的思考的过程 人总是习惯性的陷入一种\"一厢情愿\"的思维方式中, 诚然, 这样会让我们觉得温暖/快乐/踏实/惬意, 如果你是在梦里, 那没什么不好, 但是令人沮丧的是, 我们生活在真实的世界, 事物的发展总是不那么符合我们的预期， 所以我们最好早点摒弃\"一厢情愿\"的思考方式, 这样才能让我们面对生活时更加得心应手 人的一生有N多次选择, 免不了的我们会在一些选择中犯下错误, 其中逻辑错误是在底层, 因为现实生活中一切都有其逻辑, 所以如果我们犯了逻辑错误, 或者说违反了逻辑, 那么必然会导致出现一连串的错误 这也意味着, 如果我们可以掌握好逻辑, 去按照正确的逻辑思考事情, 就可以少走部分弯路 奥斯卡-王尔德说: “逻辑没有爱情一半重要, 但他能证明事情” 逻辑可以让我们分辨别人对我们说的话是真是假, 因为世界上的事情不以某个人的意志为转移, 很多的事情其本质和表现出来的现象并不是完全相同的, 因此在遇到事情或者看到东西时, 我们需要去思考, 这件事是不是真的, 怎么证明他是真的, 如果我们去理性的思考和分析, 就可以识别出大部分不符合逻辑的, 不正确的事情, 发现事物的本质. 往往对我们造成伤害的, 不是我们不知道的事情, 而是被伪装了的我们已经知道的事情 正文 偷换概念 课堂上, 老师提问学生， 你是怎样认识孙中山的？ 学生答， 我不认识孙中山 很明显的, 老师所说的 认识 指的是对孙中山这位历史人物的理解, 而学生所说的 认识 则是日常生活中的交往关系 此学生就犯了 偷换概念 的逻辑错误，即在同一思维过程中，在中途改变某个概念的内涵或者外延，用一些听起来一样的概念进行偷换，把某个事物的原意用狡辩的手法替换成另一个看起来也可以成立的解释，把假的说成真的，来达成目的 我们在日常与人交流时，一定要牢记对方提到的概念，当对方口中的概念发生偏移时，一定要多加留意，防止落入对方的 偷换概念 的逻辑陷阱 混淆概念 在逛商场的时候，远远的看到有某个花生油上面贴了买一送一的牌子，走近一看发现是买一个花生油送一个漏斗 对于 买一送一 这个词语，就包含了混淆概念的问题，混淆概念，即在同一逻辑思维过程中，把不同的概念当成同一个概念来使用，这几个不同的概念一般是表面相似来达到混淆的效果 我们需要注意对比较容易混淆的概念进行区分和辨别，提高警戒，严格区分和确认概念是否一致，并结合真实的情况和语境来综合判断是否是一样的概念 模糊概念 伯乐告诉儿子千里马是 脊骨弯曲、额头隆起、眼睛突出、善叫会跳，结果其儿子拿起蛤蟆认为蛤蟆是千里马 这与伯乐的表述有关， 伯乐并没有表述清楚千里马的范围，只是说了其特征，伯乐的儿子在没有充分了解概念的情况下就犯了模糊概念的错误 在思维的过程中，人们提及的概念都应该有明确的范围，如果你形容一个人的身高为 挺高的 这就是模糊的表达，这是难以衡量的 所以在听别人讲话时，一定要仔细辨别有相对含义的概念，并进一步追问以免出错，同时我们表达观点时也要注意表述清晰，遵守 简单原则，避免抽象描述，简化语言的枝叶，做到 言简意赅，这样对倾听者来说就不是一头雾水了 归纳谬误 有一只鸡喜欢归纳，他见每次主人喂食都在6点，于是他认为每天6点是喂食时间，直到有一天主人6点钟将其宰杀 无论归纳了多少事例，归纳的结论始终是充满不确定性的，只要出现了一个反面例子，归纳的结论就会被推翻 善于归纳总结是好事，但是不要武断的做出结论，这样很容易陷入偏执之中，如果我们使用总结出来的归纳谬论与别人争辩，很容易火上浇油，对沟通有害无益 要记住，客观的世界其实很复杂的，我们的认知总归是有限的，过去的规律和经验不一定能帮助我们解决当前的问题 我们需要在生活中使用归纳法，但是更要明白：有限的归纳法存在谬误的可能，这本身也是风险所在，我们永远要秉持质疑精神，确信所有的东西都是暂时的，一旦陷入偏执，对某些事物产生路径产生依赖，或者想当然的去以为什么，很容易面临失误 人们在澳大利亚发现黑天鹅之前一直认为天鹅都应该是白的 协和谬误 年轻人在打折期间办了健身房会员卡，后来得病医生禁止其剧烈运动，当健身卡无法退款的情况下，年轻人选择依旧去健身 年轻人明知道带病锻炼对身体的伤害是巨大的，依旧选择去健身，是因为他花钱购买了会员卡，又无法退款，浪费会员卡让其无法接受，所以铤而走险 年轻人面临的问题在逻辑学上被称为：协和谬论， 指在某件事情上投入了成本后，当发现不适合继续时，因为不舍得之前的投入，选择将错就错，造成更大的损失 正确的做法是果断地抛弃沉没成本，带着痛苦转身，如果不止损，继续投入。可能会有柳暗花明的那一天，但是概率很小，并不是所有事情坚持到最后都有好结果。很多时候我们要敢于认赔服输，半途而废，开始新的事情，而不是继续在协和谬论中苦苦挣扎 滑坡谬论 印度电影：起跑线 中的妻子不愿意 让自己儿子读她自己小时候的学校，认为孩子上不了好的幼儿园就上不了好的中学，就上不了好的大学，找不到好的工作，被同龄人抛在身后，然后走入歧途 但是我们知道，孩子上不了好的幼儿园不代表上不了好的中学，被同龄人抛在身后更是无稽之谈，我们都是普通人，妻子其实就是犯了 滑坡谬论 滑坡谬论指的是不合理的使用一连串的因果关系，将 可能性 转化为 必然性，得出某种结论 通常是链条式的，由 A 到 B，再到 C， 再到 D，一步步的推导出极端的结论 这种情况并不是因为其本身是链条式，而是在于链条中的每一个环节因果强度是不一样的，有些因果关系只是可能，而不是必然，所以在没有足够的证据之前，不要认定极端的结果必然会发生 赌徒谬论 40位博士参加一个实验，玩100局游戏，赢的概率是60%，每人初始额度1万元，最后金额大于1万的只有2个人，其实每次投资100元，最后能得到1.2万元 研究发现，人倾向于在不利的情况下投资更多的筹码，而在有利的情况下则反之 比如在连续输了3把之后他们会认为，下一把一定可以赢，然后投资更多的筹码，这就是赌徒心理，也叫赌徒谬论 这是一种不合理的逻辑推论，他们错误的认为随机序列中的一个事件发生的概率与之前发生的事件有关，即发生的概率会随着之前没有发生该事件的次数而增加 比如抛硬币，实际上我们知道每次的正反面概率都为50%, 但是赌徒谬论认为：连续两次抛出正面的概率为50%*50%=25% 其实无论你之前抛了多少次，正面多少次，反面多少次，下一次的概率依旧为50%，他不受之前的结果影响 看透赌徒谬论可以让我们更加理性的看待生活，避免让主观上的自信影响了自己的逻辑判断 诉诸怜悯 被警察抓住的小偷总是会说：我刚从外地过来，钱包丢了等等，总之是不得已才行窃 我们知道，任何事情总有其代价，这样的解释在法律面前并不适用，那他们为什么还要这样说呢？这就是诉诸怜悯的问题 诉诸怜悯是指在论证某个问题时，不是通过正面论题论证，而是利用受众对弱势的怜悯心理，诉说某个人的惨状来激起人们的恻隐之心，这其实就是转移话题，是一种逻辑谬误，无论所说是否真假，也与所作所为没有必然联系，不是支持论断的逻辑理由 我们在看待事情时，不要被同情心蒙蔽了双眼，而忽略了其所作所为，忽略了问题的本质 人人都有恻隐之心，但是情归情，法归法，两者不能混为一谈，一个理智的人不能用逻辑谬误去代替理性思考，更不能被情绪左右而丧失了客观的分析与判断 诉诸大众 诉诸大众的逻辑谬误, 指在论证一个观点时, 只是因为多数人赞同该观点, 则认为该观点为正确 诉诸大众的典型案例则是所谓的 从众心理 , 即多数人认为他是对的就是对的, 这根本就不是逻辑推论, 而是利用了人的不自信和盲从等弱点 人们总是倾向于让自己的观点得到更多人的赞同, 反之, 多数人都赞同的观点也会对个体的判断产生压力 但是我们要知道, 一个观点的正确与否, 与多少人赞同他无关, 没有必然的因果关系, 永远记住: 检验真理的唯一标准是实践 诉诸个体 与诉诸大众相反的是诉诸个体, 指仅仅根据个案做出总结和结论, 或者以个人经验作为论据来论证 我们要注意的是, 个人的经验是有局限性的, 单个事件也可能存在特殊的因素, 不能将其作为普遍性的材料进行论证 诉诸经验 当儿女的观念与父母不和时，父母往往会说：我走过的桥比你走过的路还多，这就是诉诸经验，我们知道，年龄并不是判断是非对错的标准，观点的正确与年龄大小没有明确的关系，而是要看论据和论证是否符合逻辑 当然，不得不承认，年龄越大、经历越多的情况下，其看待事情的正确性要优于小辈，所以对于经验，我们要辩证看待，既要吸收其合理部分，也要学会辨别其中不合理的部分，尤其注意要具体问题具体分析，不能被经验画地为牢 诉诸无知 没有人能证明外星人存在，所以外星人一定不存在 只是因为没有强有力的证据去证明或者反证，就认定某个观点是对的或者错的，此为诉诸无知的诡辩，也是很多阴谋论者的逻辑 人的认知是有限的，要证明某个事物的存在是很困难的，更别说去证明外星人这种我们没有见到过的事物 诉诸规则以外 凡事都有其规律，也有其规则，比如信用，失信者总是会诡辩说失信的事情是例外，殊不知 规则与例外，本身就是对立的，规则就是规则，例外就是破坏规则，破坏了规则就要付出代价，比如失信者不被别人信任，这就是代价，破坏规则一定会付出代价 诉诸完美 如果这件事情，我没有办法做到完美，那么就干脆不做了 这就是诉诸完美的逻辑谬误，总觉得不完美的是不能做的，这种想法只会导致无线拖延，错过大量的良机，甚至一事无成 谁也无法保证做一件事情可以万无一失，任何事情只有先去做了才有完美的可能，很多时候都是机不可失，时不再来 诉诸最差 我只是偷东西，又没有伤人 作恶者通常使用对比来祈求原谅 作恶与没作恶，是根本性质的问题，大恶与小恶，是严重程度的问题。两者不可混为一谈 诉诸信心 人们总是希望能得到他人的信任和理解 诉诸信心，指依仗信心作为论据的根基，而不是靠逻辑或证据的支持 诉诸信心的误区：以他人信心为论据，此为诉诸非理性的论证方式 我们要知道，一个人对另一个人的信任，不是建立在“我和你感情好”的基础上，而是建立在事实论据的基础上 诉诸恐惧 恐惧是人类最原始的情感之一, 诡辩者通常利用恐惧来强化自己的观点, 即为诉诸恐惧 诉诸恐惧通常刻意描绘危险, 让人感觉到恐惧, 从而愿意听信诡辩者的建议, 通常诉诸恐惧并不是凭空捏造, 而是有一定的根据, 只是可以的夸大其词, 以达到效果, 达到说服他人的目的 诉诸反诘 你说刷手机对眼睛不好，你不也老刷吗？ 说这些的目的是为了批驳对方的观点，但是采用的方式不是通过讲道理，摆事实去论证问题，而是通过向对方反诘来用对方的行为去批驳对方的观点。 正确的方式(以刷手机为例)，应该分析诸如手机屏幕发出的蓝光对视力有什么影响等才是有理有据的论证 我们不能因为刷手机这件事有人做就认为他是无害的 诉诸沉默 不说话不等于默认，不说话不等于心虚 诉诸沉默，指由于论点的主张者没有论证该论点，从而推断该论点是假的，这是不对的，论点的主张者没有论证论点这个行为，本身并不能成为该论点为假的理由 诉诸势力 人在屋檐下不得不低头 书的作者认为必要时也要为自己寻求权利，而不是因为多数人选择承受而随大流 动机论 在生活中，切记不能 以小人之心，度君子之腹 这种怀疑主义，是一种动机论，属于逻辑谬误，这与科学精神中强调的质疑精神有本质区别 科学精神中的质疑精神都是有前提条件的，他们有充足的理由，建立在实证和理性的基础上，是以事实条件为基础，以实验和检测为手段的，有根据、合理的怀疑 诉诸权威 我们要知道，名人说的话不一定是对的，诉诸权威的谬误，指的是认为权威人士说的话都是对的，实际上，权威具有相对性、多元性、可变性、时效性。 我们在引用权威时，需要注意以下几点 诉诸的权威必须是论题所在领域的权威，毕竟隔行如隔山 权威会过期，时代在进步，上限在不断提高 权威所秉持的观点，要在诸多权威中形成普遍共识，如果权威之间本身存在分歧则不适宜作为论据","link":"/2021/09/04/introduction_logic(1-22)/"},{"title":"逻辑学入门(23-44)","text":"书籍信息 书名: 逻辑学入门 作者: 格桑 出版: 中国纺织出版社 正文 重复谎言 三人成虎的故事 众人的言论往往能混淆是非, “谎言重复一千遍就是真理” ，不断地重复一个虚假的观点，就算没有进一步提供论证或支持，也可以削弱论敌的反驳，因为不断地重复会增加逻辑的合理性，让人误以为事实就是那样。 但是要牢记的是，谎言永远不能变成真理，哪怕重复一万遍也是如此，谎言重复再多次也与事实无关，谎言永远无法变成正确的逻辑 强制推理 有些人，看见别人有钱，就说：“这个人，肯定是干了坏事才挣到这么多钱” 之类的话语 强制推理，即将不同的事物错误的勉强的联系在一起，从而得出结论。看似是结论，其实毫无意义，完全是歪曲事实。 比如上面的例子，有钱与干坏事并没有必然的联系，却被有些人强行的联系到一起。将两个不相关的事务强行联系到一起，得出来的结论自然是谬误。 真正理性的是,客观的观察和总结事物的关系, 不掺加主观看法, 不把没有逻辑的事务联系到一起 因果混淆 研究发现, 越是成功人士, 睡眠时间越短 研究发现, 去医院越多, 越容易生病 许多人喜欢把 “接连发生” 的事情引为环环相扣,互为因果. 这种思考方法是错误的, 属于 因果混淆 的谬误. 事物之间有相关性, 并不能证明他们之间存在因果关系. 而有时候, 两者之前的关系恰恰相反, 或者两者之间并没有关系 我们在分析事物时一定要谨慎, 不能把巧合的相关关系视为因果关系, 否则的话就会得出错误的结论 惯性思维 人类无法抗拒的十大心理之一, 鸟笼心理 人们在遇到问题时, 通常都会先入为主的按照自己熟悉的某个方向或途径去联想, 把自己遇到的问题纳入自己熟悉的框架内进行分析, 从而让思维形成惯性, 也就是惯性思维. 就比如鸟笼心理, 人们习惯的认为, 只有鸟才生活在鸟笼里. 家里有鸟笼就证明之前养过鸟. 不要用惯性思维去看待生活中的问题, 偶尔尝试突破鸟笼心理, 进行发散性的思维, 也许我们就会发现鸟笼外有另一个世界 诉诸出生 龙生龙, 凤生凤, 老鼠的儿子会打洞 有些子女与其父母在某种行为或性格上存在相似性, 但是不要过度的 “迷信” 这句话, 甚至将其作为推断一个人 道德/品行/能力/成就 的依据, 这就犯了诉诸出生的逻辑谬误 本章给出两个真实的例子: 赵国名将赵奢/新东方创始人俞洪敏 人从出生开始, 就会受到来自 家庭/社会/他人 等各方面的影响, 这些影响很重要, 但是终究只是外因, 而非决定性的因素, 毕竟人还有主观能动性 出生并不能代表一个人的品行和能力, 出生也无法决定一个人的命运和前途, 我们在看待别人和自己时, 一定不要犯诉诸出生的错误 诉诸人身 有些商家, 当顾客对商品提出异议时, 比如\"东西有点贵\", 商家就翻脸, 用比如 “你可以去买便宜的/一看你就没有眼光” 等话语来反驳 商家这种是诡辩, 根本不符合逻辑, 完全是人生攻击 如果一个人在驳斥他人的观点和结论时, 忽略了论证本身, 而是去直接攻击提出观点的人或团体, 那他就犯了 诉诸人身 的谬误 诉诸人身的谬误门槛很低, 生活中经常遇到, 其主要有两种 直接性诉诸人身: “这个人之前偷过东西, 所以他说的肯定是错的” 处境性诉诸人身: “你买了A公司的股票, 你当然会说A的股票会涨” 直接性诉诸人身指的是, 因为某个人身上存在某种积极或消极的特质, 就认为其想法或论点是错误的, 而通常一个论点是否正确,在于它是否符合事实, 我们是否相信某个人的看法与这个人的说法正确与否没有直接的绑定关系 处境性诉诸人身指的是, 因为某个人处在某个团体中, 这个团体与其有利益关系, 就认为该人的想法是不客观/不中立/不理性 的, 事实上, 当我们考虑某个人的论点时, 可以去考虑是否与某人有利益关系, 但是某人的处境和利益关系并不能直接判断这个人的论点为不真实的/错误的 我们在辩论某个观点时, 切记要对事不对人, 如果遭到了诉诸人身的问题, 不必再争论下去, 直接远离即可 循环论证 A: “你为什么这么胖” B: “因为我吃得多” A: “你为什么吃这么多” B: “因为我胖” 循环论证, 即用来证明论题的论据本身的真实性需要靠论题来证明, 就以上面为例, A最后也不知道为什么这么胖 为什么会出现循环论证的谬误, 归根结底是在论证过程中, 将论证的前提当成了论证的结论, 此为 先定结论. 先预设前提 x, 求出 y, 再用 y 去证明 x 正确. 当然, 循环论证在逻辑上是说得通的, 因为x可以求出y, 所以y可以反推到x, 但是因为结论可能与前设完全相同, 所以结论并不是其前设的推论 在论证的过程中, 所有循环论证都必须假设其命题成立 即x推出来的一定是y, 所以循环论证本身并不能证明什么, 他只不过是回避问题的手段 稻草人谬误 劳动人民会在田地里插上一个稻草人, 目的是欺骗并吓走动物 稻草人谬误, 指的是在辩证过程中, 为了反驳对方, 而 歪曲/夸大/以其他方式曲解 对方, 使得被攻击的不是对方的论点, 而是更容易被批判的立场 比如A想反驳B, 就在B旁边树立一个稻草人当做B, 然后攻击稻草人来冒充和替换A的观点, 此为刻意扭曲 A: “我认为小孩不应该在马路上乱跑” B: “把小孩关起来, 不让他们活动, 这才是不对的” A的观点是不让小孩在马路上跑, B却刻意的曲解观点, 树立了一个稻草人 “把小孩关起来”, 然后攻击稻草人, 但是其实不让小孩在马路上跑并不是要将小孩关在屋子里 我们在生活中, 要站在真实的立场去思考问题, 秉持平和的心态, 减少歪曲/夸大来攻击他人的立场, 一切都拿事实和证据来说话. 当有人对你声情并茂的讲起某件事或某个人时, 不要被颠倒是非的语言影响, 要有自己的判断 要记住的是, 稻草人再逼真也不是真实的人 转移论题 明代有一个学士, 其父并不出名, 其子也不争气, 其孙考上了进士, 其就责骂他的儿子不成材 其: “你真是个废材” 其子: “你的父亲不如我的父亲, 你的儿子不如我的儿子, 我有什么不成材的呢?” 转移论题就是在思维过程中, 吧有些联系或表面上相似的不同话题当做相同的话题使用 其本人要跟儿子辩论的是 “儿子是否成才”, 其子则转换成了 “你的父亲和我的父亲, 你的儿子和我的儿子相比”, 恰好把原来的问题给回避了 为了避免出现这样的谬误, 我们必须要对自己的批判对象了解清楚, 认真把握原意, 避免犯错 诉诸感觉 刻舟求剑的典故 两小儿辩日的典故 当事人为什么认为可以找到宝剑呢? 全凭他个人的感觉, 这种凭借表象和感觉经验来作出判断和推理的, 并且认为以此得出的结论是绝对正确的, 无视事实的情况, 就为诉诸感觉的谬误, 当然经验很多时候也是正确的, 但是经验也要经得起推敲, 同时要注意并不是绝对正确, 还是要仔细的推理和论证才行 同样的, 两小儿辩日, 也是两个人都按照自己的经验来作为结论, 得出的结论就是错误的 我们在生活中, 不要 “想当然” , 否则就会陷入到逻辑谬误中, 有的时候, 我们感觉正确的可能与事实大相径庭 预设谬误 有一些论证是基于假设的, 即用那些被认为理当如此的预设或背景信念去做论证, 但是如果这个假设本身就是有问题的, 那么得到的结果也是不成立的 争议前提 前提1: 在堕胎的过程中, 胎儿被杀害了 前提2: 胎儿是无辜的 前提3: 故意杀害一个无辜的人是谋杀 结论: 堕胎属于谋杀 其中, 前提1是属实的, 但是前提2和3是有争议的, 争议之处在于胎儿是否算是一个人? 拿有争议的论据去论证某个结果, 这个论证本身是存在争议的, 所以不能当做论据 窃取论题 问题: 为什么中国人都爱说谎? 直接给出了结论, 而没有任何论据去支撑, 把需要去论证的结论当作一个前提, 比如这里应该去论证中国人是否爱说谎, 而不是论证为什么中国人爱说谎 复杂问句 A: 我见过C B: C是白猫还是黑猫 A: 有黑有白 B: 你在说谎, 因为C不是一只猫 复杂问句指的是以问句预设了某些假设为真的方式来询问, 你只能去回答对和错, 当这个假设本身为假时, 回答对和错都会导致对这个为假的假设的肯定, 作为被提问者, 我们要仔细辨别假设的真伪, 防止被套路. 当我们身为提问者时. 可以通过这种方式来探听虚实 虚假选言 要么所有英国大学都把项目完全变成在线课程, 要么所有英国人都会破产 这种属于选言, 选言指有两个命题或者选言肢的复合命题, 比如这里的两个 要么, 但是当出现了推理错误, 就会导致影响结果出现错误, 比如这里的两个选择根本上是错误的, 没有实际关联的 例外谬误 狗是友好的动物 我的皮皮是一条狗 皮皮是一只友好的动物 当一个论据是通过普遍的规律来论证的, 并且这个论据占了得到该论点的关键性因素, 但是事实是一个例外时, 就是例外谬误 比如皮皮是一只友好的动物, 但是当皮皮乱咬人时, 这个结论就不成立, 该用户以普遍的规律来论证, 却忘了什么事情都有可能有例外 需要牢记的是: 通常为真的不一定总是真的 诉诸后果 我们公司每月底薪+提成有8000 以讨好或不讨好的结果来说服他人 诡辩者不是通过正常的逻辑来证明自己的观点, 而是通过告知被说服者会有怎样的后果, 来 引诱/哄骗/威胁 被说服者, 来达成目的 否定前件 如果一个人想要出国, 他就需要学习英语, 如果一个人不想出国, 那么他就不需要学习英语, 因为我不想出国, 所以我不学英语 在 如果…那么… 这种格式的论证中, 把 如果… 称为前件, 把 那么… 成为后件 如果前件就是错的, 比如这里的 想要出国 与 学习英语, 两者并无直接的关系, 想要学习英语的动机有很多, 不一定是出国 机械类比 东施效颦_百度百科 (baidu.com) 其中东施就犯了机械类比的错误, 他只看到了西施捂住胸口皱着眉头, 认为是这样才好看, 却没有发现西施的美是客观存在的, 是多方面决定的 类比是一种表达思想, 是进行教育和说服的有力工具, 但是要注意类比前后的事物, 必须要有尽可能多的共性, 还有就是两个事物的本质属性和结论之间一定要有必然的联系 无理假设 我不是故意的, 再给我一次机会, 我一定不… 我们经常可以听到这种话, 听起来真挚动人, 但是要记住, 这只是一种美好的假设, 现实是无法改变的, 在逻辑学上, 假设是一种方法, 可以用于各个领域的研究, 但是如果进行不科学的假设, 目的是为了安慰自己, 平缓情绪, 表达悔恨的, 这种假设就是无理假设 面对一些人的假设, 要保持冷静和理智, 不可轻信和心软, 因为这可能是一种逻辑谬误 双否定前提 所有哺乳动物都是温血动物 猫是哺乳动物 所以猫是温血动物 这种属于典型的三段论, 即先列出两个陈述, 再在这两个陈述的前提下推导出第三个结果, 这种是没有问题的, 但是下面这种 不喜欢吃甜食的人比较瘦 有些抽烟的人不喜欢吃甜食 所以抽烟的人比较瘦 这种就属于错误, 这种三段论的前两段都是否定的, 逻辑学上, 这种被称之为 双否定前提, 这种得出来的结论是不可靠的 不当周延 所有骑自行车的都是节俭的人 没有企业老板是骑自行车的 所以, 没有企业老板是节约的 可能猛一看觉得有点道理, 但是细细思考其实这个逻辑推论是不符合逻辑的, 因为企业老板是否节约与他是否节俭没有直接的关系, 不能因为不骑自行车就说老板不节俭. 这个推导就犯了 不当周延 的错误, 这是因为第一句所有骑自行车的都是节俭的, 这句话只能说明 骑自行车的都是节俭的人, 而忽略了 骑自行车的只是节俭的人的一部分, 有些不骑自行车的人也很节俭, 当你的论据中出现了某个群体中的某个部分的例子, 在结论中却使用某个部分来论证整个群体, 这就是 不当周延, 再看例子, 论据中使用 节俭人群中的骑自行车的人 这个 借鉴群体的一部分人 , 结果中却将 整个节俭人群 来作为证据, 明显是错误的 在很多情况下, 诡辩者会使用 不当周延 来忽悠人, 我们一定要注意这种情况 罗素悖论 罗素悖论_百度百科 (baidu.com) 我们这里不谈对数学的影响, 单从逻辑来讲, 这就属于悖论, 指逻辑上可以推导出相互矛盾的逻辑, 但是表面上又可以自圆其说的命题或理论体系 还有许多这样的例子, 比如 一个年轻人对大发明家爱迪生谈起自己的设想,他满怀信心地说：“我想发明一种万能溶液,它可以溶解一切东西.” 爱迪生听罢,惊奇地说：“那么,你想用什么器皿盛这种万能溶液呢?” 年轻人哑口无言. 这是因为, 万能溶液能把任何东西都溶解了,所以装溶液的器皿也都溶解了,不能用任何东西来盛万能溶液. 但是液体就需要器皿去盛放, 但是如果你能用器皿去盛放了, 这个溶液还叫万能溶液吗? 还有许许多多的悖论, 这并不是一种诡辩, 实际上, 悖论的提出和解决, 是人类智慧的闪光, 也是科学发展的酵母, 在不断的启发人们进行深入的思考 排中律 排中律是事物的规律, 也是思维的规律, 一个事物在某个时间里, 一定会具有某个属性, 或者不具有某个属性, 必须满足两者之一, 比如 A是B, 或者A不是B, 那么对于相互矛盾的两个命题, 一定是有一个是正确的, 不可能同时正确或错误, 此为排中律 西瓜是甜的 西瓜不是甜的 这两个肯定有一个是真的, 不可能两个都是真的或假的 充足理由律 充足理由律_百度百科 (baidu.com) 充足理由律是逻辑思维必须遵守的基本规律之一, 指在论证和思维过程中, 要确定一个判断为真, 必须有足够证明他真实的理由. 如果缺乏足够的理由, 就没有论证性. 正确的思维是思路严谨的思维, 论证的过程要摆事实, 讲道理, 以理服人, 言之以理, 持之以故 现实中经常有人违背这种理由论 毫无理由: 不讲任何理由, 没有任何依据就下结论 理由虚假: 对一个命题来提供理由, 但是这个理由毫无根据, 这个理由是主观的, 是不存在的或者虚假的 论证错误: 指证明论题的理由是真实的, 但是理由与结论之间没有必然联系 在逻辑思维过程中, 无论是被说服者或说服者, 都要找到充足的理由来证明结论, 以理服人 范畴错误 师范大学在哪里? 师范大学指的是一种大学的种类, 而不是指某一所大学, 两者是包含和被包含的关系, 而不是并列关系, 这就是一种统筹错误 曹雪芹是一个天文学家 哈弗大学面积排名第几? 曹雪芹是文学家不是天文学家 哈弗大学是世界名校, 面积大小不影响排名 这种也属于范畴错误, 指的是将既有的属性归属到不可能会拥有该属性的对象上, 是语义学和存在论的错误 小孩子经常会犯这种错误, 因为他们对分类没有明确的概念 断章取义 爱迪生说过: “天才就是1%的天赋+99%的汗水, 但那1%的灵感是最重要的，甚至比那99%的汗水都要重要。” 很多人只看到了 “天才就是1%的天赋+99%的汗水”, 但是爱迪生的原话强调的是灵感的重要性, 只看到第一句可能认为勤奋可以成功, 这就与爱迪生的原义相差甚远 类似于这样的断章取义的谬误越来越多, 不顾整篇文字或谈话的真实意图, 单独的截取一句话进行分析, 尤其是短视频的火热与人们习惯汲取碎片知识 甚至还会被人恶意的引导, 曲解原义而进行攻击, 比如 知识就是力量 原话: 知识就是力量, 但更重要的是运用知识的技能 原义是强调运用知识的技能, 可能被变成过分强调知识本身 吾生有崖, 而知无涯 原话: 吾生有崖, 而知也无涯, 以有涯随无涯, 殆已！ 原义是说生命是短暂的, 知识是无限的, 用有限的生命去学习无限的知识, 是很危险的 我们在引用名言警句作为论据时, 必须要注意不要断章取义, 同时在生活中也要有自己的思考, 不要被带歪","link":"/2021/09/04/introduction_logic(23-44)/"},{"title":"逻辑学入门(45-66)","text":"书籍信息 书名: 逻辑学入门 作者: 格桑 出版: 中国纺织出版社 正文 结构歧义 今天有两个报社的记者参加了活动 逻辑学上, 由于语句中的语法结构具有不确定性导致判断产生的歧义叫做结构歧义 比如上面的语句, 有可能理解为一个报社的两个记者参加了活动, 也可能理解为两个报社的多个记者参加了活动, 这种就是表述者犯了结构歧义的错误 要消除歧义, 最好的办法就是重新组织表述的结构 隐含命题 听话听声, 锣鼓听音 即听人说话的时候, 为了准确把握对方的思想, 听明白对方真正想表达的东西, 不能只听对方话语表面的意思, 因为对方可能在暗示什么 这种别人说的命题中, 隐藏着另一个命题, 被称为隐含命题 隐含命题是一只高明的, 非常实用的表达方式, 用好了的话, 即可以委婉的提出观点, 又不至于得罪人. 你们这的蚊子很聪明, 懂得提前来踩点, 方便晚上就餐 意思是蚊子很多 同构异悖 A: 你这样不会有好结果的, 说真话的话, 富人会怨恨你. 说假话, 穷人会指责你 B: 我会有好结果的, 说真话, 穷人会拥护我, 说假话, 富人会喜欢我 这种仿照对方的辩词的话语结构, 构建一个与对方话语结构完全相同, 表述意思却完全悖的观点, 以此来反驳对方的方式, 叫做同构异悖 大多数时候, 这种反制方式会取得比较好的成果, 往往令人无言以对 分解问题 在日常生活中, 我们一定要学会分解自己的问题, 这样可以让人更好的理解我们的问题; 也要学会分解他人的问题, 为的是减少答非所问的发生 如何更好的提问问题? 确定问题的方向 生活中最简单的疑问句, 莫过于5W+1H When 什么时候? Where 什么地点? What 什么情况? Who 什么人? Why 为什么? How 怎么? 提问时首先要确认你要问的是什么类型, 比如: 你周末去了什么地方? 你上午和什么人在一起? 你昨天为什么不来? 而不是: 你周末什么情况? 你上午怎么了? 你昨天在什么地方? 强调问题的目的 其实, 上面举出的错误例子, 也能从侧面问出来答案, 而正确的提问可以直接的强调你问问题的目的, 更具有目的性, 让对方知道你想要的答案, 让交流顺利的进行 一个问句的疑问词要少于三个 无论什么问题都有侧重点, 这就要求我们在提问时不能在一个问句中包含太多疑问词, 这样会导致回答者无法了解我们的目的 最好一个问句只有一个疑问词, 只问一个问题 你昨天没来上课, 和谁? 去了哪? 干了什么? 这样一句话有三个疑问词, 让人很难回答 在生活中我们要学会分解问题, 提高沟通的效率 虚假两分 这个人是好人还是坏人? 这件事是对是错? 在我们小的时候, 对很多事物没有充分的认知, 认为世界非黑即白, 非善即恶. 到大了才知道, 事情都是有两面性的, 不能像二极管一样去看待事物. 当你认为某件事情非黑即白的时候, 你可能就已经犯了虚假两分的谬误 虚假两分, 指把一个可能存在多个答案的事情, 假设成只有两个答案, 通常这两个答案还是两级反转的, 似乎世界上所有问题都只有两面 而当我们把结论限制在两个以内的时候, 我们的视野就会被限制, 思维会遭到严重的束缚 了解虚假两分的逻辑错误, 有助于我们用开放性的思维去思考问题, 特别是受挫的时候, 能够及时的提醒自己和他人, 还有第三种可能 这样的话就不会走向极端的思考误区, 也不会因为一次失败就彻底丧失自信, 否认自己的价值与努力 从表面上看, 遇到挫折一蹶不振, 是心态过于悲观. 实际上是陷入了虚假两分的逻辑陷阱. 稍加分析, 这是把人生错误的分为了两个极端, 一个是正极端, 一个是负极端, 不是这个就是那个, 没有其他的可能 遇到这种时候, 我们要牢记, 人生并不是只有两种可能, 他是未知的, 发散的, 有无限种可能, 每种都可能实现 我高考失败了, 我这辈子完了 高考失败了可以重新复读, 或者选择其他学校, 不是考不上人生就凉了 我失恋了, 我要单身一辈子了 失恋了可以再谈恋爱, 不是这次没谈好就一辈子单身 当我们意识到了多种可能性时, 我们就能从牛角尖中钻出来, 会发现人身其实不存在绝境, 处处都有转机 事实断言 在提问的过程中, 我们遇到的所有的推理论证, 几乎都涵盖了以下三方面内容 过去是什么样 现在是什么样 将来是什么样 这些看法形式不一, 有可能是假设, 有可能是理由, 也有可能是结论. 但是说话者的目的都是让你相信他的结论 在逻辑学上, 这种被称之为事实断言 当面对 事实断言, 我们不要立刻的选择相信, 要先去分析, 看看这个结论是否有疏漏 如果需要验证 事实断言, 需要完成几个问题 我为什么要相信他 是否需要证据来证实这个断言 证据的效力可靠吗 如果这个断言缺乏有力的证据, 那么这个断言就是 孤立断言, 因为他没有给出证据, 因此我们必然要怀疑 孤立断言 的可靠性, 向对方进一步求证 有时候, 事实断言的真实与否与个人的感觉无关, 比如 “大部分的美国议员都是男性” 可能看起来更加真实, 而 “练习瑜伽可以降低癌症” 看起来不那么真实 所以对于大部分的断言来讲, 要证明他是对的, 还是错的, 是一件很困难的事情 通常来讲, 某个断言的证据越多, 质量越高, 他的可信度就越高, 我们也就越能把这种断言称之为\"事实\", 那么怎么样来帮助我们确定断言的可靠性, 我们可以借助提问来实现 我们可以向阐释者提问 你的证据是什么 你怎么知道他是真的 你有什么证据 你为什么相信他 你能确定他是真的吗 你可以证明吗 这些问题要求阐释者进一步解释这些断言的证据, 以证明准确性, 如果他能大方的立刻的回答你的问题, 大概率是掌握了足够的证据 而顾左右而言他, 回避问题的人, 你就要留意这个断言的准确性了, 因为很可能他意识到了, 自己没有足够的证据去证明自己的断言 隐瞒证据(采樱桃谬误) 这个很容易举例, 现实中也很多, 比如楼盘的销售人员, 总是向你隐瞒房子的缺点 租房的中介 等等 在销售过程中, 业务员会有选择性的摆出论据, 挑对自己有利的话来说, 这就是隐瞒证据, 也叫采樱桃谬误(人们只会采好的樱桃) 比喻有选择性的说话, 只呈现好的部分, 把不利于自己的部分隐藏起来 作为消费者, 我们一定不要被销售轻易打动 答非所问 在某些特殊情境下, 真话说不得, 假话也说不得, 最好的办法就是不说. 这种诡辩被称为 答非所问, 即回答问题时, 有意无意的回答不相关的问题 这通常是为了在某些尴尬的场合, 有些话不方便直接的回答, 但是又不能失礼, 于是就 答非所问, 来避免尴尬 需要注意的是, 在该说真话, 需要表达意见的时候, 还是要真实的表达, 说出答案, 否则就会被认为是虚伪狡猾, 让人觉得不够真诚, 不可信任 绝对化谬误 诡辩术在古代非常盛行，古希腊哲入苏格拉底也精干此道。他有一次和欧西德辩论。 苏：“偷盗的行为对不对？” 欧：“不对。” 苏：“侮辱他人呢？” 欧：“不对。” 苏格拉底转语又问：“为了诱敌而窃取敌物，这种行为可对？”欧西德的头脑很清醒，不为迷惑，答道：“对。” 苏又问：“侮辱敌人可对？” 欧：“对。” 苏格拉底争辩说：“你刚才说偷盗和侮辱他人是不对的，难道敌人不是他人吗？你怎么又说’对’了呢？” 欧氏不甘示弱，解辩说：“那是因为对象不同、刚才我说的是对付友人，现在说的是对付敌人。” 苏格拉底便继续间道：“假如有一名将军，见其部下士气低落，便欺骗他们．说是救兵即将来到，从而鼓舞了部属的斗志、使斗争取得胜利、这样做对吗？” 欧：“对。” 苏又问：“孩子生了病却不肯吃药，父亲就欺骗孩子，说药是甜的。结果孩子吃了药治好了病，这做法可对？” 欧：“对！” 苏格拉底又争辩起来：“士兵和孩子都是自己人，你刚才说，不对的事情只能对敌，怎么又可对自己人呢？岂非自相矛盾？” 欧西德无法回答了。 我们可以看到, 欧西德已经输了, 他无法自圆其说 这启示我们. 回答问题太过绝对, 会让自己很被动 欧西德就犯了 绝对化谬误 的逻辑谬误, 没有具体问题具体分析, 结果被对方抓住了把柄, 最终输了辩论 世界上的所有事情都是有两面或多面性的, 需要具体问题具体分析, 绝对不能一概而论 在不同的现象, 不同的条件下, 针对某个问题或事物, 有不同的结论是正确的, 虽然是不同的结论, 但是他们相对于各自所处的事件/地点/条件下是正确的 在生活中, 我们要拥有辩证的思维, 对待不同的事物, 不但要具体分析, 还要辩证分析, 就算是真理也不一定放之四海而皆准 二难诡辩术 普罗塔哥拉悖论_百度百科 (baidu.com) 在这场辩论中, 双方都使用了 二难诡辩术 二难诡辩术 指的是辩论过程中, 只列出两种可能性, 此外别无选择, 迫使论敌从中做出选择. 无论对方选择哪一种可能性, 都对他不理. 这就迫使敌人进入进退两难的境地. 从而落入自己的控制之中. 二难诡辩术的两种可能性, 全部都是虚假的, 前后没有必然的联系, 这个假设的设置, 都是诡辩者出于自己的利益出发的. 目的是让敌人陷入进退两难的境地. 辩论的双方, 他们的立论都是错误的, 因为他们都违背了 “同一律” 原则, 同时概念和判断混乱, 从而导致是非不分, 所以就是诡辩. 关于上面的案例, 对于 欧提勒士 来说 如果我打赢了这场官司, 按照法院判决, 我不应该支付另一半学费 如果我输了这场官司, 按照合同规定, 我不应该支付另一半学费 对于 普罗塔哥拉 来说 如果欧提勒士打赢了, 按照合同, 他应该支付我另一半学费 如果欧提乐士打输了, 按照判决, 他应该支付我另一半学费 但是对于 欧提勒士 来说, 他的前提是不真实的, 推导不出结论, 因为这个官司的胜诉与败诉的区别在于给不给支付另一半学费. 如果他输掉了官司, 就必须需要支付另一半学费, 不然的话, 败诉的\"着力点\"在哪? 对于 普罗塔哥拉 来说, 它的前提也是不真实的, 因为前件与后件不存在必然的联系, 欧提勒士打赢了官司, 与支付另一半学费没有必然的联系, 因为合同规定欧提勒士第一次出庭打赢官司, 指的是他以律师的身份, 而这次是以被告的身份 这双方的二难推理, 采取的是不同的标准: 一个是法院判决, 一个是合同规定. 两个标准各有利弊, 他们都从为自己有利的标准为自己诡辩, 所以才会得出针锋相对的结论. 如果他们都使用同一个标准, 那案子就不复杂了. 破解这种诡辩可以采用三种角度 指出对方的假设前提是虚拟的, 不现实的 不正面回答对方的问题 以其人之道, 还其人之身 简化因果关系 导致大量人员死亡的原因是地震 大雪导致了铁路交通的瘫痪 就比如论点1, 你可以说直接原因或者最主要的原因是地震, 但是忽略了其他原因, 比如说房子的牢固性等等 在对某件事情进行解释时, 强调许多因素的某一个或多个因素, 就犯了过度简化因果的谬误 故意曲解 明明知道对方的意思, 却故意曲解成另一个意思, 造成概念或话题转移, 以便达成自己的目的, 这就是故意曲解 故意曲解是一种诡辩技巧, 把对自己不利的话语转成对自己有利的意思. 但有时候, 面对自己无法回答, 不能回答的问题, 也可以使用故意曲解的方式来回应, 这样可以缓和气氛 命名谬误 他为什么脸色不好? 因为他心情不好 这一问一答, 表面上看起来是在沟通, 实际上什么实际性的内容也没有说, 脸色不好与心情不好本来就是同一个意思, 通过贴标签或者命名的方式来描述发生的事实, 以掩盖说话者无知的情况, 被称为命名谬误 命名谬误很容易让人产生错觉, 认为说话者知道原因, 实际上, 说话者只不过是换个说话重复问题 同语重复 小明是小明爸爸的儿子 与命名谬误差不多, 这种属于在下定项中直接使用了被定义的概念, 互相套娃, 等于没说, 而且无法证明什么 一厢情愿 快过节了, 超市的商品肯定会有大的折扣 这句话是绝对正确的吗? 不一定 逻辑学上的一厢情愿, 是一种常见的谬误. 指的是人总是认为事物和人总是按照自己的想法来运行, 相信自己愿意相信的事情, 相信让自己快乐的事情. 这样只会让自己逃避现实, 回避真相, 对成长没有任何好处 区群谬误 男同胞都喜欢足球 仅仅基于群体的统计数据, 就对其下属的个体性质得出结论, 区群谬误假设了群体中的所有个体都拥有群体的性质, 是以偏概全 直觉思维 他肯定有什么事情瞒着我, 我的直觉一向很准 对某件事情没有经过分析, 仅仅根据直觉就下定论. 从逻辑上来讲, 直觉是无法作为论据的, 因为他没有可信度和说服力 只有经过证明的直觉, 才能作为论据 预期理由 这辆车马上要涨价了, 现在买最划算 这里将没有发生的事情拿来作为论据, 这就是预期理由的谬误 指在证明或反驳一个观点时, 把真实性有待验证的判断作为论据, 不具有可信度和说服力 巧合谬误 萧敬腾真的是雨神吗? 这句话只是调侃, 如果是当成真的, 就犯了巧合谬误 巧合与偶然不等于必然, 要找出结论与现象之间的必然性, 还是要深入的研究背后的原因 因果倒置 给懒惰的人发两头牛, 他们就勤奋了 这就是因果倒置的谬误, 并不是给懒惰的人发两头牛就勤奋了, 而是勤奋了会拥有自己的牛 回归谬误 A考试, 第一次考了100分, 第二次考了90分, 被骂之后又考了100, 所以骂会让人进步 这就是回归谬误, 从统计学上看, 事件发生的概率都是围绕一个均值来回波动的, 如果忽视了这个特点, 就会得出错误的结论 这里的A, 考试的分数与被不被骂没有必要的联系, A的水平就是90-100之间, 来回波动是正常的, 因为挨骂和得分就得出来骂会让人加分的结论简直离谱 推不出来 为什么把孩子扔进水里? 他的父亲擅长游泳 这两者之间并没有必然的联系, 由父亲会游泳, 就推倒出孩子也会实在是太牵强 这就是推不出来的谬误","link":"/2021/09/04/introduction_logic(45-66)/"},{"title":"跳出循环的几种方式","text":"比如这样的需求, 遍历一个 切片, 切片内容是切片1, 需求是判断切片1中某个是否有相应数据, 有就返回 我们需要考虑的是在写两层遍历时如何在获取结果后结束这两层遍历 变量法 设置一个变量, 在外层监听该变量, 获取到结果后修改该变量 123456789101112131415func main() { t := [][]int{{1, 2, 3, 4, 5}, {5, 6, 7, 8, 9}} s := false for _, v := range t { for _, v1 := range v { if v1 == 5 { s = true // 判断成立修改标量退出二层循环 break } } if s { // 检测标量结果，为true代表命中 break } }} 缺点很明显, 如果套更多层需要在每个层都写一个判断标量的逻辑一层层退出 goto 1234567891011121314func main() { t := [][]int{{1, 2, 3, 4, 5}, {5, 6, 7, 8, 9}} for _, v := range t { for _, v1 := range v { if v1 == 5 { goto Loop // 跳转到注册名为Loop的标记处，中间的代码直接跳过 } } } fmt.Println(\"nil\") return // 此处return防止继续执行loop的代码Loop: // Loop标记处， Loop只是一个标记，正常顺序执行也会执行Loop的代码,,一般叫Loop,可以自定义,与上面一致即可 fmt.Println(\"success\")} 此方法不止适用于循环,实际上他可以贴在任意地方,比如 1234567func main() { fmt.Println(1) goto Loop fmt.Println(2)Loop: fmt.Println(3)} 上面的 2 永远不会打印 这种方法的问题是会破坏正常的代码结构, 一个项目的代码必定是很多的, 有很多逻辑, 使用goto会破坏原有的代码结构, 大大降低了可读性和可维护性, 因此请尽可能的避免使用 goto break Label 给某一层循环设置一个Label,指定跳过某一个Label 12345678910111213141516func main() { t := [][]int{{1, 2, 3, 4, 5}, {5, 6, 7, 8, 9}} s := falseLoop: // 标记该循环为Loop,一般叫Loop,可以自定义,与下面一致即可 for _, v := range t { for _, v1 := range v { if v1 == 5 { s = true break Loop // 跳出Loop标记的循环 } } } if s { fmt.Println(\"success\") }} 相比于 goto, break Label 只能在循环中使用, Loop只能注册到循环中, goto是跳转到某行执行, break是跳出Loop标记的循环,相对来说限制大一些, 没有那么随意, 而相比于 方法一,则无需写多层判断, 需要注意的是, break Label 的 Label 不一定是顶层, 可以在任意一层 123456789101112131415161718func main() { t := [][][]int{{{1, 2, 3, 4, 5}}, {{5, 6, 7, 8, 9}}} s := false for _, v := range t { Loop: // 标记该循环为Loop for _, v1 := range v { for _, v2 := range v1 { if v2 == 5 { s = true break Loop // 跳出Loop标记的循环 } } } } if s { fmt.Println(\"success\") }} 单独写一个函数 这个不多说, 因为 return 直接退出函数了 1234567891011121314151617func t1(t [][][]int) bool { for _, v := range t { for _, v1 := range v { for _, v2 := range v1 { if v2 == 5 { return true } } } } return false}func main() { t := [][][]int{{{1, 2, 3, 4, 5}}, {{5, 6, 7, 8, 9}}} fmt.Println(t1(t))} 总结 条条大路通罗马, 其实哪种都可以, 但是我还是推荐使用函数的形式, 因为goto和lable或多或少都会降低可读性. 何况, 如果真的出现多个循环在一个函数, 应该思考是不是设计的有问题或者实现的有问题.","link":"/2021/09/04/jump_out_of_loop/"},{"title":"LeetCode解题(1-10)","text":"1.两数之和(简单) https://leetcode-cn.com/problems/two-sum/ 题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解答 1234567891011121314151617181920212223package main/*URL: https://leetcode-cn.com/problems/two-sum/解题思路: 维护一个map,key为nums的值,value为该值的索引, 遍历一遍nums, 假设每个值为b, 算出a+b中a的值, 判断map存不存在, 如存在则获取到map中a的value(索引), 不存在则将b的值与索引加入map中, 有可能都不匹配,注意在遍历结束后返回一个空切片 */func twoSum(nums []int, target int) []int { sumMap := map[int]int{} for index, value := range nums{ mapValue, ok := sumMap[target-value] if !ok{ sumMap[value] = index continue } return []int{mapValue, index} } return []int{}} 2.两数相加(中等) https://leetcode-cn.com/problems/add-two-numbers/ 题目 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解答 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package main/*URL: https://leetcode-cn.com/problems/add-two-numbers/解题思路: 新建函数 addNodeaddNode 多接收一个参数为偏移值读取两个结构体的 val，相加，大于10则pre为1使用递归来层层读取调用 addNode*/type ListNode struct { Val int Next *ListNode}func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { return addNode(l1, l2, 0)}func addNode(l1 *ListNode, l2 *ListNode, pre int) *ListNode { // 处理链表 if l1 == nil &amp;&amp; l2 == nil{ if pre == 0{ return nil }else { return &amp;ListNode{ Val: pre, Next: nil, } } } if l1 == nil{ l1 = &amp;ListNode{ Val: 0, Next: nil, } } if l2 == nil{ l2= &amp;ListNode{ Val: 0, Next: nil, } } count := l1.Val + l2.Val + pre // 计算本次数据结果,pre为上一次计算满10进1 p := 0 if count &gt;= 10{ p = 1 count = count - 10 } node := &amp;ListNode{ Val: count, Next: addNode(l1.Next, l2.Next, p), } return node} 3.无重复字符的最长子串(中等) https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 123输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 1234输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 解答 12345678910111213141516171819202122232425262728package main/*URL: https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/滑块模式，维护一个map，存放当前滑块内的内容，滑块向前滑动，新的字符直接加入滑块老的字符先判断是否在滑块内，在则滑块起始为老的字符出现位置+1每次获取一下长度，如果大于已保存的最大长度则最大长度+1*/func lengthOfLongestSubstring(s string) int { var ins = make(map[int32]int, len(s)) // 建立存放已出现字符的map，key为该字符，value为下标 max := 0 // 最大值 startIndex := 0 // 起点下标 for index, value := range s { // 遍历字符串 oldIndex, ok := ins[value] // 判断字符是否已经出现过 ins[value] = index // 如出现过将map字符下标替换成新的，未出现过新增 if ok &amp;&amp; startIndex &lt;= oldIndex { // 如果之前出现过且老的下标在起点下标之内，代表之前虽然有出现过且在·滑动窗口内 startIndex = oldIndex + 1 // 将起点下标向前偏移一位，去除重复字符 } if (index - startIndex + 1) &gt; max { // 判断现在的长度是否超过记录的最大长度 max = index - startIndex + 1 // 更新最大长度 } } return max} 4. 寻找两个正序数组的中位数(困难) https://leetcode-cn.com/problems/median-of-two-sorted-arrays/ 题目 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 解答 pass 5.最长回文子串(中等) https://leetcode-cn.com/problems/longest-palindromic-substring/ 题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000 示例 123输入: \"babad\"输出: \"bab\"注意: \"aba\" 也是一个有效答案。 12输入: \"cbbd\"输出: \"bb\" 解答 1234567891011121314151617181920212223242526272829303132333435363738394041package main/*URL: https://leetcode-cn.com/problems/longest-palindromic-substring/中心扩散法: 遍历目标字符串, 以当前字符为中心, 向两边扩散, 如一致则继续扩散, 比较找出最长的, 此为奇数扩散针对类似于 baa 这种情况, 连续两个相同的字符串, 在遍历时考虑将当前字符与下一个字符当作扩散的中心, 此为偶数扩散*/func longestPalindrome(s string) string { maxStr := \"\" // 长度为0或1直接返回 if len(s) &lt;= 1 { return s } // 循环 for i := range s { t := verify(s, i, i) if len(t) &gt; len(maxStr) { maxStr = t } t = verify(s, i, i+1) if len(t) &gt; len(maxStr) { maxStr = t } } return maxStr}func verify(s string, l int, r int) string { for { if l &gt;= 0 &amp;&amp; r &lt; len(s) &amp;&amp; s[l] == s[r] { l-- r++ } else { // 如果匹配不上了, 返回上一个匹配成功的回文 // list包头不包尾, 所以 l+1 而 r 不包 return s[l+1 : r] } }} 6.Z字形变换(中等) https://leetcode-cn.com/problems/zigzag-conversion/ 题目 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 12输入: s = \"LEETCODEISHIRING\", numRows = 3输出: \"LCIRETOESIIGEDHN\" 123456789输入: s = \"LEETCODEISHIRING\", numRows = 4输出: \"LDREOEIIECIHNTSG\"解释:L D RE O E I IE C I H NT S G 解答 123456789101112131415161718192021222324252627282930313233343536package main/*URL: https://leetcode-cn.com/problems/zigzag-conversion/解题思路: 我们把 Z 结构的中间的空格全部去掉, 会发现实际上是一个二维数组,每独取一个新的字符, 将其存储进当前数组, 再读取下一个字符存储进下一行数组,当触碰到行底时, 下一个字符存储进上一行直到行初再正序存储*/func convert(s string, numRows int) string { if numRows == 1 { return s } var resList = make([][]string, numRows) res := \"\" rowIndex := 0 flag := 1 for _, v := range s { resList[rowIndex] = append(resList[rowIndex], string(v)) switch rowIndex { case numRows - 1: flag = -1 case 0: flag = 1 } rowIndex = rowIndex + flag } for _, v := range resList { for _, k := range v { res = res + k } } return res} 7.整数反转(简单) https://leetcode-cn.com/problems/reverse-integer/ 题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 示例 12输入: 123输出: 321 12输入: -123输出: -321 12输入: -123输出: -321 解答 1234567891011121314151617181920212223242526package mainimport \"math\"/*URL: https://leetcode-cn.com/problems/reverse-integer/首先我们可以使用 math 包下的变量来判断是否超限反转方面使用求余+取模计算即可*/func reverse(x int) int { if x &lt; math.MinInt32 || x &gt; math.MaxInt32 { return 0 } res := 0 for x != 0 { temp := x % 10 x = x / 10 res = res*10 + temp if res &lt; math.MinInt32 || res &gt; math.MaxInt32 { return 0 } } return res} 8.字符串转换整数 (atoi)(中等) https://leetcode-cn.com/problems/string-to-integer-atoi/ 题目 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 本题中的空白字符只包括空格字符 ’ ’ 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 12输入: \"42\"输出: 42 1234输入: \" -42\"输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 123输入: \"4193 with words\"输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 1234输入: \"words and 987\"输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 1234输入: \"-91283472332\"输出: -2147483648解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN 。 解答 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"fmt\" \"math\" \"strconv\")/*URL: https://leetcode-cn.com/problems/string-to-integer-atoi/解题思路: 普通的逻辑处理*/func myAtoi(str string) int { si := \"\" sum := 1 stop := false for _, v := range str{ vs := fmt.Sprintf(\"%c\", v) if vs == \" \" &amp;&amp; stop == false &amp;&amp; si == \"\" { // 捕捉最开始是空格的情况 continue } if vs == \"-\" &amp;&amp; stop == false{ // 捕捉以-开头 sum = -1 stop = true continue } if vs == \"+\" &amp;&amp; stop == false{ // 捕捉以+开头 sum = 1 stop = true continue } if _, err := strconv.Atoi(vs); err == nil{ // 捕捉数字 stop = true si+=vs continue } break } res, _ := strconv.Atoi(si) if res &lt; math.MinInt32 || res &gt; math.MaxInt32 { if sum == 1{ return math.MaxInt32 } return math.MinInt32 } return res * sum} 9. 回文数(简单) https://leetcode-cn.com/problems/palindrome-number/ 题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 12输入: 121输出: true 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶 你能不将整数转为字符串来解决这个问题吗？ 解答 12345678910111213141516171819202122package mainimport ( \"strconv\")/*URL: https://leetcode-cn.com/problems/palindrome-number/解题思路: 转换成字符串，遍历一半即可，对于基数长度，最中间的数字不必要比较*/func isPalindrome(x int) bool { s := strconv.Itoa(x) l := len(s) for i := 0; i&lt;= l/2-1; i++{ if s[i] != s[l-i-1]{ return false } } return true}","link":"/2021/09/04/leet_code(1-10)/"},{"title":"保护你的网站用户密码","text":"最近对密码的加密比较感兴趣, 但是对于比较全面的文章, 只找到了这一章, 英文版, 我稍微翻译了一下, 这里记录一下 原文: Salted Password Hashing - Doing it Right 序言 如果你是一个web开发人员，你可能不得不建立一个用户帐户系统。用户帐户系统最重要的方面是如何保护用户密码。用户帐户数据库经常被黑客入侵，所以如果你的网站被入侵，你绝对必须采取措施保护你用户的密码。保护密码的最好方法是使用salt密码散列(salted password hashing)。本文将解释为什么它是这样做的。 关于如何正确地进行密码散列有很多相互矛盾的想法和误解，可能是因为网络上有大量的错误信息。密码散列其实是很简单的事情之一，但是很多人都会犯错。通过这一篇文章，我希望不仅解释正确的方法，而且解释为什么应该这样做。 重要警告: 如果您正在考虑编写自己的密码哈希代码, 请立即停止, 这太容易搞砸了。不，你在大学上的密码学课程并不能使你免除这个警告。这适用于每一个人, 不要编写自己的 CRYPTO(DO NOT WRITE YOUR OWN CRYPTO!), 存储密码的问题已经得到解决, 许多语言都有现成的包和模块供你使用, 他将比你自己实现的更加完美和稳定 需要说明的是,本篇文章并不是要指导你如何编写自己的存储系统，而是要解释为什么密码应该以某种方式存储。 什么是密码散列 123hash(\"hello\") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824hash(\"hbllo\") = 58756879c05c68dfac9866712fad6a93f8146f337a69afe7dd238f3364946366hash(\"waltz\") = c0e81794384491161f1777c232bc6bd9ec38f616560b120fda8e90f383853542 哈希算法是单向函数。他们把任何数量的数据转换成一个固定长度的“指纹”，不能逆转。它们还有一个特性，即如果输入发生一点点的变化，那么产生的散列就完全不同了（参见上面的示例）。这对于保护密码非常有用，因为我们希望以一种即使密码文件本身被泄露也能保护密码的形式存储密码，但同时，我们需要能够验证用户的密码是否正确。 在基于哈希的帐户系统中，帐户注册和身份验证的一般工作流程如下： 用户创建一个帐户 他们的密码被散列并存储在数据库中。任何时候都不会有写入硬盘的纯文本(未加密)密码 当用户尝试登录时，将根据其真实密码(从数据库中检索)的哈希值与他们输入的密码的哈希值进行比对 如果散列匹配，用户将被授予访问权限。如果不匹配，用户将被告知输入了无效的登录凭证 当用户每次登录时, 重复步骤3和步骤4 在第4步中，千万不要告诉用户是不是用户名或密码错了。始终显示“无效用户名或密码”这样的通用消息。这可防止攻击者在不知道其密码的情况下枚举有效用户名。 应该注意的是，用于保护密码的哈希函数与您在数据结构课程中看到的哈希函数不同。用于实现哈希表等数据结构的哈希函数被设计为快速的，而不是安全的。只能使用加密哈希函数来实现密码哈希。像SHA256、SHA512、RipeMD和WHIRLPOOL这样的散列函数都是加密散列函数。 很容易认为你所要做的就是通过一个加密散列函数来运行密码，你的用户的密码将是安全的。这与事实相去甚远。有很多方法可以很快地从普通散列中恢复密码。有几种易于实现的技术使这些“攻击”的效果大大降低。为了激发对这些技术的需求，考虑一下这个网站。在首页上，您可以提交一个要破解的哈希列表，并在不到一秒钟的时间内收到结果。显然，简单地对密码进行哈希运算并不能满足我们对安全性的需求。 如何破解哈希 字典和暴力攻击 破解散列的最简单方法是尝试猜测密码，对每个猜测进行散列，并检查猜测的散列是否等于被破解的散列。如果哈希值相等，则猜测到了密码。猜测密码最常见的两种方法是字典攻击和暴力攻击。 字典攻击使用包含单词、短语、常用密码和其他可能用作密码的字符串的文件。对文件中的每个单词进行哈希运算，并将其哈希值与密码哈希值进行比较。如果他们匹配，这个词就是密码。这些字典文件是通过从大量文本中提取单词，甚至从真实的密码数据库中提取单词来构建的。进一步的处理通常应用于字典文件，例如用“leet speak”等价词替换单词（“hello”变成“h3110”），以使它们更有效。 暴力攻击会尝试所有可能的字符组合，长度不超过给定的长度。这些攻击在计算上非常昂贵，而且通常在每个处理器时间破解哈希方面效率最低，但它们最终总会找到密码。密码应该足够长，搜索所有可能的字符串以找到它将花费太长的时间是值得的。 我们无法防止字典攻击或暴力攻击。它们可以变得不那么有效，但是没有一种方法可以完全阻止它们。如果密码散列系统是安全的，破解散列的唯一方法就是对每个散列运行字典或暴力攻击, 但是对于破解者来说要花费很大的代价和很长的时候才能破解其中一个密码. 查找表 查找表是一种非常有效的方法，可以快速地破解许多相同类型的哈希。其基本思想是在密码字典中预先计算密码的哈希值，并将其和相应的密码存储在查找表数据结构(数据库)中。使用者提交需要破解的哈希, 由数据库去查找有没有对应的密码, 一个好的查找表实现可以每秒处理数百个哈希查找，即使它们包含数十亿个哈希。 如果您想更好地了解查找表的速度，请尝试使用CrackStation的免费哈希破解程序破解以下sha256哈希(需要FQ) 123456c11083b4b0a7743af748c85d343dfee9fbb8b2576c05f3a7f0d632b0926aadfc11083b4b0a7743af748c85d343dfe9fbb8b2576c05f3a7f0d632b0926aadfc08eac03b80adc33dc7d8fbe44b7c7b05d3a2c511166bdb43fcb710b03ba919e7e4ba5cbd251c98e6cd1c23f126a3b81d8d8328abc95387229850952b3ef9f9044ba5cbd251c98e6cd1c23f126a3b81d8d8328abc95387229850952b3ef9f9045206b8b8a996cf5320cb12ca91c7b790fba9f030408efe83ebb83548dc3007bd 反向查找表 此攻击允许攻击者对多个哈希同时应用字典或暴力攻击，而无需预先计算查找表。 首先，攻击者创建一个查找表，将每个密码哈希值从受损用户帐户数据库映射到拥有该哈希值的用户列表。然后，攻击者对每个密码猜测进行哈希运算，并使用查找表获取其密码是攻击者猜测的用户列表。这种攻击特别有效，因为许多用户都有相同的密码。 这段比较晦涩, 我使用大白话来解释一下, 其实是攻击者注册一个账号到被攻击网站, 然后进入该网站的密码数据库, 查找到刚才注册的帐号的加密后的密码, 再通过数据库查找有没有和该加密密码一致的加密密码, 一致则代表某个用户使用了和你相同的密码, 即可达到破解的效果 彩虹表 彩虹表是一种时间记忆折衷技术。它们类似于查寻表，只是它们牺牲了哈希破解的速度，以使查寻表更小。因为它们更小，所以可以将更多散列的解决方案存储在相同的空间中，从而使它们更有效。彩虹表，可以快速破解任何8个字符生成的md5。 彩虹表 加盐(salt) 1234hash(\"hello\") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824hash(\"hello\" + \"QxLUF1bgIAdeQX\") = 9e209040c863f84a31e719795b2577523954739fe5ed3b58a75cff2127075ed1hash(\"hello\" + \"bv5PehSMfV11Cd\") = d1d3ec2e6f20fd420d50e2642992841d8338a314b8ea157c9e18477aaef226abhash(\"hello\" + \"YYLmfY6IehjZMQ\") = a49670c3c18b9e079b9cfaf51634f563dc8ae3070db2c4a8544305df1b60f007 查找表和彩虹表起作用，因为每个密码的散列方式完全相同。如果两个用户有相同的密码，他们将有相同的密码哈希。我们可以通过随机化每个散列来防止这些攻击，这样当相同的密码被散列两次时，散列就不一样了。 我们可以通过在散列之前在密码中添加或预先添加一个随机字符串（称为 salt ）来随机散列。如上面的示例所示，每次都会将相同的密码散列成完全不同的字符串。为了检查密码是否正确，我们需要这个密码加密时的salt，因此它通常与散列一起存储在用户帐户数据库中，或者作为散列字符串本身的一部分。 Salt不需要加密。因为salt是随机的, 随机化了哈希值，查找表、反向查找表和彩虹表就变得无效了。攻击者不会预先知道salt是什么，因此无法预先计算查找表或彩虹表。如果每个用户的密码都用不同的salt散列，那么反向查找表攻击也不会起作用。 加盐的错误使用 重复使用一个盐 一个常见的错误是在每个散列中使用相同的盐。salt要么硬编码到程序中，要么随机生成一次。这是无效的，因为如果两个用户有相同的密码，他们仍然会有相同的哈希。攻击者仍然可以使用反向查找表攻击同时对每个哈希运行字典攻击。他们只需对每个密码猜测应用salt，然后再对其进行哈希运算。如果将salt硬编码到一个流行的产品中，那么可以为该salt构建查找表和彩虹表，以便更容易地破解产品生成的哈希。 每次用户创建帐户或更改密码时，都必须生成一个新的随机salt。 短盐 如果盐太短，攻击者可以为每个可能的盐建立一个查找表。例如，如果salt只有三个ASCII字符，则只有95x95x95=857375个可能的salt。这看起来可能很多，但是如果每个查找表只包含1MB最常用的密码，那么它们总共只有837GB，考虑到现在1000 GB的硬盘售价低于100美元，这并不算多。 出于同样的原因，用户名不应该用作salt。用户名对于单个服务可能是唯一的，但是它们是可预测的，并且经常被其他服务上的帐户重用。攻击者可以为常见用户名构建查找表，并使用它们来破解用户名作为salt的哈希。 为了使攻击者无法为每个可能的salt创建一个查找表，salt必须很长。一个好的经验法则是使用与哈希函数输出大小相同的salt。例如，SHA256的输出是256位（32字节），因此salt应该至少是32个随机字节。 散列算法的错误使用 本节介绍另一个常见的密码散列误解：散列算法的古怪组合。人们很容易忘乎所以地尝试组合不同的散列函数，希望结果更安全。但实际上，这样做并没有什么好处。它只会造成互操作性问题，有时甚至会降低哈希的安全性。永远不要试图发明你自己的密码，总是使用一个由专家设计的标准。有些人会认为使用多个散列函数会使计算散列的过程变慢，所以破解会变慢，但是有一个更好的方法可以让破解过程变慢，我们稍后会看到。 下面是一些我在互联网论坛上看到的糟糕的古怪哈希函数的例子 md5(sha1(password)) md5(md5(salt) + md5(password)) sha1(sha1(password)) sha1(str_rot13(password + salt)) md5(sha1(md5(md5(password) + sha1(password)) + md5(password))) 不要使用这些。 注：本节已被证明是有争议的。我收到过很多邮件，认为古怪的散列函数是件好事，因为如果攻击者不知道使用的是哪一个散列函数就更好了，攻击者为古怪的散列函数预先计算彩虹表的可能性更小，计算散列函数的时间也更长。 攻击者在不知道算法的情况下无法攻击哈希，但请注意Kerckhoffs的原理，即攻击者通常可以访问源代码（尤其是免费或开源软件），并且给定目标系统中的一些密码哈希对，对算法进行反向工程并不困难。计算古怪的散列函数确实需要更长的时间，但只需要一个小的常数因子。最好使用一个设计得非常难以并行化的迭代算法（这些将在下面讨论）。而且，适当地对散列进行盐分可以解决彩虹表问题。 如果你真的想使用一个标准化的“古怪”散列函数，比如HMAC，那就没关系了。但是，如果这样做是为了降低哈希计算的速度，请先阅读下面关于密钥扩展(key stretching)的部分。 将这些小的好处与意外实现完全不安全的散列函数的风险以及古怪的散列所产生的互操作性问题进行比较。显然，最好使用标准的、经过良好测试的算法。 散列碰撞 因为散列函数将任意数量的数据映射到固定长度的字符串，所以必须有一些输入散列到相同的字符串中。加密散列函数的设计使这些冲突难以找到。有时，密码学家会发现对散列函数的“攻击”，从而更容易找到冲突。最近的一个例子是MD5散列函数，实际上已经找到了它的冲突。 就是有可能字符串 abc 和 bbc 生成的散列是相同的 冲突攻击是一种迹象，表明除用户密码以外的字符串更有可能具有相同的哈希值。然而，即使是在MD5这样的弱哈希函数中发现冲突，也需要大量专用的计算能力，因此在实践中，这些冲突“偶然”发生的可能性非常小。使用MD5和salt散列的密码在所有实际用途中都是安全的，就像使用SHA256和salt散列一样。不过，如果可能的话，最好使用更安全的散列函数，如SHA256、SHA512、RipeMD或WHIRLPOOL。 如何正确的散列 本节详细描述了密码应该如何散列。第一小节涵盖了基本的一切，这是绝对必要的。下面的小节将解释如何扩充基础知识，使哈希更难破解。 用盐做散列 警告：不要只阅读本节。您绝对必须实现下一节中的内容：“使密码破解更困难：慢哈希函数” 我们已经看到恶意黑客如何使用查找表和彩虹表快速破解普通哈希。我们已经了解到使用salt随机散列是问题的解决方案。但是如何生成salt，以及如何将其应用于密码？ Salt应该使用加密安全的伪随机数生成器（CSPRNG）生成。csprng与普通的伪随机数生成器非常不同，比如“C”语言的rand（）函数。顾名思义，csprng被设计成密码安全的，这意味着它们提供了高度的随机性，并且完全不可预测。我们不希望盐是可预测的，所以我们必须使用CSPRNG。每个语言都有对应的函数供你使用, 例如 python 的 os.urandom 等 每个用户每个密码的salt必须是唯一的。每次用户创建帐户或更改密码时，都应该使用新的随机salt对密码进行哈希运算。不要重复使用盐。盐也应该足够长, 以保证有足够多的盐用于哈希加密。根据经验，使salt至少与哈希函数的输出一样长。salt应该与hash一起存储在用户账户表中。 保存密码 使用 CSPRNG 生成足够长的随机盐 将salt预先混入密码中，并使用标准密码哈希函数（如Argon2、bcrypt、scrypt或PBKDF2）对其进行哈希运算。 在用户的数据库记录中保存salt和hash。 校验密码 从数据库中检索用户的salt和hash。 将salt混入用户提交的密码，并使用相同的哈希函数对其进行哈希运算。 将给定密码的哈希值与数据库中的哈希值进行比较。如果匹配，则密码正确。否则，密码不正确。 在 Web 应用程序中，始终在服务器上进行散列 如果您正在编写一个web应用程序，您可能想知道在哪里散列。密码应该在用户浏览器中用JavaScript散列，还是应该发送将明文密码发送到服务器再进行散列呢? 即使用JavaScript散列用户密码，也必须在服务器上散列。考虑一个网站，它在用户浏览器中散列用户密码，而不在服务器上散列。若要验证用户身份，此网站将接受来自浏览器的哈希值，并检查该哈希值是否与数据库中的哈希值完全匹配。这似乎比在服务器上散列更安全，因为用户的密码从未发送到服务器，但事实并非如此。 问题是客户端的哈希值逻辑上变成了用户的密码。用户需要做的只是告诉服务器他们密码的散列。如果一个坏人得到了一个用户的散列，他们可以用它来验证服务器，而不知道用户的密码！因此，如果坏人不知何故从这个假想的网站窃取了哈希数据库，他们就可以立即访问每个人的帐户，而不必猜测任何密码。 这并不是说你不应该在浏览器中散列，但如果你这样做了，你绝对也必须在服务器上散列。在浏览器中进行散列当然是一个好主意，但在实现时请考虑以下几点： 客户端密码哈希不能替代HTTPS（SSL/TLS）。如果浏览器和服务器之间的连接不安全，中间人可以在下载JavaScript代码时修改它，以删除散列功能并获取用户的密码。 有些web浏览器不支持JavaScript，有些用户在浏览器中禁用JavaScript。因此，为了获得最大的兼容性，你的应用程序应该检测浏览器是否支持JavaScript，如果不支持，就在服务器上模拟客户端散列。 你也需要在客户端散列的过程中中加盐。显而易见的解决方案是让客户端脚本向服务器请求用户的salt。不要这样做，因为它让攻击者在不知道密码的情况下检查用户名是否有效。由于您也在服务器上进行散列和加盐（使用一个合格的salt），因此可以使用用户名（或电子邮件）与特定于站点的字符串（例如域名）连接作为客户端salt(这个客户端salt并不是最终的salt, 客户端生成的加密密码也不是最终的密码, 只是为了将明文密码加密而防止中间人攻击, 并且,当黑客拿到了客户端加密后的密码, 他也能通过请求登录接口模拟客户端已经加密密码然后登录的情况, 此时则与客户端不加密的效果一致)。 使得密码破解更难: 缓慢的散列函数 Salt确保攻击者不能使用专门的攻击，如查找表和彩虹表来快速破解大量散列集合，但它不能阻止攻击者单独对每个散列运行字典或暴力攻击。高端图形卡（GPU）和定制硬件每秒可以计算数十亿个哈希，因此这些攻击仍然非常有效。为了降低这些攻击的效果，我们可以使用一种称为密钥扩展(key stretching)的技术。 其想法是使哈希函数非常慢，因此即使使用快速的GPU或定制硬件，字典和暴力攻击也很慢，从而让攻击者放弃或者失败。目标是使散列函数足够慢以阻止攻击，但仍然足够快以避免给用户造成明显的延迟。 密钥扩展是使用一种特殊类型的CPU密集型哈希函数实现的。不要试图创造你自己的加密函数, 简单地对密码的散列进行迭代散列是不够的，因为它可以在硬件中并行化，并且可以像普通散列一样快速执行。使用标准算法，如PBKDF2或bcrypt。 这些算法以安全因子或迭代计数作为参数。此值确定哈希函数的速度。对于桌面软件或智能手机应用程序，选择此参数的最佳方法是在设备上运行一个简短的基准测试，以找到计算哈希值的耗时约半秒的参数。这样，您的程序就可以在不影响用户体验的情况下尽可能安全。 如果您在web应用程序中使用密钥扩展哈希，请注意您将需要额外的计算资源来处理大量身份验证请求，并且密钥扩展可能会使您的网站更容易受到拒绝服务（DoS）攻击。我仍然建议使用密钥扩展，但是迭代次数要少一些。您应该根据计算资源和预期的最大身份验证请求速率来设置迭代次数。通过让用户在每次登录时输入验证码，可以消除DoS威胁。系统在设计时要将迭代次数设置为可配置的，以便将来可以增加或减少迭代次数。 如果您担心计算负担，但仍希望在web应用程序中使用密钥扩展，请考虑使用JavaScript在用户浏览器中运行密钥扩展算法。Stanford Javascript Crypto Library加密库包括PBKDF2。迭代次数应该设置得足够低，这样系统就可以在移动设备等速度较慢的客户端上使用，如果用户的浏览器不支持JavaScript，那么系统应该返回到服务器端来模拟客户端计算。客户端密钥扩展并不能消除服务器端散列的需要。你必须对客户端传回来的哈希值再次进行哈希加密, 也就是说客户端生成的加密密码并不是最终的加密密码, 以此来增加安全性, 因为前端的代码是透明的, 不能将完整的算法放置在前端 不可能破解的哈希: 密钥哈希和密码哈希设备 只要攻击者可以使用哈希来检查密码猜测是否正确，他们就可以对哈希运行字典或暴力攻击。下一步是将密钥添加到哈希中，这样只有知道密钥的人才能使用哈希来验证密码。这可以通过两种方式实现。可以使用类似AES的算法对散列进行加密，或者使用类似HMAC的密钥散列算法将密钥包括在散列中。 这并不像听起来那么容易。密钥必须对攻击者保密，即使在出现漏洞的情况下也是如此。如果攻击者获得对系统的完全访问权限，则无论密钥存储在何处，他们都可以窃取密钥。密钥必须存储在外部系统中，例如专门用于密码验证的物理上独立的服务器，或者连接到服务器的特殊硬件设备，例如YubiHSM。 对于任何大规模（超过10万个用户）的服务，我强烈推荐这种方法。我认为有必要为任何托管超过100万个用户帐户使用该方法。 如果您负担不起多个专用服务器或特殊硬件设备，您仍然可以在标准web服务器上获得密钥哈希的一些好处。大多数数据库都是通过SQL注入攻击被破坏的，在大多数情况下，SQL注入攻击不允许攻击者访问本地文件系统（如果SQL server具有此功能，则禁用对本地文件系统的访问）。如果生成一个随机密钥并将其存储在无法从web访问的文件中，并将其包含到salt哈希中，那么如果使用简单的SQL注入攻击破坏数据库，哈希就不会受到攻击。不要将密钥硬编码到源代码中，而是在安装应用程序时随机生成密钥。这不如使用单独的系统进行密码的管理安全，因为如果web应用程序中存在SQL注入漏洞，攻击者可能会使用其他类型（如本地文件包含）来读取密钥文件。但是，总比什么都没有强。 请注意，密钥哈希并不能消除对盐的需要。聪明的攻击者最终会找到破解密钥的方法，因此密码哈希依然需要加盐和密钥扩展, 这是很重要的。 其他安全措施 密码哈希在发生安全漏洞时保护密码。它并不能使整个应用程序更加安全。为了防止密码散列（和其他用户数据）在第一时间被窃取，还必须做更多的工作。 即使是有经验的开发人员也必须接受安全教育，才能编写安全的应用程序。了解web应用程序漏洞的一个重要资源是openweb应用程序安全项目 OWASP 。一个很好的介绍是 OWASP十大漏洞列表。除非您了解列表中的所有漏洞，否则不要尝试编写处理敏感数据的web应用程序。雇主有责任确保所有开发人员都接受过安全应用程序开发方面的充分培训。 对您的应用程序进行第三方\"渗透测试\"是一个好主意。即使是最好的程序员也会犯错，因此让安全专家检查代码中的潜在漏洞总是有意义的。找一个值得信赖的组织（或雇佣员工）定期检查您的代码。安全审查过程应该在应用程序生命周期的早期开始，并在整个开发过程中持续进行。 同样重要的是要监测你的网站，以发现入侵行为。我建议至少雇佣一个全职工作是检测和处理安全漏洞的人。如果一个漏洞未被发现，攻击者可以通过你的网站利用恶意软件感染访问者，所以检测漏洞并及时作出反应是非常重要的。 常见问题 我应该使用什么散列算法？ 使用 精心设计并经过大量测试的密钥扩展算法比如 PBKDF2, Bcrypt, Scrypt 很好的开源项目比如 Portable PHP password hashing framework PBKDF2在各个语言的实现 crypt 的安全版本 不要使用 快速密码散列函数，如 MD5、 SHA1、 SHA256、 SHA512、 RipeMD、 WHIRLPOOL、 SHA3等 不安全版本的 crypt 任何你自己设计的算法。只能使用公共领域的技术，并且经过经验丰富的密码学家的良好测试。 当用户忘记密码时，我应该如何允许他们重置密码？ 我个人认为，现在广泛使用的所有密码重置机制都是不安全的。如果你有很高的安全要求，比如加密服务，不要让用户重置密码。 大多数网站使用向忘记密码的用户发送邮件来验证身份。为此，生成一个与帐户紧密关联的随机一次性令牌(Token)。将其包含在发送到用户电子邮件地址的密码重置链接中。当用户单击包含有效令牌的密码重置链接时，提示他们输入新密码。确保令牌与用户帐户紧密绑定，以便攻击者不能使用发送到自己电子邮件地址的令牌重置其他用户的密码。 令牌必须设置为在15分钟内或使用后过期，一旦使用过就立即作废。当用户登录（他们想起来了他们的密码）或请求一个新的重置密码时，使该用户任何现有的密码令牌过期。如果一个令牌没有过期，它可以永远被用来入侵用户的帐户。电子邮件（SMTP）是一种纯文本协议，互联网上存在截取电子邮件的恶意路由。用户的电子邮件帐户（包括重置链接）可能会在其修改密码后很长一段时间内被泄露出去。而使令牌尽快过期可以减少用户将信息暴露给攻击者的风险。 攻击者将能够修改令牌，因此不要在其中存储用户帐户信息或失效时间。它们应该是不可猜测的随机二进制数据，仅用于标识数据库表中的某条用户记录。 千万不要通过电子邮件向用户发送新密码。当用户重置密码时，请记住选择一个新的随机盐。不要重复使用他们的旧盐。 如果我的用户帐户资料库被泄漏/入侵，我应该怎么办？ 您的首要任务是确定系统是如何受到危害的，并修补攻击者用来进入的漏洞。如果你没有应对漏洞的经验，我强烈建议你聘请第三方安全公司。 可能会有人试图掩盖漏洞，希望没人注意到。然而，试图掩盖漏洞会让你变得更糟，因为你没有通知用户密码和其他个人信息可能会被泄露，这会让你的用户面临更大的风险。你必须尽快通知你的用户，即使你还没有完全明白发生了什么。在你的网站首页放一个通知，链接到一个有更详细信息的页面，如果可能的话，通过电子邮件向每个用户发送一个通知。 向你的用户解释他们的密码是如何被盐哈希保护的，即使他们被盐哈希保护，恶意黑客仍然可以对哈希运行字典和暴力攻击。恶意黑客会使用他们找到的任何密码试图登录到另一个网站上的用户帐户，希望他们在两个网站上使用相同的密码。将此风险告知您的用户，并建议他们在使用类似密码的任何网站或服务上更改密码。强制他们在下次登录时更改您服务的密码。大多数用户会尝试将自己的密码“更改”为原始密码，以快速绕过强制更改。你需要使用当前密码散列来校验新旧密码是否相同来确保他们不能这样做。 很可能，即使使用盐哈希，攻击者也能很快破解一些弱密码。为了减少攻击者使用这些密码的机会，在登录时除了当前密码之外，还应该要求通过电子邮件进行身份验证，直到用户更改了密码。请参阅前面的问题，“当用户忘记密码时，我应该如何允许用户重置密码？”有关实现电子邮件验证身份的提示。 同时告诉你的用户网站上储存了什么样的个人信息。如果你的数据库包含信用卡号码，你应该指示你的用户仔细检查他们最近和将来的账单，并注销他们的信用卡。 我的密码政策应该是什么? 我应该强制使用强密码吗？ 如果您的服务没有严格的安全要求，那么不要限制您的用户。我建议在用户键入密码时向其显示有关密码强度的信息，让他们决定密码的安全性。如果您有特殊的安全需求，请强制执行至少12个字符的长度，并且至少需要两个字母、两个数字和两个符号。 不要强迫用户每六个月更改一次以上的密码，因为这样做会造成“用户疲劳”，使用户不选择复杂的密码。相反，教育用户在感到密码被泄露时主动更改密码，并且永远不要把密码告诉任何人。如果是商业环境，鼓励员工利用带薪时间熟记和使用密码。 如果攻击者可以访问我的数据库，难道他们不能用自己的散列和登录来替换密码的散列吗？ 是的，但是如果有人可以访问你的数据库，他们可能已经可以访问你服务器上的所有内容，所以他们不需要登录到你的帐户就可以得到他们想要的。密码散列（在网站中）的目的不是保护网站不被破坏，而是在确实发生入侵时保护数据库中的密码。 通过使用两个具有不同权限的用户连接到数据库，可以防止哈希在SQL注入攻击期间被替换。一个用于“创建帐户”代码，另一个用于“登录”代码。“create account”代码操作的用户应该能够读取和写入用户表，但是“login”代码使用的用户应该只能读取。 为什么我必须使用像 HMAC 这样的特殊算法？为什么我不能把密码附加到密钥上呢？ 像 MD5、 SHA1和 SHA2这样的散列函数使用 Merkle-Damgård 结构，这使它们容易受到所谓的长度扩展攻击(length extension attack)。这意味着给定一个 哈希 h (x) ，对于任意的字符串 Y，攻击者可以计算出 h(pad(X)+Y) 的值，而无需知道 X 的值。其中， pad(X) 是哈希函数的填充函数。 这意味着，攻击者不知道密钥的情况下，仍然可以根据给定的哈希值 H(key+message) 计算出 H(pad(key+message)+extension) 。如果该哈希值用于身份认证，并依靠其中的密钥来防止攻击者篡改消息，这方法已经行不通。因为攻击者无需知道密钥也能构造出包含 message+extension 的一个有效的哈希值。 目前尚不清楚攻击者如何利用此攻击更快地破解密码哈希。但是，由于受到攻击，使用普通哈希函数进行密钥哈希加密被认为是不好的做法。一个聪明的密码学家也许有一天会想出一个聪明的方法来使用这些攻击来加快破解速度，所以还是使用HMAC 较好。 盐应该放在密码的前面还是后面？ 这不重要，但是为了互操作性，选择一个并保持风格一致即可。把盐放在密码之前似乎更为常见。 需要保证对比密码时的操作时间相同 原文这里很晦涩, 理解了一会才明白是什么意思 标题的意思是, 假设用户的密码哈希是 ‘abcde’, 当服务端接收到了用户提交的密码, 哈希后假如是 ‘adcca’ 或者是 ‘121333’ 或者是其他的, 要保证判断他们与数据库中的是否一致的代码在处理所有密码时都要有一致的处理时间 比较哈希值的函数遵循 “时间一致” 可确保攻击者无法在使用计时攻击的在线系统中提取密码的哈希值，然后离线破解密码。 检查两个字节（字符串）是否相同的标准方法是比较第一个字节、第二个字节、第三个字节，依此类推。一旦发现两个字符串的字节不一样，就知道它们是不同的，可以立即返回false。如果您在两个字符串中都没有找到任何不同的字节，那么您就知道字符串是相同的，并且可以返回一个true。这意味着比较两个字符串可能需要不同的时间，具体取决于匹配的字符串数量。 例如，对字符串“xyzabc”和“abcxyz”进行标准比较，可以立即看到第一个字符是不同的，不必检查字符串的其余部分。另一方面，当比较字符串“aaaaaaaab”和“aaaaaaaaaaz”时，比较算法在扫描到 z 时才会确认这两个字符串是不一样的, 这代表他已经检查了前面几位, 显而易见的, 一般的, 比较算法在处理这两个判断时用时是不一样的, 后面的会比前面的处理慢一些。 假设攻击者想要侵入一个在线系统，该系统将身份验证尝试的速率限制为每秒一次。另外，假设攻击者知道密码散列的所有参数（salt、散列类型等），但密码和散列后的密码除外。如果攻击者能够精确测量在线系统将真实密码的散列值与攻击者提供的密码的散列值进行比较所需的时间，那么他可以使用定时攻击提取部分散列值，并使用脱机攻击进行破解，从而绕过系统的速率限制。 首先，攻击者找到256个字符串，其哈希值以每个可能的字节开始。他将每个字符串发送到在线系统，记录系统响应所需的时间。耗时最长的字符串将是哈希的第一个字节与实际哈希的第一个字节匹配的字符串。攻击者现在知道第一个字节，可以以类似的方式继续攻击第二个字节，然后攻击第三个字节，依此类推。一旦攻击者对散列有足够的了解，他就可以使用自己的硬件来破解它，而不受系统的速率限制。 这里指的是: 我不知道你的密码, 但是密码的每一位肯定是在256个字符串中间的某一个, 假如代码不遵循 ‘操作时间相同’ 原则, 那我试这256次, 耗时最长的那一个肯定是第一位是对的, 然后我试第二个字符, 一直到我试出来密码或者我根据试出来的猜测出密码 在网络上运行定时攻击似乎是不可能的, 因为网络本身具有延迟。然而，有人 已经做到了，并且被证明是切实可行的。这就是为什么要遵循 ‘操作时间相同’ 原则 怎么编写遵循 ‘操作时间相同’ 的代码 前面的问题解释了为什么操作时间相同是必要的，这里解释了代码实际上是如何工作的。 1234567private static boolean slowEquals(byte[] a, byte[] b){ int diff = a.length ^ b.length; for(int i = 0; i &lt; a.length &amp;&amp; i &lt; b.length; i++) diff |= a[i] ^ b[i]; return diff == 0;} 代码使用 XOR“ ^”运算符来比较整数是否相等，而不是使用“ = =”运算符。原因如下。当且仅当两个整数完全相同时，XORing 的结果才为0。这是因为0 XOR 0 = 0,1 XOR 1 = 0,0 XOR 1 = 1,1 XOR 0 = 1。如果我们对两个整数中的所有位都应用这个函数，那么只有当所有位都匹配时，结果才是0。 所以, 如上面代码所示, 先判断这两个哈希值的长度, 如果其不一致, diff为 1, 但是并不直接退出, 而是在进行 for 循环, 结束后统一返回, 也就是说, 就算在代码中能够提前判断不正确也不立刻返回而是同样遍历一遍达到耗时相同的效果 我们需要使用XOR而不是“= =”运算符来比较整数的原因是“= =”通常被翻译/编译/解释为一个branch。例如，C代码“”可能编译为以下x86程序集：diff &amp;= a == b 12345678MOV EAX, [A]CMP [B], EAXJZ equalJMP doneequal:AND [VALID], 1done:AND [VALID], 0 分支使代码根据整数的相等性和CPU的内部分支预测状态以不同的时间量执行。 C代码应编译为以下内容，其执行时间不依赖于整数的相等性：diff |= a ^ b 123MOV EAX, [A]XOR EAX, [B]OR [DIFF], EAX 为什么要为你的网站设置密码加密 您的用户正在您的网站中输入密码。证明他们相信你的安全。 如果你的数据库遭到黑客攻击，而你的用户密码没有受到保护，那么恶意黑客就可以利用这些密码危害你在其他网站和服务上的用户帐户（大多数人在任何地方都使用相同的密码）。 风险不仅仅在于你的安全，还在于你的用户。 你要对你的用户的安全负责","link":"/2021/09/04/protect_user_pwd/"},{"title":"Python -c 使用","text":"Python -c python -c 命令还是有用的哈 python的 -c 可以在命令行中调用 python 代码, 实际上 -c 就是 command 的意思 官方文档中解释为(节选自: python docs): Execute the Python code in command. command can be one or more statements separated by newlines, with significant leading whitespace as in normal module code. If this option is given, the first element of sys.argv will be \"-c\" and the current directory will be added to the start of sys.path (allowing modules in that directory to be imported as top level modules). Raises an auditing event cpython.run_command with argument command. 简单来说, 就是 python -c 可以在命令行中执行 python 代码, 跟把代码放置在 .py 文件中然后运行这个文件比无明显差别, 我们来测试一下 1python -c \"print('TTXT')\" 随后正确输出了 TTXT 需要注意的是, python -c 后必须跟一个字符串, 因此必须带上引号, 而且在要执行的代码中也不要重叠, 这样会引发错误, 这是因为 python 认不出该到哪里结尾, 例如 1python -c \"print(\"TTXT\")\" 这样就会报错, 输出 123Traceback (most recent call last): File \"&lt;string&gt;\", line 1, in &lt;module&gt;NameError: name 'TTXT' is not defined 我们一般可以使用三引号来标示需要执行的代码, 例如 1python -c '''print(\"TTXT\")''' 这样还有一个好处就是也可以执行多行的代码, 例如 1234python -c '''import arrow print(arrow.now())''' 这样也是可以的, 也可以定义并调用函数 12345python -c '''def a(): print(111)a()''' 当然也是可以导入自定义的模块或者已经安装的包的 妙用 那么 -c 有什么妙用呢? 这个要具体问题具体分析, 比如说我在开发中要使用一个第三方包 patool, 项目在 github, 这个包作用是根据格式解压压缩文件, 但是在调用时发生总是会报找不到 patoollib 模块的错误 官方给的例子如下 12import patoolibpatoolib.extract_archive(\"archive.zip\", outdir=\"/tmp\") 排查发现, 该模块的起始文件最上面写定了python的地址, 导致运行时强制指定了python路径而没有使用自己的虚拟环境, 因为 /usr/bin/python 没有安装 patool 包所以报错找不到 py文件节选 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/python# -*- coding: utf-8 -*-# Copyright (C) 2010-2015 Bastian Kleineidam## This program is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.\"\"\"patool [global-options] {extract|list|create|diff|search|formats} [sub-command-options] &lt;command-args&gt;\"\"\"def main(): \"\"\"Parse options and execute commands.\"\"\" try: argparser = create_argparser() args = argparser.parse_args() if args.command is None: # Python 3.3.1 under linux allows an empty command somehow argparser.error(\"too few arguments\") # run subcommand function res = globals()[\"run_%s\" % args.command](args) except KeyboardInterrupt: log_error(\"aborted\") res = 1 except Exception: log_internal_error() res = 2 return resif __name__ == '__main__': sys.exit(main()) 似乎只能将包的源代码修改, 实际上只要把第一行删除即可, 但是考虑到Docker部署, 就没有更好的办法了吗? 使用 python -c 即可完美解决 我们使用 python -c 在命令行中使用我们指定的 python 去执行模块, 就会使py文件中指定的不生效, 所以调用改成如下即可 123code = f\"import patoolib; patoolib.extract_archive('{file}', outdir='{unfile}')\"proc = await asyncio.create_subprocess_exec(sys.executable, '-c', code)await proc.wait() 这样就可以完美的解决问题了, 不用修改原来包的代码","link":"/2021/09/04/python_-c/"},{"title":"单例的实现","text":"单例的实现 提前祝大家过个好年 最近忙于项目,今天抽出点时间写写Blog 本篇就写Python的单例实现吧, 就拿自带的模块logging举例吧 Python的logging模块是Python自带的模块,可方便快捷的进行日志的记录 python doc logging本身就是单例的 该模块本身就是线程安全的,下面的注释摘抄至 doc The logging module is intended to be thread-safe without any special work needing to be done by its clients. It achieves this though using threading locks; there is one lock to serialize access to the module’s shared data, and each handler also creates a lock to serialize access to its underlying I/O. If you are implementing asynchronous signal handlers using the signal module, you may not be able to use logging from within such handlers. This is because lock implementations in the threading module are not always re-entrant, and so cannot be invoked from such signal handlers. 也就是说你不需要关注多线程的问题,只要 getLogger() 时指定当前空间即可 Loggers have the following attributes and methods. Note that Loggers should NEVER be instantiated directly, but always through the module-level function logging.getLogger(name). Multiple calls to getLogger() with the same name will always return a reference to the same Logger object. The name is potentially a period-separated hierarchical value, like foo.bar.baz (though it could also be just plain foo, for example). Loggers that are further down in the hierarchical list are children of loggers higher up in the list. For example, given a logger with a name of foo, loggers with names of foo.bar, foo.bar.baz, and foo.bam are all descendants of foo. The logger name hierarchy is analogous to the Python package hierarchy, and identical to it if you organise your loggers on a per-module basis using the recommended construction logging.getLogger(name). That’s because in a module, name is the module’s name in the Python package namespace. 意思是 logger.getLogger() 时传入相同的变量,会永远返回同一个对象,比如我在当前进程内的任何地方, 使用 log = logger.getLogger(\"work\") 生成的log对象一直是同一个对象,这就是单例模式,官方推荐传入 __name__ 因为他是Python包命名空间中模块的名称。 使用logging来讲单例纯粹是一时间没想到有啥能举例子的, 我们就先假如他不是单例的吧😬 不写单例的普通类 手动写一个单例完全是为了记忆单例模式的使用,只是以 logging 模块举例 先写一个普通的类, 这个类封装了logging类, 没有考虑单例问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import loggingimport threadingfrom logging import StreamHandler, handlersclass MyLogger: # log 日志 def __init__(self, *args, **kwargs): # 接收参数 self.level = (kwargs[\"level\"] if kwargs.get(\"level\") else \"debug\") # 日志等级 self.format = (kwargs[\"format\"] if kwargs.get( \"format\") else \"%(asctime)s % (levelname)-8s[%(filename)s:%(lineno)d(%(funcName)s)] %(message)s\") # 格式化结构 self.console = (kwargs[\"console\"] if kwargs.get(\"console\") else True) # 是否输出 self.file = (kwargs[\"file\"] if kwargs.get(\"file\") else None) # 保存的文件名 self.when = (kwargs[\"when\"] if kwargs.get(\"when\") else \"D\") # 日志文件按时间切分 self.backCount = (kwargs[\"backCount\"] if kwargs.get(\"backCount\") else 30) # 保留日志文件最大数量 # 日志级别匹配 self.level_relations = { \"debug\": logging.DEBUG, \"info\": logging.INFO, \"warning\": logging.WARNING, \"error\": logging.ERROR, \"critical\": logging.CRITICAL } self.logger = logging.getLogger(__name__) self.format = logging.Formatter(self.format) if not self.level_relations.get(self.level): self.level = \"debug\" self.logger.setLevel(self.level_relations[self.level]) if self.console: # 输出 streamHandler = logging.StreamHandler() streamHandler.setFormatter(self.format) self.logger.addHandler(streamHandler) if self.file: # 保存 timeHandler = handlers.TimedRotatingFileHandler( filename=self.file, when=self.when, backupCount=self.backCount, encoding=\"utf-8\" ) timeHandler.setFormatter(self.format) self.logger.addHandler(timeHandler)if __name__ == \"__main__\": def test(): l = MyLogger(level=\"debug\") l.logger.warning(\"test\") ts = [] for i in range(10): t = threading.Thread(target=test) t.start() ts.append(t) for t in ts: t.join() 如果我们同时起多个线程去使用, 可能就会出现意料之外的问题 利用 __new__ 实现单例 我们知道,python实例化时其实是先走 __new__ 再走 __init__ 我们可以重写 __new__ 方法,如果发现已生成对象直接返回该对象 同时为了防止多线程的资源竞争,我们使用线程锁来保证同一时间只有一个线程能访问 __new__ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import loggingimport threadingfrom logging import StreamHandler, handlersclass MyLogger: # log 日志 # 使用线程锁防止同一时间多个线程调用__new__ _instance_lock = threading.Lock() def __init__(self, *args, **kwargs): # 接收参数 self.level = (kwargs[\"level\"] if kwargs.get(\"level\") else \"debug\") # 日志等级 self.format = (kwargs[\"format\"] if kwargs.get( \"format\") else \"%(asctime)s %(levelname)-8s[%(filename)s:%(lineno)d(%(funcName)s)] %(message)s\") # 格式化结构 self.console = (kwargs[\"console\"] if kwargs.get(\"console\") else True) # 是否输出 self.file = (kwargs[\"file\"] if kwargs.get(\"file\") else None) # 保存的文件名 self.when = (kwargs[\"when\"] if kwargs.get(\"when\") else \"D\") # 日志文件按时间切分 self.backCount = (kwargs[\"backCount\"] if kwargs.get(\"backCount\") else 30) # 保留日志文件最大数量 # 日志级别匹配 self.level_relations = { \"debug\": logging.DEBUG, \"info\": logging.INFO, \"warning\": logging.WARNING, \"error\": logging.ERROR, \"critical\": logging.CRITICAL } self.logger = logging.getLogger(__name__) self.format = logging.Formatter(self.format) if not self.level_relations.get(self.level): self.level = \"debug\" self.logger.setLevel(self.level_relations[self.level]) if self.console: # 输出 streamHandler = logging.StreamHandler() streamHandler.setFormatter(self.format) self.logger.addHandler(streamHandler) if self.file: # 保存 timeHandler = handlers.TimedRotatingFileHandler( filename=self.file, when=self.when, backupCount=self.backCount, encoding=\"utf-8\" ) timeHandler.setFormatter(self.format) self.logger.addHandler(timeHandler) # 实例化时先走这里 def __new__(cls, *args, **kwargs): # 单例模式 if not hasattr(MyLogger, \"_instance\"): # 检查这个类有没有_instance属性 with MyLogger._instance_lock: # 获取锁 if not hasattr(MyLogger, \"_instance\"): # 这里获取到锁, 但是有可能在获取中有另一个线程已经创建了对象, 所以这里再判断一次 # 没有实例化过 MyLogger._instance = object.__new__(cls) # 调用object的__new__方法, 然后自动调用本类的__init__进行实例化, 将实例化的对象赋值 return MyLogger._instance # 如果已经有了这个属性直接返回if __name__ == \"__main__\": def test(): l = MyLogger(level=\"debug\", file=\"test.log\") l.logger.warning(\"test\") ts = [] for i in range(10): t = threading.Thread(target=test) t.start() ts.append(t) for t in ts: t.join() 运行测试代码, 发现还是会有问题 调试后发现, 即使代码正确捕捉到了 _instance 已经存在, 将其返回了, 但是因为 _instance 是 __new__ 的, 还没有进行 __init__ 调用, 所以每次又重新运行 __init__ , 因为 __init__ 里有给 logging 添加 handler 的操作, 所以随着线程的增多, 每次都会多添加一个 handler, 导致记录一次 logging 记录了多个 handler, 每次记录日志就会重复记录很多次 利用__call__实现 我们将代码改造成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import loggingimport threadingfrom logging import StreamHandler, handlersclass SingletonType(type): # 该类继承元类 _instance_lock = threading.Lock() # 线程锁 def __call__(cls, *args, **kwargs): # 单例模式 if not hasattr(cls, \"_instance\"): # 检查这个类有没有_instance属性 with cls._instance_lock: # 获取锁 if not hasattr(cls, \"_instance\"): # 这里获取到锁, 但是有可能在获取中有另一个线程已经创建了对象, 所以这里再判断一次 # 没有实例化过 cls._instance = super(SingletonType, cls).__call__(*args, **kwargs) # 没有实例化过, 调用type基类的__call__方法, 走正常的流程 return cls._instanceclass MyLogger(metaclass=SingletonType): # log 日志 # 使用线程锁防止同一时间多个线程调用__new__ _instance_lock = threading.Lock() def __init__(self, *args, **kwargs): # 接收参数 self.level = (kwargs[\"level\"] if kwargs.get(\"level\") else \"debug\") # 日志等级 self.format = (kwargs[\"format\"] if kwargs.get( \"format\") else \"%(asctime)s %(levelname)-8s[%(filename)s:%(lineno)d(%(funcName)s)] %(message)s\") # 格式化结构 self.console = (kwargs[\"console\"] if kwargs.get(\"console\") else True) # 是否输出 self.file = (kwargs[\"file\"] if kwargs.get(\"file\") else None) # 保存的文件名 self.when = (kwargs[\"when\"] if kwargs.get(\"when\") else \"D\") # 日志文件按时间切分 self.backCount = (kwargs[\"backCount\"] if kwargs.get(\"backCount\") else 30) # 保留日志文件最大数量 # 日志级别匹配 self.level_relations = { \"debug\": logging.DEBUG, \"info\": logging.INFO, \"warning\": logging.WARNING, \"error\": logging.ERROR, \"critical\": logging.CRITICAL } self.logger = logging.getLogger(__name__) self.format = logging.Formatter(self.format) if not self.level_relations.get(self.level): self.level = \"debug\" self.logger.setLevel(self.level_relations[self.level]) if self.console: # 输出 streamHandler = logging.StreamHandler() streamHandler.setFormatter(self.format) self.logger.addHandler(streamHandler) if self.file: # 保存 timeHandler = handlers.TimedRotatingFileHandler( filename=self.file, when=self.when, backupCount=self.backCount, encoding=\"utf-8\" ) timeHandler.setFormatter(self.format) self.logger.addHandler(timeHandler)if __name__ == \"__main__\": def test(): l = MyLogger(level=\"debug\", file=\"test.log\") l.logger.warning(\"test\") ts = [] for i in range(10): t = threading.Thread(target=test) t.start() ts.append(t) for t in ts: t.join() 在这个代码中, 我们指定了MyLogger 的元类是 SingletonType, 其实在python中实例化对象都是在声明这个类时执行type的__new__和__init__(这里每次声明一个新的类都会走一遍), 然后在创建对象时执行type的__call__, 在__call__中调用自定义类的__new__和__init__ 我们主要是修改了SingletonType 的__call__, 当实例化时首先判断是否存在了, 不存在再走super 也就是 type 的__call__流程 一文搞懂什么是Python的metaclass - 知乎 (zhihu.com) 当然对于自定义metaclass, 开发者们有相当一部分是认为其会破坏代码的可读性等, 如果你也这么觉得, 我们可以使用下一个方法 自写初始化方法 我们回看第一种方法, 之所以有问题是每次在__init__时会添加一个handler, 那么我们可以修改逻辑, 让他通过别的方法来添加handler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import loggingimport threadingfrom logging import StreamHandler, handlersclass MyLogger: # log 日志 # 使用线程锁防止同一时间多个线程调用__new__ _instance_lock = threading.Lock() def _instance_init(self, *args, **kwargs): # 接收参数 self.level = (kwargs[\"level\"] if kwargs.get(\"level\") else \"debug\") # 日志等级 self.format = (kwargs[\"format\"] if kwargs.get( \"format\") else \"%(asctime)s %(levelname)-8s[%(filename)s:%(lineno)d(%(funcName)s)] %(message)s\") # 格式化结构 self.console = (kwargs[\"console\"] if kwargs.get(\"console\") else True) # 是否输出 self.file = (kwargs[\"file\"] if kwargs.get(\"file\") else None) # 保存的文件名 self.when = (kwargs[\"when\"] if kwargs.get(\"when\") else \"D\") # 日志文件按时间切分 self.backCount = (kwargs[\"backCount\"] if kwargs.get(\"backCount\") else 30) # 保留日志文件最大数量 # 日志级别匹配 self.level_relations = { \"debug\": logging.DEBUG, \"info\": logging.INFO, \"warning\": logging.WARNING, \"error\": logging.ERROR, \"critical\": logging.CRITICAL } self.logger = logging.getLogger(__name__) self.format = logging.Formatter(self.format) if not self.level_relations.get(self.level): self.level = \"debug\" self.logger.setLevel(self.level_relations[self.level]) if self.console: # 输出 streamHandler = logging.StreamHandler() streamHandler.setFormatter(self.format) self.logger.addHandler(streamHandler) if self.file: # 保存 timeHandler = handlers.TimedRotatingFileHandler( filename=self.file, when=self.when, backupCount=self.backCount, encoding=\"utf-8\" ) timeHandler.setFormatter(self.format) self.logger.addHandler(timeHandler) # 实例化时先走这里 def __new__(cls, *args, **kwargs): # 单例模式 if not hasattr(MyLogger, \"_instance\"): # 检查这个类有没有_instance属性 with MyLogger._instance_lock: # 获取锁 if not hasattr(MyLogger, \"_instance\"): # 这里获取到锁, 但是有可能在获取中有另一个线程已经创建了对象, 所以这里再判断一次 # 没有实例化过 MyLogger._instance = object.__new__(cls) # 调用object的__new__方法, 然后自动调用本类的__init__进行实例化, 将实例化的对象赋值 MyLogger._instance._instance_init(*args, **kwargs) # 只有第一次初始化时才执行handler return MyLogger._instance # 如果已经有了这个属性直接返回if __name__ == \"__main__\": def test(): l = MyLogger(level=\"debug\", file=\"test.log\") l.logger.warning(\"test\") ts = [] for i in range(10): t = threading.Thread(target=test) t.start() ts.append(t) for t in ts: t.join() 保证每次只在需要的时候添加handler 即可","link":"/2021/09/04/realize_single_case/"},{"title":"requirements 语法","text":"requirements 语法 之前一直苦于一个问题,比如一些包在Win上安装不了,比如 uvloop 但是为了提高效率,代码中必须有这个模块 在运行中可以通过 os 模块判断是否使用, 那依赖文件呢? requirements.txt 要不要有 uvloop 呢? 其实我们可以通过语法来赋予 requirements.txt 一定的灵活性. 比如,我们使用 pip freeze &gt; requirements.txt 时,输出的大致为 12redis==3.2.1requests==2.21.0 每一行为 模块名==版本号, 这其实就是一种语法, 用来标记安装的模块的版本号, 其实他还有很多语法 详见官方文档 PEP508-doc 根据操作系统确定是否安装依赖 这里抛砖引玉,只写一个例子,就是根据系统OS判断要不要装某个模块 比如 uvloop, 不支持 Windows 我们可以这样写 1uvloop==0.14.0;platform_system==\"Linux\" 这样就是判断当前环境,如果为 Linux 就安装 0.14.0 的 uvloop 模块,如果是其他环境就 忽略 需要注意的是, Linux 是表格中写的可选值(详见官方文档的platform_system栏) 请严格区分大小写并不要写错,写错不会报错但是识别不了","link":"/2021/09/04/requirements_syntax/"},{"title":"Rust程序设计语言(1)","text":"安装 brew brew install rust 其他 官网 校验是否安装成功 安装后在命令行输入 rustc --version 如果看到rust的版本号即可, 例如 rustc 1.42.0 (b8cedc004 2020-03-09) 打开内置的文档 命令行输入 rustup doc, 会调用默认浏览器打开本地的内置文档 VsCode配置插件 插件商城输入 rust, 排第一的就是, 安装后打开rust项目会提示下载依赖, 同意即可 Hello,world 编写一个输出 hello, world 的程序 编写与执行 在某个地方新建文件夹 hello_world , 在文件夹下新建文件 main.rs , 编写代码如下 123fn main() { println!(\"hello, world\");} 保存后在当前目录下执行命令 rustc main.rs 会生成可执行文件 main, 执行这个文件, 打印 hello, world, 例如 1234➜ hello_world rustc main.rs ➜ hello_world ./main hello, world➜ hello_world 解析 rust的代码写在 .rs 后缀的文件中 rust推荐使用下划线方法来命名, 比如 hello_world 而不是 helloWorld 或者 helloworld rust的缩进是4个空格而不是一个tab 我们来解析代码 12fn main() {} fn代表定义一个函数, 这里定义了一个 main 函数, main函数是特殊的函数, 每个可执行的rust程序都从main函数开始, main() 代表这个函数不需要任何参数, 如果有的话应该定义在 () 中. () 后直接跟的 {} 代表函数本体, rust要求函数内部的代码都被这个大括号包裹, 而 main(){} 也代表了这个函数没有任何的返回值, 一般来说 { 与函数名在同一行, 并使用空格分开 rust的新版本自带了代码的格式化工具 rust fmt, 使用他可以将你的代码格式化的更加规范 在当前命令行中使用 rustfmt main.rs 查看格式化后的代码, 如果你的代码原来是 1fn main() {println!(\"hello, world\");} 格式化之后变成了 123fn main() { println!(\"hello, world\");} 而其中的 1println!(\"hello, world\"); 则是函数的逻辑, 上面说到了缩进是四个空格 println! 是rust内置的宏(macro), 类似于内置的语法, 而引入内置的函数则是 println, 这个之后再说明 \"hello, world\"是传入这个宏的参数, 是一个字符串, 然后该字符串就会被输出到命令行中 rust中使用 ; 作为一行的结束, 代表这个表达式结束, 下一个表达式开始 编译 rust是一门静态语言, 他也是需要编译的, 还记得我们写完后在命令行输入 rustc main.rs 吗, 这就是在编译代码, 编译完成后会生成编译平台可执行的文件 hello, cargo 认识cargo cargo 是rust的构建系统和依赖管理工具, 类似于golang的 go mod 在实际的编写项目中, 常常需要引入第三方的函数, 此时我们就需要 cargo 来帮助我们管理 cargo在安装 rust 时就已经安装到了你的电脑中 你可以在命令行中输入 1cargo --version 来查看cargo的版本, 例如 cargo 1.42.0 (86334295e 2020-01-31) 使用cargo建立项目 正常情况下我们一般使用 cargo 来建立新项目, 而不是手动建立文件夹 12345➜ student ls➜ student cargo new hello_cargo Created binary (application) `hello_cargo` package➜ student lshello_cargo 可以看到, 在执行 cargo new hello_cargo 之后, 原本空的文件夹下出现了 hello_cargo 文件夹, 这与我们执行 new 时的输入是相同的 我们的项目就在这里 里面已经多了几个文件, 目录树如下 12345678910111213141516171819.├── .git│ ├── HEAD│ ├── config│ ├── description│ ├── hooks│ │ └── README.sample│ ├── info│ │ └── exclude│ ├── objects│ │ ├── info│ │ └── pack│ └── refs│ ├── heads│ └── tags├── .gitignore├── Cargo.toml└── src └── main.rs 可以看到, cargo会在 hello-cargo 下初始化 git, 并且为我们生成了 .gitignore 忽略文件, 其中默认忽略了 /target 目录, 我们之后再介绍这个文件夹 同时生成了 cargo.toml 文件, toml格式是一种配置文件的格式, 他的内容大致如下 123456789[package]name = \"hello_cargo\"version = \"0.1.0\"authors = [\"example &lt;example@example.com&gt;\"]edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] 其中, package下为项目的信息, name为项目名, version为版本, authors为创建人(读取git的信息), edition这个项目创建时的大版本号, 目前是2018 里面的Value内容是可以修改的, 如果信息不准确你可以手动进行修改 我们真正的代码在 src/main.rs 中, 里面已经默认添加了 main 函数 123fn main() { println!(\"Hello, world!\");} rust希望你将所有的源代码放置在这个src目录下, 在根目录只放置 README.md/ 配置文件 等不涉及到代码的东西 如果当前目录已经在 git 的控制下, 那么使用 cargo new 默认不会创建git相关的文件, 但是你可以使用参数 --vcs=git 来强制创建, 更多用法可查看 cargo new --help 执行cargo cargo build 在命令行执行 123➜ hello_cargo git:(master) ✗ cargo build Compiling hello_cargo v0.1.0 (/Users/Work/Code/Rust/student/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.76s 我们会发现在目录下生成文件夹 /target 在里面的 /debug 中则有可执行文件 hello_cargo 我们执行他 12➜ hello_cargo git:(master) ✗ ./target/debug/hello_cargoHello, world! 所以, 我们 build 后会把生成的文件放置在 /target/debug 下, 当然 target 下还有很多文件, 我们之后再说 当某个项目第一次build, 还会在根目录生成 Cargo.lock 文件, 里面会存放一些具体的依赖, 一般不需要我们修改 cargo run 我们也可以使用 cargo run 来直接运行 build 出的程序, 与上面的方式没有区别 1234➜ hello_cargo git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/hello_cargo`Hello, world! 更强大的是, 如果你修改了源代码, 此时你无需执行 build, 直接执行 run 可自行 build然后执行 比如我们将 main.rs 修改为 1234fn main() { println!(\"Hello, world!\"); println!(\"Hello, world!\");} 保存后直接执行 cargo run 123456➜ hello_cargo git:(master) ✗ cargo run Compiling hello_cargo v0.1.0 (/Users/Work/Code/Rust/student/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.27s Running `target/debug/hello_cargo`Hello, world!Hello, world! 如果你事先没有 build, 也就是没有 target 文件夹, 执行 cargo run也会自己build cargo check 如果你只想确认你编写的代码是否可以运行而不想build出文件, 可以执行 cargo check, 可以在不生成可执行文件的前提下检查你的代码是否可以编译 123➜ hello_cargo git:(master) ✗ cargo check Checking hello_cargo v0.1.0 (/Users/chenming/Work/Code/Rust/student/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.13s cargo release 当你的项目需要发布或者迁出稳定版的时候, 使用 cargo build --release , 与普通的build不同的是, 该操作会优化生成的可执行文件, 提高执行速度等等, 当然, 因为优化原因, release 的耗时会比普通的 build 慢一些, 编译完成后会放置在 /target/release 文件夹下, 建议每次发布时都采用此方式编译 代码格式化 之前提到对某一个 rs 文件格式化代码使用 rustfmt xx.rs 如果对整个项目都格式化, 使用 cargo fmt 即可 如果你只想查看哪些是需要格式化的而不是直接修改好文件, 使用 cargo fmt -- --check 即可 最好对每个项目都是用targo来管理, 这样对项目来讲是最好的 设计猜谜游戏程序 这个程序的流程是, 用户输入一个数字, 然后程序自己随机出一个数字, 将这两个数字进行对比 建立新项目 使用 cargo 建立新项目并进入目录 12345➜ student cargo new guessing_game Created binary (application) `guessing_game` package➜ student lsguessing_game➜ student cd guessing_game 此时在 /src/main.rs 中已经有一个 main 函数了, 我们修改 main 函数 处理用户输入的数字 我们将代码修改成下面的 12345678910use std::io; // 引入标准库fn main() { println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 println!(\"你猜测的数字是: {}\", guess) // 输出获取到的输入} 值得注意的是, rust的注释是 //, 他不会编译//后的内容直到本行的结尾 这段代码的目的是读取用户输入的数字并输出 在第一行, 我们使用 use 语法来引入标准库 std::io, 类似于Python/Go的import 我们首先在输入框中输出提示 输入你的猜测数字: let 在第5行, 我们使用 let 来创建一个 变量, 但是与其他语言不同的是, 如果你只是使用 let, 那么你创建的变量的值是不可变的, 例如以下代码 12let a = \"1212\";a = \"1111\" ; 我们使用 cargo check 来检查会爆出错误 123456789101112error[E0384]: cannot assign twice to immutable variable `a` --&gt; src/main.rs:5:5 |4 | let a = \"1212\"; | - | | | first assignment to `a` | help: make this binding mutable: `mut a`5 | a = \"1111\" ; | ^^^^^^^^^^ cannot assign twice to immutable variableerror: aborting due to previous error 告诉我们不能对不可变的变量进行二次赋值 所以, 如果这个变量在以后需要重新赋值, 我们需要使用 let mut 12let mut a = \"1212\";a = \"1111\" ; 对于新建变量来说, 还是要根据用途来进行设计 12let mut a = \"1212\"; // 可变变量let b = \"dddd\" // 不可变变量 回到代码中, 我们看到, 我们新建了一个可变变量 guess, 他的值是 String::new() , 代表着使用了 String 的new 方法, 生成了一个 String 实例, String 代表着 rust 的字符串类型, 那么, String::new()代表生成了一个字符串类型的初始值, 也就是空字符串 ::new 代表调用 new 方法, new对于String 来说是关联函数(associated function) , 通常我们认为new是String 的静态方法, 一些面向对象的语言通常都有这个概念, 指的是类自有的方法, 而不需要对象去调用 在 rust 中, 新建一个新的类型的初始值通常使用 ::new 123io::stdin() // 调用stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 这三行代码其实是一条语句, 我们之前提到, ; 代表一段代码的结束, 所以rust会将这三行合并成一条语句来解析, 所以我们也可以将这三行缩短为, 这样会减少代码的可读性 1io::stdin().read_line(&amp;mut guess).expect(\"读取失败\"); 这段代码的意思是调用 io 模块的静态方法 stdin, 此方法回传一个实例 stdin, 匹配标准输入控制 然后继续调用实例的 read_line 方法, 此方法对标准输入代码执行 read_line 命令, 来获取使用者的输入信息, 我们还将生成的可变变量 guess 传递进去, 代表将用户输入的结果传递给 guess &amp; 代表这个参数是引用(reference) , 这让代码中的多个部分共享一个值, 不需要每次都复制值到一个新的地址, 引用是个复杂的概念, rust 可以让你安全又轻松的使用引用, 这个之后再讲, 你现在需要知道的是, 引用默认也是不可变的, 因此在后面加上 mut 代表这个是可变引用, 因此你必须写 &amp;mut guess 而不是 &amp;guess 使用Result类型处理可能出现的错误 .expect(\"读取失败\"); 这个代码处理了 read_line 方法可能出现的错误, 因为 read_line 返回了 io::Result 对象, 在 rust 中有很多库都有 Result类, Result实际上是种枚举(enumerations/enums), 枚举是拥有固定的值的类型, 这些值被称为枚举的变体(variants), 对于Result 来说, 变体有 ok 和 Error, ok代表成功, error 代表失败, 返回 Result 的目的是让使用者在错误发生时去处理这个问题, io::Result 自带了方法 expect, 当Result返回 时便会触发 expect, 如果是 ok 则代表没有出现问题, expect 不会对数据进行任何操作 当我们不对 expect 进行捕捉, 我们在编译时就会出现如下警告 1234567891011use std::io; // 引入标准库fn main() { println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess); // 调用stdin的方法read_line获取输入值 // .expect(\"读取失败\"); // 如果获取错误打印警告 println!(\"你猜测的数字是: {}\", guess) // 输出获取到的输入} 12345678910111213➜ guessing_game git:(master) ✗ cargo build Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game)warning: unused `std::result::Result` that must be used --&gt; src/main.rs:6:5 |6 | / io::stdin() // 调用函数stdin7 | | .read_line(&amp;mut guess); // 调用stdin的方法read_line获取输入值 | |_______________________________^ | = note: `#[warn(unused_must_use)]` on by default = note: this `Result` may be an `Err` variant, which should be handled Finished dev [unoptimized + debuginfo] target(s) in 0.62s 提示你没有处理可能出现的错误, 这里我们先添加 expect 保证其编译时不警告, 至于怎么去使用 expect 我们之后再说 println!打印输入的数字 1println!(\"你猜测的数字是: {}\", guess) // 输出获取到的输入 这里是将用户输入的数字打印出来, {}代表占位符, 将 guess 的值填充到 {} 中, {} 可以多个, 例如 1234let x = 5;let y = 10;println!(\"x = {} 而且 y = {}\", x, y); 输出 1x = 5 而且 y = 10 运行第一个部分 显然的, 程序还没有编写完成, 目前只能获取到用户的输入并打印出来 1234567➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game) Finished dev [unoptimized + debuginfo] target(s) in 0.60s Running `target/debug/guessing_game`输入你的猜测数字: 3你猜测的数字是: 3 生成随机的秘密数字 既然是猜谜游戏, 那么系统需要生成一个随机的数字来进行比对决定对错 使用Crate来获取更多功能 crate.io 是rust官方的仓库, 里面是rust各种各样的包(类似Python的pypi), 我们需要使用其中的一个包 rand 来帮助我们生成随机数字 如何将rand添加进我们的项目呢? 我们找到项目根目录下的Cargo.toml 文件, 并编辑 12345678910[package]name = \"guessing_game\"version = \"0.1.0\"authors = [\"xx &lt;xx@Outlook.com&gt;\"]edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]rand = \"0.5\" 我们在 [dependencies] 下新增包 rand 设置其版本为 0.5 ,这代表限制rand的版本在0.5`中, 避免出现兼容问题 然后我们使用 cargo build 能看到cargo自动下载了我们指定的包, 如果我们指定的包需要依赖其他的包, cargo也会自动帮我们下载(比如下面的 rand_core) 123456➜ guessing_game git:(master) ✗ cargo build Updating crates.io index Downloaded rand v0.5.6 Downloaded rand_core v0.3.1 ...... Finished dev [unoptimized + debuginfo] target(s) in 11.13s crate.io受网络影响, 在国内可能会出现通信问题, 可以使用第三方源比如USTC 如果你出现Blocking waiting for file lock on package cache错误, 尝试删除 ~/.cargo/.package-cache 文件 通过Cargo.lock确保项目依赖的正确性 当我们通过 cargo 安装新的依赖后, 我们会发现 Cargo.lock 文件也发生了变化, 增加了我们添加的依赖的具体的信息, 比如 123456789101112[[package]]name = \"rand\"version = \"0.5.6\"source = \"registry+https://github.com/rust-lang/crates.io-index\"checksum = \"c618c47cd3ebd209790115ab837de41425723956ad3ce2e6a7f09890947cacb9\"dependencies = [ \"cloudabi\", \"fuchsia-cprng\", \"libc\", \"rand_core 0.3.1\", \"winapi\",] cargo通过该文件来保证依赖的完整性和准确性, 当我们联合开发时, 只要将 Cargo.lock Cargo.toml 上传至项目中, 通过 cargo build 即可下载同样的依赖 升级Crate依赖 如果依赖有小版本的升级, 这通常是修复BUG和提高性能, 使用 cargo update 可以更新依赖, cargo会根据 cargo.toml 的语义化版本升级兼容该版本的小版本更新, 然后更新 cargo.toml 和 cargo.lock 中的内容 例如 你指定了rand 版本为 rand=0.8 则如果当前的版本是 0.8.3 新版本是 0.8.5会自动更新 如果新版本为 0.9.1 则与你指定的版本不同, 则不更新 如果你想更新到 0.9 版本, 需手动的编辑 toml 文件然后执行 update, 但是因为大版本的更新可能伴随着功能的修改, 必须要在手动升级前确认新版本的兼容性 生成随机数字 修改代码为 12345678910111213use std::io; // 引入标准库use rand::Rng;fn main() { println!(\"输入你的猜测数字: \"); // 打印 let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 println!(\"你猜测的数字是: {}\", guess) // 输出获取到的输入} 注意到我们新增了两行代码 1234 use rand::Rng; ....let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 在最开始, 我们引入了新的模块, rand::Rng, 需要注意的是, 我们在下面使用 rand 的时候并没有使用 Rng, 实际上这个 Rng 被称作 特征(trait) 它定义了数字生成器的工作方法, 必须将其引入才可以正常生成数字, 关于特征的更多情况, 我们之后再做讲解 重要的是生成随机数字这一段, 我们使用 rand包的thread_rng方法, 这会返回一个随机数字的生成器, 以当前的工作进程做为种子, 然后我们调用这个生成器的 gen_range 方法, 这个方法是由我们引入的 Rng 定义的, 他接受两个参数, 最大值和最小值, 我们传入 1, 101 代表生成 1-100的数字, 他是顾头不顾尾的, 所以我们要填到101 我们将其打印出来运行, 目的是测试功能是否正常, 事实上程序并未完成 12345678➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game) Finished dev [unoptimized + debuginfo] target(s) in 0.51s Running `target/debug/guessing_game`输入你的猜测数字: 生成的数字是: 61你猜测的数字是: 1 将猜测的数字与生成的数字进行比较 在上面, 我们生成了数字并获取到了用户输入的数字, 这一步我们将这两个数字进行比较 12345678910111213141516171819use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { println!(\"输入你的猜测数字: \"); // 打印 let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; println!(\"正确\"), }} 我们先引入了 std::cmp::Ordering , Ordering是一个枚举, 其变体为 Less, Greater, Equal. 当你对两个数字进行比较时会有这三种结果 cmp方法会对数字进行比较, 我们传入引用 secret_number , 目的是将 guess 与 secret_number 进行比较, 他会回传我们引入的 Ordering 变体 match 有时候, 我们需要对某个枚举的变体进行分别处理, 比如这里, 我们根据数字比较结果来提示用户数字的范围 所以我们使用 match 语法 match 由**分支(arms)组成, 每个分支包含一个模式(pattern)**和他的处理逻辑, 当匹配到这个模式, 就会执行对应的逻辑. 在执行完毕后则退出 math 不再进行下面的匹配, match的具体细节会在之后讲解 但是我们运行时会发现他会报错 1234567891011121314151617➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game)error[E0308]: mismatched types --&gt; src/main.rs:15:21 |15 | match guess.cmp(&amp;secret_number){ | ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer | = note: expected reference `&amp;std::string::String` found reference `&amp;{integer}`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `guessing_game`.To learn more, run the command again with --verbose. 这是因为, guess的类型是字符串, 而secret_number是数值,这就会导致 型別無法配對（mismatched types）, rust是静态类型的语言, 这两个是无法进行直接比较的 关于数值, rust有多个数值类型, 分别为 i3232位元数字, u32无符号32位元数字, i6464位元数字, u6464位无符号元数字等等, 默认的类型为 i32, 因此 secret_number 为 i32 同时我们也面临一个问题, 就是用户输入的不是数字怎么办 此时我们需要将guess转换为数字, 让他们可以比较, 将代码修改为 1234567891011121314151617181920use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { println!(\"输入你的猜测数字: \"); // 打印 let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 let guess: u32 = guess.trim().parse().expect(\"请输入正确的数字\"); println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; println!(\"正确\"), }} 我们添加了一行 1let guess: u32 = guess.trim().parse().expect(\"请输入正确的数字\"); 注意到, 之前有定义过 guess 为 string 类型, 这里是将他重新定义为一个u32类型的数值, 这在rust中被称为遮蔽(shadow), 我们遮蔽了原来的guess, 遮蔽让我们可以重复的使用一个变量名, guess.trim()可以去除这个字符串前后的空白和换行, 而.parse()则可以将字符串转换为数值类型, 同时我们捕捉expect, 如果转换失败, 则告诉用户出现错误了, 我们来执行代码 12345678➜ guessing_game git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/guessing_game`输入你的猜测数字: 生成的数字是: 54 1你猜测的数字是: 1太小了 12345678➜ guessing_game git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/guessing_game`输入你的猜测数字: 生成的数字是: 9ffff111thread 'main' panicked at '请输入正确的数字: ParseIntError { kind: InvalidDigit }', src/main.rs:13:22note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 使用户循环输入 目前的程序, 用户输入一次失败后就结束了程序, 为了提升体验, 我们需要让用户可以循环输入 loop loop语法可以生成一个死循环, 我们将代码修改为 12345678910111213141516171819202122use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 loop{ println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 let guess: u32 = guess.trim().parse().expect(\"请输入正确的数字\"); println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; println!(\"正确\"), } }} loop是一个死循环, 因此我们不停的输入数字去比较, 退出的方法只有强制关闭程序比如 ctrl+c, 或者输入一个无法解析为数值的字符串让他报错 12345678910111213➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game) Finished dev [unoptimized + debuginfo] target(s) in 0.40s Running `target/debug/guessing_game`生成的数字是: 79输入你的猜测数字: 11你猜测的数字是: 11太小了输入你的猜测数字: ffthread 'main' panicked at '请输入正确的数字: ParseIntError { kind: InvalidDigit }', src/main.rs:14:26note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace break 我们需要在用户猜中之后让他结束这个游戏, 使用 break 语法可以退出循环 12345678910111213141516171819202122232425use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 loop{ println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 let guess: u32 = guess.trim().parse().expect(\"请输入正确的数字\"); println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; { println!(\"你猜中了, 游戏结束\"); break; }, } }} 当猜中时, 使用break退出循环, 因为下面没有代码了,就直接退出 123456789101112➜ guessing_game git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/guessing_game`生成的数字是: 25输入你的猜测数字: 11你猜测的数字是: 11太小了输入你的猜测数字: 25你猜测的数字是: 25你猜中了, 游戏结束 对错误进行处理 现在, 用户输入一个无法转成数值的字符串会导致程序结束, 我们现在需要处理这个错误, 让他在错误时重新输入, 不让代码结束, 我们应该对每个错误都捕捉处理, 避免程序关闭, 这对每个程序都是一样的 我们将expect的处理变成一个match, 当分支检测到Error时进行特殊的处理 12345678910111213141516171819202122232425262728293031use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 loop{ println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 let guess: u32 = match guess.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; { println!(\"输入了一个无法解析的字符串\"); continue; }, }; println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; { println!(\"你猜中了, 游戏结束\"); break; }, } }} 我们在上面说过, parse返回一个枚举, 那我们就使用match判断这个枚举的分支, 他会有两种情况, OK 和Err, 如果是OK则代表正确, 我们将回传的num原样返回给guess, 如果Err 代表失败, 在失败时我们就不关心num是什么了, 所以我们使用_ 接受, 然后打印告诉用户出现了错误, 使用break关键字跳出当前的循环 12345678910111213141516➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game) Finished dev [unoptimized + debuginfo] target(s) in 0.44s Running `target/debug/guessing_game`生成的数字是: 82输入你的猜测数字: 11你猜测的数字是: 11太小了输入你的猜测数字: ff输入了一个无法解析的字符串输入你的猜测数字: 82你猜测的数字是: 82你猜中了, 游戏结束 如果是真实的程序, 应该将程序生成的数值打印去除, 这里保留只是为了方便调试","link":"/2021/09/04/rust_programming_language(1)/"},{"title":"Rust程序设计语言(2)","text":"变量与可变性 rust默认你创建的变量是不可变变量, 这是为了提高代码的安全性, rust鼓励你多使用不可变变量, 当然当你有需要的时候, 你可以将其变成可变变量 我们来创建一个新的项目来开始本章 cargo new variables 修改main.rs为 123456fn main() { let x = 5; println!(\"{}\", x); x = 6; println!(\"{}\", x);} 运行他, 会报错 1234567891011121314151617181920➜ variables git:(master) ✗ cargo run Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables)error[E0384]: cannot assign twice to immutable variable `x` --&gt; src/main.rs:4:5 |2 | let x = 5; | - | | | first assignment to `x` | help: make this binding mutable: `mut x`3 | println!(\"{}\", x);4 | x = 6; | ^^^^^ cannot assign twice to immutable variableerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0384`.error: could not compile `variables`.To learn more, run the command again with --verbose. 这里的错误是 cannot assign twice to immutable variable, 告诉你不能对不可变变量二次赋值 rust加入这个限制是为了代码的安全性, 因为对于开发者来说, 建立不可变变量的目的是不希望他能够修改, 如果你可以修改, 就可能会导致代码朝着无法预料的方向发展 在rust中, 编译器会确保你创建的不可变变量永远不被修改, 这能让你更加专注的考虑正常的逻辑 同时我们可以设置可变变量来解决问题, 使用 mut 来标识这个变量是可变的, 比如 123456fn main() { let mut x = 5; println!(\"{}\", x); x = 6; println!(\"{}\", x);} 此时就可以正常的运行 123456➜ variables git:(master) ✗ cargo run Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables) Finished dev [unoptimized + debuginfo] target(s) in 0.60s Running `target/debug/variables`56 对于大型的项目来说, 将变量设置成可变然后更改其值要比将变量设置为不可变然后读取其值复制给新的变量效率更高 变量与常量的区别 当你创建一个不可变变量 时, 你仍然可以在后续中修改他为可变变量, 但是对于常量来讲, 创建过后及 无法通过任何方式修改, 他不是预设无法修改, 而是永远无法修改 当你使用 const 关键字来创建常量时, 必须要指定他的类型 常量只能被常量表达式来设置, 不能通过某个函数的返回值或者运行时产生的数值来设置 rust的常量通常使用全大写的字母, 多个单词间使用_连接的方式来命名, 例如 1const MAX_POINTS: u32 = 100_000; // 创建常量 MAX_POINTS , 类型是u32, 值是100000 其中, 100000与100_000是一样的数值, 加_可以提升可读性 遮蔽(shadowing) 对于变量来讲, 我们可以在给某个变量赋值后, 通过遮蔽的方式来重新赋值, 或者说是覆盖 使用 let 来对一个已经存在的变量重新声明, 这样新的变量就会遮蔽原来的变量 12345678fn main() { let a = 1; println!(\"{}\", a); let a = 5; println!(\"{}\", a); let a = a+1; println!(\"{}\", a);} 输出 123156 需要注意的是, 我们在遮蔽时, 必须要带上let关键字, 否则会出现编译错误 我们知道, 使用 mut 可以设置可变变量, 他与遮蔽的不同是遮蔽对某个变量操作时可以设置不同的类型, 而mut不可以, 比如 12let spaces = \" \";let spaces = spaces.len(); 这里 spaces 从字符串类型遮蔽成了数字类型 12let mut spaces = \" \";spaces = spaces.len(); 这段代码是无法编译的, 因为mut无法改变值的类型 12345fn main() { let mut a = 1; println!(\"{}\", a); a = \"dadad\"} 123456789101112➜ variables git:(master) ✗ cargo run Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables)error[E0308]: mismatched types --&gt; src/main.rs:4:9 |4 | a = \"dadad\" | ^^^^^^^ expected integer, found `&amp;str`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `variables`. 数据类型 数据类型分为两种: 纯量(scalar)和复合(compound) Rust是一个静态类型语言, 因此, 所有变量在编译时编译器就必须知道他的类型, 如果无法得知就会导致编译错误 当然, 一般情况下, 编译器会自动识别出我们想要设置的类型, 比如 1let a = 1; 但是对于函数来讲, 有时候可能有多个可能的结果返回, 比如 1let guess: u32 = \"42\".parse().expect(\"error！\"); 在编译时就会出现错误 1234567891011 Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables)warning: unused variable: `guess` --&gt; src/main.rs:2:9 |2 | let guess: u32 = \"42\".parse().expect(\"這不是數字！\"); | ^^^^^ help: consider prefixing with an underscore: `_guess` | = note: `#[warn(unused_variables)]` on by default Finished dev [unoptimized + debuginfo] target(s) in 0.40s Running `target/debug/variables` 纯量 纯量的类型代表单一的值, rust有四种纯量, 分别为 整数/浮点数/字符/布尔 整数 整数指的是没有小数点的数字, 之前我们使用过 u32, 还有其他的几种 长度 带正负号 不带正负号(正整数) 8位 i8 u8 16位 i16 u16 32位 i32 u32 64位 i64 u64 128位 u128 系统架构 isize usize 首先, 带正负号与不带正负号的区别就是字面意思, 带正负号可以表示负数, 不带则只能表示正整数 然后, 长度代表了这个变量在记忆体内存储的大小, 也影响了数字的范围, 而isize和usize则与系统有关, 如果你的系统是32位, 则是32位的长度, 64就是64 对于某个数字, 你可以将类型拼在值后面来标识这个值是什么类型, 比如54u16代表是u16位的值是54 默认的整数是i32, 这在rust中是运行速度最快的类型 整数溢出 举个例子, 如果你创建了一个u8的变量, 那么他的长度只有8位, 只能容纳 1-255 之间的数值, 如果你给他赋值成 256, 或者大于255的数字, 就会发生整数溢出, 如果你是在默认情况下编译的话, 则会在运行时造成panic错误, 如果你是编译成稳定版(release), 程序在检测到溢出时会处理这个错误, 并不会让他直接panic但是会使原有的值发生变化, 造成逻辑错误. 浮点数 浮点数有 f32(单精度) 和 f64(双精度), 默认是f64 12345fn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32} 数值运算 数值之间当然可以进行运算 12345678910111213141516fn main() { // 加 let sum = 5 + 10; // 減 let difference = 95.5 - 4.3; // 乘 let product = 4 * 30; // 除 let quotient = 56.7 / 32.2; // 求余 let remainder = 43 % 5;} 布尔值 true(真)和false(假) 12345fn main() { let t = true; let f: bool = false; } 字符 单个字符使用单引号来表示, 例如一个字母/中文/表情, 当我们需要表达不止一个字符时, 就需要使用双引号 12345678fn main() { let c = 'z'; let z = 'ℤ'; let heart_eyed_cat = '😻'; let a = \"1111111\"; let b = '我'; let d: char = '他';} rust的char与unicode类似, 确又不是完全一样, 我们之后会详细解释 复合类型 复合类型有两个最基本的, 元组(tuples)和阵列(arrays) 元组 元组是将不同或相同的数据类型放置到一起的常见用法, 需要注意的是元组的长度在确定后无法更改 元组的设立是用括号括起来, 因为一个元组内的每个数据都有可能有独立的数据类型, 所以在必要时也可以指定每个的类型, 如果不指定rust会自己判断 123fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1);} 这里的变量tup就是元组, 元组内有多个元素, 我们可以使用模式配对(pattern matching), 来获取每一个元素的值 1234567fn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\"y 的數值為：{}\", y);} 这种将元组打散然后分别赋值给 x/y/z, 需要保证接受者和元组的长度是一致的, 这种也被成为解构(destructuring) 还有一种通过索引来取其中某个值的方法, 在rust中通过.来获取, 比如 123456789fn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2;} 索引和其他语言一样, 都是从0开始的, 并且不能超出索引大小 阵列 与元组不同的是, 一个阵列的元素必须是同一个数据类型, 而且和元组一样, 阵列长度在确定后无法更改 阵列的设立是使用中括号, 例如 123fn main() { let a = [1, 2, 3, 4, 5];} 当你希望将数据放置在堆栈上而不是堆上时(我们之后会详细解读), 或者当你想要确保始终拥有固定数量的元素时, 你可以使用阵列来做 当你不知道有多少个数据时(很多时候是这样), 阵列和元组都将不适合使用, 此时, rust标准库提供了**矢量(vector)**类型, 他是可以改变长度的, 如果你不确定应该使用矢量还是阵列时, 你应该使用矢量来创建, 矢量的具体细节之后再讲述 当你明确的知道数据的数量时, 你就可以放心的使用阵列, 例如, 每年有12个月 12let months = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]; 这里rust会自己判别阵列的类型和长度, 当然你也可以指定 1let a: [i32; 5] = [1, 2, 3, 4, 5]; 这里, i32 是每个元素的类型, 5是这个阵列的长度 如果你想给每个元素都设置一个默认值, 可以这样写 1let a = [3; 5]; 会生成阵列[3, 3, 3, 3, 3], 即a的长度为5, 每个默认值都是3 获取阵列元素 我们可以使用索引来获取对应的值 123456fn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1];} 无效的阵列元素获取 对于/阵列来讲, 当你获取不存在的索引是, 有可能会出现编译通过而运行时出现错误的情况, 比如 1234567fn main() { let a = [1, 2, 3, 4, 5]; let element = a[10]; println!(\"元素的數值為：{}\", element);} 我们使用check功能发现并没有检查出错误 123➜ variables git:(master) ✗ cargo check Checking variables v0.1.0 (/Users/Work/Code/Rust/student/variables) Finished dev [unoptimized + debuginfo] target(s) in 0.12s 但是当我们运行时, 当执行到这里时, rust会抛出错误, 而对于其他的底层语言(例如C), 则不会报错但是会得到不可预料的值, rust这样做减少了不可预料的BUG的产生, 这是Rust的安全原则之一 123456789101112131415➜ variables git:(master) ✗ cargo run Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables)error: index out of bounds: the len is 5 but the index is 10 --&gt; src/main.rs:4:19 |4 | let element = a[10]; | ^^^^^ | = note: `#[deny(const_err)]` on by defaulterror: aborting due to previous errorerror: could not compile `variables`.To learn more, run the command again with --verbose.","link":"/2021/09/04/rust_programming_language(2)/"},{"title":"Rust程序设计语言(3)","text":"函数 函数在rust中无处不在, 对于rust程序来讲, main函数是许多程序的入口, 之前我们知道, 建立一个函数的关键字是 fn rust使用下划线命名法来命名, 这个之前也有提到过 我们来看下面的程序 123456789fn main() { println!(\"Hello, world!\"); another_function();}fn another_function() { println!(\"hello another_function!\");} rust中, 函数的范围由 {} 指定, 也就是说, 这段代码中有两个函数, main 和 another_function, 程序的入口是 main, 在 main 中调用了 another_function, 当我们从上往下看的时候, 会发现在 another_function 未定义之前就调用了 another_function, 这样也是可以的, rust 并不会报错, 只要你存在, 不管在哪里都可以. 在函数中逻辑是从上到下执行的, 因此会先打印 Hello, world!, 在执行 another_function, another_function 中会打印 hello another_function! 123456➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 1.00s Running `target/debug/fun`Hello, world!hello another_function! 函数的参数 很多时候, 函数需要根据参数来进行操作, rust需要在建立函数时定义参数的名称与类型, 写在函数名后的 () 中 1234567fn main() { another_function(5);}fn another_function(x: i32) { println!(\"x = {}\", x);} 12345➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.40s Running `target/debug/fun`x = 5 对于函数 another_function 来讲, 我们设置了一个参数 x, 他是 i32 类型, 需要注意的是, 我们必须对每个参数都说明类型, 不然会导致编译错误 当某个函数的需要多个参数时, 我们这样写 12345678fn main() { another_function(1, 2);}fn another_function(x: i32, y: i32) { println!(\"x = {}\", x); println!(\"y is {}\", y);} 函数的内容包含了陈述式和表达式 函数的内容是由一系列的**陈述式(statements)和在后面的可选的表达式(expression)**组成的, rust是基于表达式的语言, 下面我们来介绍这两个的区别 陈述式是一系列动作的指令, 陈述式不回传任何数据 表达式则是通过逻辑处理来产生结果, 也就是说表达式返回数据 比如代码 123fn main() { let a = 1;} 这里的mian函数本身是一个陈述式, 因为他不返回任何数据 这里的 let a = 1; 也是一个陈述式, 因为他不返回任何数据, 因为他不返回任何数据, 所以你不能接受他的返回数据, 例如 123fn main() { let b = (let a = 1);} 这就会导致编译出错, 因为let a = 1是一个陈述式, 他不返回任何数据, 但是你试图使用返回值来作为 b 的值 而表达式则会给出结果, 比如 1+1 会返回2, 表达式可以是陈述式的一部分, 比如 let a = 1中的1就是一个表达式, 他返回了一个1, 同时我们使用{}产生的作用域也是一个表达式, 例如 12345678910fn main() { let x = 5; let y = { let x = 3; x + 1 }; println!(\"y = {}\", y);} 其中, 表达式 1234let y = { let x = 3; x + 1}; 会返回4, 此时使用 y 接收就能获得 4, 这是因为 x + 1后面并没有带上 ;, 如果你加上了 ; 则不会返回结果, 这是必须要记住的 函数返回值 函数的返回值定义是-&gt;, 写在接收参数的()后, 同样的要定义他的类型. 但是无需命名 123456789fn five() -&gt; i32 { 5}fn main() { let x = five(); println!(\"x = {}\", x);} 需要注意, five 函数里直接写了5, 但是没有跟;, 所以他会返回5, 同时 five 定义了返回值是一个, 类型是 i32 同时 main 中定义了 x 来接受 five 的返回值, 所以 x 为 5, 同时函数 five 为表达式 12345➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.57s Running `target/debug/fun`x = 5 当我们为 5 加上 ;, five 就变成了 陈述式, 此时在编译时就会报错 123456789101112131415161718➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun)error[E0308]: mismatched types --&gt; src/main.rs:1:14 |1 | fn five() -&gt; i32 { | ---- ^^^ expected `i32`, found `()` | | | implicitly returns `()` as its body has no tail or `return` expression2 | 5; | - help: consider removing this semicolonerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `fun`.To learn more, run the command again with --verbose. 当这个函数有多个返回值, 则使用()包裹 123456789fn five() -&gt; (i32, i32) { (5, 6)}fn main() { let x = five(); println!(\"x0 = {}, x1 = {}\", x.0, x.1);} 12345➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.25s Running `target/debug/fun`x0 = 5, x1 = 6 注释 一个好的程序, 注释并不可少. 多写**注释(comments)**对自己和他人都有好处 编译器在编译时会将注释部分去除, 所以不用担心会增加编译文件的大小 rust的注释使用 // , 一般会在 // 后加上一个空格 1// 这里是注释 需要注意的是, //标识改行为注释, 因此 // 后一直到本行结束之间的所有东西都被编译器认为是注释 当需要多行注释时, 为每一行都加上 // 即可 12// 注释1// 注释2 注释也可以加在某一行代码的结束 123fn main() { let x = 3; // 注释} 控制流程 在程序中, 一个流程通常有多个分支, 我们需要在某个时候根据某个条件来决定怎么做 if表达式 if表达式根据条件的不同执行不同的代码. 当满足条件时就执行这段代码, 不满足时就不执行 12345678fn main(){ let a = 5; if a &lt; 5{ println!(\"&lt;5\") }else{ println!(\"&gt;=5\") }} 这里我们判断a是否小于5, 根据不同的情况来打印不同的结果 需要注意的是, 其中某个分支的逻辑必须使用 {} 包裹 并且, a&lt;5 返回的是一个bool, rust中if表达式只能使用bool来进行判断, 加入我们将代码修改成 12345678fn main(){ let a = 5; if a{ println!(\"&lt;5\") }else{ println!(\"&gt;=5\") }} 则会导致编译失败, 这是因为a是int 而不是bool 1234567891011121314➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun)error[E0308]: mismatched types --&gt; src/main.rs:3:8 |3 | if a{ | ^ expected `bool`, found integererror: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `fun`.To learn more, run the command again with --verbose. rust并不会将其他非bool值自动转化成bool 使用 else if 处理多个情况 使用多个else if和if和else一起使用来处理多个分支 123456789101112fn main(){ let a = 5; if a == 4{ println!(\"4\") }else if a == 5{ println!(\"5\") }else if a == 5{ println!(\"51\") }else{ println!(\"not\") }} 需要注意的是, 在这个代码块中, 判断只会成功一次, 也就是说, 在这个多重判断中, 即使a可以为true两次, 也只会执行一次, 也就是只会打印5 而不是51 当你有多个分支时, 不推荐使用大量的 else if, 这样会导致代码看起来不友好, 后面会推荐使用match 在let中使用if 123456789fn main(){ let t = true; let s = if t{ 5 }else{ 6 }; println!(\"{}\", s)} 这里就是, 我们在赋值的时候, 根据t的不同来返回不同的值给s, 这里注意, 写一个数字本身就是一个表达式, 也就是说如果t为true, s就为5, 其他为6 12345➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.36s Running `target/debug/fun`5 这种写法有一个限制, 就是if的返回值必须是同一类型, s不可能有可能是int有可能是str, 例如 123456789fn main(){ let t = true; let s = if t{ 5 }else{ \"6\" }; println!(\"{}\", s)} 这种就会报错 123456789101112131415161718192021➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun)error[E0308]: `if` and `else` have incompatible types --&gt; src/main.rs:6:9 |3 | let s = if t{ | _____________-4 | | 5 | | - expected because of this5 | | }else{6 | | \"6\" | | ^^^ expected integer, found `&amp;str`7 | | }; | |_____- `if` and `else` have incompatible typeserror: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `fun`.To learn more, run the command again with --verbose. 因为rust在编译时就必须准确的知道s的类型, 但是s可能会有两种类型, 这样会导致代码有可能出现问题 循环 循环可以重复的执行某段代码 rust有三种循环: loop/while/for loop loop关键字会让rust一直重复执行代码一直到明确的要求结束 看以下代码 12345fn main(){ loop{ println!(\"a\") }} 此程序是死循环, 不停的打印字符串a, 因为没有使用关键字break, 所以不会终止循环 从循环返回 12345678910fn main(){ let mut c = 0; let r = loop{ c += 1; if c == 10{ break c*2; } }; println!(\"{}\", r)} 我们可以定义一个变量来接受某个循环的返回值 while循环 我们使用循环时, 多会使用一个大的嵌套, 比如loop{}, 其实rust中的while可以在特定的场景下减少代码, 比如 12345678fn main(){ let mut c = 4; while c != 0{ c -= 1; println!(\"{}\", c) } println!(\"OK\")} while可以与一个判断条件一起使用, 比如这里就是判断c!=0, 如果c!=0为false时则退出循环. 而在循环内则对c进行-1, 代码逻辑等同于 1234567891011fn main(){ let mut c = 4; loop { c -= 1; println!(\"{}\", c); if c == 0{ break; }; } println!(\"OK\")} for循环 使用遍历来描述for可能更为准确, for并不是死循环, 而是遍历完成就结束 123456fn main(){ let c = [1, 2, 3, 4]; for i in c.iter(){ println!(\"{}\", i) }} 这里我们遍历c这个数组, 注意c.iter()可以生成一个range, 每次抛出c的一个元素, 使用for可以防止索引超出范围 12345678➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.42s Running `target/debug/fun`1234 再比如 123456fn main(){ let c = [1, 2, 3, 4]; for i in c.iter().rev(){ println!(\"{}\", i) }} rev方法可以翻转一个range, 因此会输出4-1 12345678➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.32s Running `target/debug/fun`4321 练习 编写程序实现摄氏度与华氏度之间的转换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455use std::io; // 引入标准库fn main(){ loop { println!(\"选择转换模式: 1: 摄氏度转华氏度 2: 华氏度转摄氏度 其他任意键: 退出 &gt;&gt;&gt;\"); let mut model = String::new(); io::stdin().read_line(&amp;mut model).expect(\"读取失败\"); // 如果获取错误打印警告 if model.trim() == \"1\"{ println!(\"输入你要转换的摄氏度&gt;&gt;&gt;\"); let mut c = String::new(); io::stdin().read_line(&amp;mut c).expect(\"读取失败\"); // 如果获取错误打印警告 let c: f32 = match c.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; { println!(\"输入了一个无法解析的字符串\"); continue; }, }; let f = transformation_centigrade(c); println!(\"摄氏度:{}对应的华氏度是:{}\", c, f); } else if model.trim() == \"2\"{ println!(\"输入你要转换的华氏度&gt;&gt;&gt;\"); let mut f = String::new(); io::stdin().read_line(&amp;mut f).expect(\"读取失败\"); // 如果获取错误打印警告 let f: f32 = match f.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; { println!(\"输入了一个无法解析的字符串\"); continue; }, }; let c = transformation_fahrenheit_degree(f); println!(\"华氏度:{}对应的摄氏度是:{}\", f, c); } else{ println!(\"exit.\"); break; } }}// 华氏度2摄氏度fn transformation_fahrenheit_degree(f: f32) -&gt; f32{ return (f-32.0)/1.8;}// 摄氏度2华氏度fn transformation_centigrade(c: f32) -&gt; f32{ return 32.0+c*1.8;} 运行 12345678910111213141516171819202122232425262728➜ fun git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/fun`选择转换模式: 1: 摄氏度转华氏度 2: 华氏度转摄氏度 其他任意键: 退出 &gt;&gt;&gt;1输入你要转换的摄氏度&gt;&gt;&gt;222摄氏度:222对应的华氏度是:431.59998选择转换模式: 1: 摄氏度转华氏度 2: 华氏度转摄氏度 其他任意键: 退出 &gt;&gt;&gt;2输入你要转换的华氏度&gt;&gt;&gt;4444华氏度:4444对应的摄氏度是:2451.111选择转换模式: 1: 摄氏度转华氏度 2: 华氏度转摄氏度 其他任意键: 退出 &gt;&gt;&gt;qexit. 生成 n 阶斐波那契数列 123456789101112131415161718192021222324252627282930313233343536use std::io; // 引入标准库fn main(){ loop { println!(\"输入期望的n&gt;&gt;&gt;\"); let mut n = String::new(); io::stdin().read_line(&amp;mut n).expect(\"读取失败\"); let n: usize = match n.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; { println!(\"输入了一个无法解析的字符串\"); continue; }, }; let mut c: usize = 0; let mut s0 = 0; let mut s1 = 1; println!(\"结果: \"); loop{ if c == n{ break; }; let mut f = 0; if c == 0{ f = 0; }else{ f = s0+s1; } s0 = s1; s1 = f; c+=1; print!(\"{} \", f) } println!(\"\") }} 运行 123456789101112131415161718192021➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun)warning: value assigned to `f` is never read --&gt; src/main.rs:23:21 |23 | let mut f = 0; | ^ | = note: `#[warn(unused_assignments)]` on by default = help: maybe it is overwritten before being read? Finished dev [unoptimized + debuginfo] target(s) in 0.48s Running `target/debug/fun`输入期望的n&gt;&gt;&gt;3结果: 0 1 1 输入期望的n&gt;&gt;&gt;1结果: 0 打印歌曲 “The Twelve Days of Christmas” 的歌词, 使用循环 1234567891011121314151617181920212223fn main(){ let days = [\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\", \"tenth\", \"eleventh\", \"twelfth\"]; let gift = [\"a partridge in a pear tree\", \"two turtle doves\", \"three French hens\", \"four calling birds\", \"five golden rings\", \"six geese a-laying\", \"seven swans a-swimming\", \"eight maids a-milking\", \"nine ladies dancing\", \"ten lords a-leaping\", \"eleven pipers piping\", \"twelve drummers drumming\"]; let mut n = 0; println!(\"The Twelve days of Christmas\"); for d in days.iter(){ print!(\"On the {} day of Christmas, my true love sent to me: \", d); let mut gi = n; loop{ if gi != 0{ print!(\"{}, \", gift[gi]); gi -= 1; }else if n == 0{ print!(\"{} \\n\", gift[gi]); break; }else{ print!(\"and {} \\n\", gift[gi]); break; } }; n += 1 };} 运行 12345678910111213The Twelve days of ChristmasOn the first day of Christmas, my true love sent to me: a partridge in a pear tree On the second day of Christmas, my true love sent to me: two turtle doves, and a partridge in a pear tree On the third day of Christmas, my true love sent to me: three French hens, two turtle doves, and a partridge in a pear tree On the fourth day of Christmas, my true love sent to me: four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the fifth day of Christmas, my true love sent to me: five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the sixth day of Christmas, my true love sent to me: six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the seventh day of Christmas, my true love sent to me: seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the eighth day of Christmas, my true love sent to me: eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the ninth day of Christmas, my true love sent to me: nine ladies dancing, eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the tenth day of Christmas, my true love sent to me: ten lords a-leaping, nine ladies dancing, eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the eleventh day of Christmas, my true love sent to me: eleven pipers piping, ten lords a-leaping, nine ladies dancing, eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the twelfth day of Christmas, my true love sent to me: twelve drummers drumming, eleven pipers piping, ten lords a-leaping, nine ladies dancing, eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree","link":"/2021/09/04/rust_programming_language(3)/"},{"title":"Rust程序设计语言(4)","text":"认识所有权 所有权系统是Rust最为独特的性质, 他让Rust无需垃圾回收即可保障内存的安全. 所以, 理解所有权怎么工作是非常重要的, 本章, 我们将讲到所有权和相关的功能, 借用, slice以及Rust如何在内存中放置数据 什么是所有权 rust的核心之一就是所有权 对于运行中的程序来说, 他必须对使用的内存进行管理, 同时对于运行中产生的垃圾, 程序也需要进行销毁, 以免出现内存泄露等问题 某些语言自带了垃圾回收机制, 在程序运行时不断的扫描寻找不再使用的内存将其释放 另一些语言要求程序员通过代码来自己分配和释放内存 而rust使用的是第三种, 通过所有权系统来管理内存, 编译器在编译时会根据规则来进行检查. 在运行时可以保证不会减慢程序的运行速度 栈(stack)与堆(heap) 栈和堆都是在程序运行中可供使用的内存, 他们的结构并不相同, 栈是有序的, 他就像一个水桶, 最上面的是栈顶, 向这个栈里存放数据叫做进栈, 他像一个水桶, 所以存储数据只能存放在水桶的最上面, 当移除数据**(出栈)的时候, 也只能从栈顶移除, 所以, 栈遵循先进后出**的逻辑. 栈中的所有数据都必须占用已知且固定的大小, 而且栈中的数据是有大小限制的, 所以在程序运行中出现的大小未知或者可能变化的数据, 必须存储在堆上, 堆不是有序的, 当你向堆中存储一个数据, 操作系统首先在堆的某处找到一块足够大的空间, 把它标记为已使用, 然后回传该空间的指针, 这个过程叫做在堆上分配内存, 指针的大小是已知且固定的 所以可以把真正的数据存储在堆中, 将指针存放在栈中, 当需要访问真实数据时, 先获取指针, 再访问指针 入栈比在堆上分配内存快, 这是因为栈在建立时每一块数据的大小是固定的, 而且是有序的, 操作系统无需为新数据去搜索合适的内存空间. 当在堆上分配内存时, 系统需要先找到一块足够大的内存, 然后做记录 访问堆上的数据也比访问栈的数据慢, 堆上面的数据通过指针访问, 现代处理器在内存中跳转越少速度就越快(缓存), 而堆是无序的, 意味着指针指向的地方可能需要很多次内存跳转 同样的, 因为这个原因, 处理器在处理数据彼此相近的时候(比如栈)比远的时候(堆)效率更高. 在堆上分配大量空间也会消耗时间. 当代码调用一个函数时, 会将函数的值和函数内部的局部变量压入栈中, 当这个函数结束时, 这些数据就属于垃圾, 理应被回收, 此时则出栈, 因为栈是后进先出, 导致这种回收是快速的, 符合逻辑的, rust的所有权就是这样做的 跟踪哪部分代码正在使用哪些数据, 最大限度的减少堆上重复数据的数量, 同时清理堆上不再使用的数据, 这些就是所有权系统需要去关心的 12345678910111213// 假设一个抽象的栈 []{ A; // A入栈, [A] B; // B入栈, [B, A] { a; // a入栈, [a, B, A] b; // b入栈, [b, a, B, A] }; // 函数结束了, a和b是垃圾了, 将a和b出栈, 直接取栈顶的的一段即可,保证效率的同时也符合逻辑(代码从上往下执行的顺序), [b, a, B, A] -&gt; [B, A] C; // C入栈, [C, B, A] D; // D入栈, [D, C, B, A]} 所有权的基本规则 Rust中的每一个值都有且只有一个被称为其 所有者 的变量 值在任一时刻有且只有一个所有者 所有者离开作用域时, 这个值将会被丢弃 变量作用域 每个变量都有其作用域(scope), 作用域是一个**项(item)**在程序中有效的范围 1let s=\"hello\"; 这里的变量s绑定到了字符串hello中, 这个字符串编码进了程序代码中, 那么s从声明开始到当前作用域结束时都是有效的 12345fn main() { // s未声明 let s = \"hello\"; // s在这里生效 // 可以使用s}// 函数结束, 作用域也结束, s无法使用了 这里有两个关键点 s进入作用域时, s是有效的 s离开作用域, s无效 String类型 上面的例子来说, s因为是不可变的, 加上其数据很小, 所以本体存储在栈中 本次测试将把数据的本体放置在堆中, 而将指针放置在栈中 我们这里使用String作为例子, 专注于String与所有权相关部分. 对于在编译时无法知道具体的值的变量, 也就是说并不知道大小, 他就会被分配到堆上, 比如String 1let s = String::from(\"hello\"); 这里的::是运算符, 具体的详情我们在之后的章节说明. 12345fn main() { let mut s = String::from(\"hello\"); s.push_str(\", world\"); // 在s后拼接字符串 println!(\"{}\", s); // hello, world} 这里得到的s是可变的, 他可以通过调用 push_str 函数来修改自己 内存与分配 对于字符串字面值来说, 我们在编译时就能准确的知道其内容, 所以直接硬编码进最终的可执行文件中, 这使得字符串字面值快速且高效. 这里的前提是字符串字面值的不可变性, 但是, 对于未知的文本, 我们无法在开始时确定大小, 因为他是可以改变的. 对于string类型, 为了让他可以支持一个可变的, 可增长的文本片段, 需要在堆上分配一块在编译时未知大小的内存存放数据, 这就有两个问题 必须在运行时向操作系统请求内存 当string处理完成后将内存返回给操作系统 如何在运行时请求内存呢? 当我们调用String::from 时, 他会请求所需要的内存 如何在处理完成后将内存返给操作系统呢? 在有垃圾回收GC的语言中, GC会记录和清理不再使用的内存, 作为开发者我们不需要关心他, 没有GC则需要开发者手动的释放, 就跟请求一样需要我们写在代码中, 正确的处理内存回收通常比较困难, 如果忘记回收会浪费内存, 导致内存泄露等. 如果回收过早, 可能会在后续的使用中出现无效变量, 如果重复回收也可能会导致问题, 所以要准确的在合适的地方对一个分配(allocate)配对一个释放(free) 在Rust中, 内存在拥有他的变量离开作用域时就被自动释放, 例如下面的例子 123456{ let mut s = String::from(\"hello\"); // 创建s, s此时是有效的, 在此作用域中 s.push_str(\", world\"); // 使用修改s, 在s后拼接字符串 println!(\"{}\", s); // hello, world} // 该作用域已结束, 作用域内的使用的内存需要释放// s失效了 这里, 当s离开当前有效的作用域时, Rust为我们自动调用函数drop (前提是该数据类型有drop), 该函数可以将变量释放, Rust会在结尾}自动调用 需要释放的变量的drop 变量与数据交互: 移动 如果我们将一个变量赋值给另一个变量, 其数据会怎么处理呢? 123let x = 5; // x为5let y = x; // copy x的值5, 赋值给y// x和y都等于5 因为5是在编译时就可以确定的, 所以这两个5被放入了栈中 那么对于无法确定大小的变量来说, 例如 12let s1 = String::from(\"s1\");let s2 = s1; 之前说过, 对于不可预测的变量, 我们会在栈上存储指针而在堆上存储真正的数据, 那么对于s1来说, 在栈上的数据为 name value ptr(指针) 堆上的地址 len(长度) 2 capacity(容量) 2 指针指向的堆的数据为 index value 0 s 1 1 这就是将s1绑定给变量s1在内存中的表现形式 我们注意到, 栈上的数据有 长度 和 容量, 长度指的是当前使用了多少字节的内存, 容量指的是从操作系统申请了多少字节的内存, 这两个是不一样的, 不要混淆 而我们将s1赋值给s2时, 实际上只是从拷贝了s1在栈上的数据, 也就是说此时 s1与s2共同指向了一个堆地址, 这跟其他语言的浅COPY(shallow copy)非常像, 这样做的好处是使操作变得快速, 如果是深COPY(deep copy), 意味着需要将堆上的数据找到,再插入到堆的另一个地方, 如果堆上的值很大, 则会造成效率的低下 但是这样会导致问题出现, 例如当s1与s2离开了作用域时, Rust 会对s1和s2进行清理, 但是他们实际上指向了同一个地址, 两次清理一个内存, 这就会出现前文提到的二次释放(double free)问题, 因此, Rust使用了不同的方法, 即移动(move), 就是在运行 s2=s1 时, 将s1无效化 123456fn main() { let s1 = String::from(\"s1\"); // 创建s1 let s2 = s1; // 将s1栈上的数据转移到s2上, s1失效了 println!(\"{}\", s1); // s1不可用, 所以会出错 println!(\"{}\", s2); // s2可用} // drop时, 先处理s2的Drop再s2的栈, s1无了, 只清理s1的栈 运行该代码时, 会出错 1234567891011121314error[E0382]: borrow of moved value: `s1` --&gt; src/main.rs:4:20 |2 | let s1 = String::from(\"s1\"); | -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait3 | let s2 = s1; | -- value moved here4 | println!(\"{}\", s1); | ^^ value borrowed here after moveerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0382`.error: could not compile `ownership`. Rust禁止你使用无效的引用 所以, Rust在处理这个s2 = s1时, 先将s1的栈数据复制一份给s2, 然后将s1置空, 这样就解决了二次释放的问题 需要知道的是, Rust的设计原则是: 永远不会自动创建数据的深拷贝, 这是出于对性能影响的考虑 变量与数据交互: 克隆 如果你确实需要进行深copy, 你可以使用内置函数clone 123456fn main() { let s1 = String::from(\"s1\"); // 创建s1, s1进入作用域 let s2 = s1.clone(); // s1的堆数据复制为另一份, 然后重新生成栈数据, 指向新的堆数据, s2进入作用域 println!(\"{}\", s1); // 未发生转移, s1还是可用的 println!(\"{}\", s2); // s2可用} // drop时, s1和s2的堆数据并不是一个, 所以没有二次释放的问题, 先进后出所以先清理s2 必须要注意的是, 这样会对资源和性能造成一定的损耗, 在确保你必须这样做时才需要进行克隆操作 只在栈上的数据: 拷贝 而对于只在栈上保存的数据, 也就是在编译时就知道值的数据来说, 不存在转移和克隆, 因为他是只保存在栈上, 所以进行拷贝速度很快,Rust在处理这种数据的赋值时直接copy栈的数据到另一个变量, 所以两个变量都可用 12345fn main() { let s1 = 1; // 创建s1, 进入作用域 let s2 = s1; // 拷贝s1的栈数据生成s2, s2进入作用域 println!(\"{},{}\", s1, s2) // s1与s2都可以使用} // i32没有drop, 根据先进先出, 清理s2再s1 怎么分辨什么是会出现移动的呢, Rust有一个叫做Copy的trait的特殊注解, 如果某个类型拥有这个注解, 那么旧的变量在赋值给新的变量后依旧可用. 如果一个类型有Drop注解, 那么他就无法使用Copy注解. 他们是无法共存的. 什么类型是Copy的呢? 可以查看对应的文档. 一般的, 任何简单标量值的组合可以是Copy的, 不需要分配内存或者某种形式的资源类型是Copy的, 比如 所有整数类型 布尔类型 所有浮点类型 字符类型, char 元组, 当其包含的类型都是Copy时 drop与内存释放的关系 这里是本人记录的 需要注意的是, Rust释放内存有两种 如果是有drop注解的数据类型(例如String), 先执行drop方法,再将栈数据删除 而没有drop注解的数据类型(例如i32), 直接将栈数据删除 为什么drop与copy注解不能兼容 这里是本人记录的 我们知道, copy注解代表着该数据类型并不会发生转移, 也就是说发生 s1 = s2 时,s2 依旧存在, 在内部逻辑中是Copy一份栈数据, 有copy 的数据类型一般只将数据放置在栈上, 在退出作用域时, 只需要清理栈数据即可, 而拥有drop的数据类型, rust会优先调用drop方法, 一般来讲, drop 一般是清理堆的有关数据, copy的不需要清理, 所以为了保持统一, 就规定了两者不兼容 如果某个类型同时拥有Copy和Drop注解的话, 首先拥有Drop一般都需要将数据本体放置进堆, 那样在重复赋值时又有Copy会Copy一份栈数据, 就造成了两个变量实际上指向了同一个资源, 在清理时就会发生二次释放的问题 所有权与函数 123456789101112131415161718fn main() { let s = String::from(\"s\"); // 创建s, 进入作用域 takes_ownership(s); // s转移进了函数takes_ownership的some_string中 println!(\"{}\", s); // 这里会报错, 因为s已经转移, s不可用了 let i = 5; // i进入作用域 makes_copy(i); println!(\"{}\", i); // i可用, 因为i是存储在栈上, 有`Copy`直接复制一份进makes_copy的some_integer} // s和i退出作用域, 栈是先进后出, 所以先清理i, i没有`Drop`所以直接删除栈, s已经被转移所以不做特殊操作fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(\"{}\", some_string);} // some_string 移出作用域并调用`drop`方法。占用的内存被释放fn makes_copy(some_integer: i32) { // some_integer 进入作用域 println!(\"{}\", some_integer);} // 将 some_integer 释放, 因为i32没有`drop`注解所以只清理栈数据 返回值与作用域 如果函数是拥有返回值, 如果返回值是drop, 则会将返回值移动给返回值的接收者, 如果是copy, 则是copy给返回值 变量的所有权总是遵循相同的模式: 将值付给另一个变量时移动他. 当持有堆中数据值的变量离开作用域时, 堆中值会通过drop被清理, 除非数据被移动到另一个变量 看下面代码 1234567891011121314151617181920212223fn main() { let s1 = gives_ownership(); // s1接受返回值, 进入作用域 let s2 = String::from(\"s2\"); // 创建s2, 进入作用域 let s3 = takes_and_gives_back(s2); // s2传入takes_and_gives_back函数, s2转移给该函数的a_string, 随后s3接受返回值, 进入作用域 println!(\"{}\", s2); // 这里s2已经发生转移, 指针为空, 所以使用会报错 println!(\"{}, {}\", s1, s3); // s1和s3可用} // 退出作用域, 清理s3&gt;s2&gt;s1// s2为空fn gives_ownership() -&gt; String { let some_string = String::from(\"gives_ownership\"); some_string // 如果这里返回了, 而返回值是String类型, 有Drop注解, 会发生所有权的移动, 移动给接受者, some_string失效了} // some_string 移除作用域, 因为 some_string 已经转移所以只删除栈fn takes_and_gives_back(a_string: String) -&gt; String { a_string // 如果这里返回了, 而返回值是String类型, 有Drop注解, 会发生移动, 移动给接受者, a_string失效了} // a_string 移除作用域, 因为 a_string 已经转移所以只删除栈 这样就会出现一个问题, 如果某个变量是拥有Drop的, 那么这个变量需要作为某个函数的参数使用, 我们传入到这个函数中总会使原有的变量失效, 那么如果我还需要再使用这个变量呢? 有一个折中的办法, 在函数中再将参数值传出, 例如 123456789101112fn main() { let s1 = String::from(\"s1\"); let (s2, len) = calculate_length(s1); // s1转移了, 用s2接受原来的s1 println!(\"The length of '{}' is {}.\", s2, len);}fn calculate_length(s: String) -&gt; (String, usize) { let length = s.len(); // len() 返回字符串的长度 (s, length) // 将s也返回} 但是这样太LOW了, 为了解决这样的问题, Rust提供了引用(references) 引用和借用 引用可以在不转移所有权的情况下使用变量 12345678910fn main() { let s1 = String::from(\"hello\"); // s1进入作用域 let len = calculate_length(&amp;s1); // 将 &amp;s1 传入, &amp;意思是引用, 即将s1的引用传入函数calculate_length println!(\"The length of '{}' is {}.\", s1, len); // 仍可以使用s1, 因为未发生所有权转移}fn calculate_length(s: &amp;String) -&gt; usize { // 因为类型变成了String的引用, 所以接收参数类型发生变化 s.len()} &amp;代表对某个引用, 引用允许你使用值但不获取其所有权, 比如上面的 s1, 当 s1传入到 calculate_length 的参数 s 时, 实际上s是 s1 的引用, 类似于指针, 指向了s1 与&amp;(引用)相反的操作是解引用(dereferences), 他的运算符是 *, 之后会讲到 &amp;s1 让我们创建一个指向s1的引用, 但是并不拥有他, 因为不拥有他, 所以当引用离开作用域时其指向的值也不会被清理 在 calculate_length 结束时, s离开作用域, 理应清理, 但是因为s只是个引用类型, 所以只把s清理并不会清理s对应的真正的变量 对于函数 calculate_length 来说, 其接受了String的引用, 这种行为被称为 借用 需要注意的是, 如果你借用了某个变量, 那你 默认情况下 是无法修改这个变量的值的 123456789fn main() { let mut s = String::from(\"hello\"); change(&amp;s);}fn change(some_string: &amp;String) { some_string.push_str(\", world\"); // 尝试追加字符串} 会报错 123456789101112error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference --&gt; src/main.rs:8:5 |7 | fn change(some_string: &amp;String) { | ------- help: consider changing this to be a mutable reference: `&amp;mut std::string::String`8 | some_string.push_str(\", world\"); // 尝试追加字符串 | ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutableerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0596`.error: could not compile `ownership`. 提示你无法修改他, 当然这是默认情况下 可变引用 某些情况下可以修改引用的值, 我们修改代码成 12345678910fn main() { let mut s = String::from(\"hello\"); change(&amp;mut s); // &amp;mut 表示是可变的引用 println!(\"{}\", s) // hello, world}fn change(some_string: &amp;mut String) { // 同样的参数类型也要 mut some_string.push_str(\", world\"); // 尝试追加字符串} 这样即可运行, 但是注意, 可变引用有几个限制 在特定作用域的特定数据只能有一个可变引用 例如以下代码 123456fn main() { let mut s = String::from(\"hello\"); let r1 = &amp;mut s; let r2 = &amp;mut s; // 错误, 因为s的 &amp;mut 同时只能出现一个 println!(\"{},{}\", r1, r2);} 会报错 1234567891011121314error[E0499]: cannot borrow `s` as mutable more than once at a time --&gt; src/main.rs:4:14 |3 | let r1 = &amp;mut s; | ------ first mutable borrow occurs here4 | let r2 = &amp;mut s; | ^^^^^^ second mutable borrow occurs here5 | println!(\"{},{}\", r1, r2) | -- first borrow later used hereerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0499`.error: could not compile `ownership`. 这是为了避免出现数据竞争的问题, 数据竞争通常由这三种行为造成: 两个或多个指针同时访问一个数据 至少一个指针写入数据 没有同步数据的机制 数据竞争可能导致出现BUG, 并且让开发者难以定位和解决问题, 所以Rust在编译时会检查这个问题 当然, 这个限制只是存在于同一个作用域, 例如下面的代码是可以的 1234567fn main() { let mut s = String::from(\"hello\"); { let r1 = &amp;mut s; } // 可变引用r1退出作用域 let r2 = &amp;mut s; // 可以重新创建} 在特定作用域的特定数据不能同时拥有可变和不可变引用 12345678910fn main() { let mut s = String::from(\"hello\"); let r1 = &amp;s; // 不可变1 let r2 = &amp;s; // 不可变2 let r3 = &amp;mut s; // 可变1 println!(\"{}, {}, and {}\", r1, r2, r3); // 会报错, 因为不可变与可变引用无法共存 } 报错 12345678910111213141516error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --&gt; src/main.rs:6:14 |4 | let r1 = &amp;s; // 不可变1 | -- immutable borrow occurs here5 | let r2 = &amp;s; // 不可变26 | let r3 = &amp;mut s; | ^^^^^^ mutable borrow occurs here7 | 8 | println!(\"{}, {}, and {}\", r1, r2, r3); | -- immutable borrow later used hereerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0502`.error: could not compile `ownership`. 两者不能共存, Rust认为如果你使用了不可变引用. 你一定不希望他在某些时候变化, 所以禁止共存, 但是对于多个不可变引用, 是可以的. 因为都是读取, 就是安全的, 没有办法影响到别人, 所以可以一个作用域可以有多个不可变引用存在 标题所言的是特定作用域, 对于引用来说, 他的作用域从声明的地方开始到最后一次使用为止. 如果声明未使用, 那么只存在于声明的那一行, 当然最好不要声明却不使用, 这是不好的习惯 123456789fn main() { let mut s = String::from(\"hello\"); let r1 = &amp;s; // 不可变1, 未使用 let r2 = &amp;s; // 不可变2, 未使用 let r3 = &amp;mut s; // 可变1, 使用 println!(\"{}\", r3); // 这里已经超出了r1和r2的作用域, 因为r1/r2未使用, 作用域只有生成的一行} 12345678910fn main() { let mut s = String::from(\"hello\"); let r1 = &amp;s; // 不可变1, 未使用 let r2 = &amp;s; // 不可变2, 未使用 println!(\"{},{}\", r1, r2); // 这里是r1/r2最后一次使用, r1/r2作用域到此结束 let r3 = &amp;mut s; // 可变1, 使用 println!(\"{}\", r3); // 可使用, 当前作用域无不可变引用} 垂悬引用 垂悬指针指的是指针指向的内容已经被分配给了其他的持有者. 在Rust中, 编译器确保了永远不会出现这个问题, 因为当你拥有引用时, 编译器会确保数据不会在其引用之前离开作用域 12345678910fn main() { let res = dangle(); // 接收返回的引用 println!(\"{}\", res);}fn dangle() -&gt; &amp;String { let s = String::from(\"hello\"); // s进入作用域 &amp;s // 将s的引用返回} // 函数结束, s的数据会被清理, 但是s的引用返回出去了 这里的 res 是函数 dangle 内部生成的变量的引用, 但是该函数内部的变量会结束后销毁, 此时你获取到的引用就是错误的, 就会发生悬垂引用的问题, Rust会在编译时予以拦截 123456789101112error[E0106]: missing lifetime specifier --&gt; src/main.rs:6:16 |6 | fn dangle() -&gt; &amp;String { | ^ help: consider giving it a 'static lifetime: `&amp;'static` | = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed fromerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0106`.error: could not compile `ownership`. 如果有这样的需求, 你应该直接返回变量, 而不是他的引用, 这样会发生所有权的移动 12345678910fn main() { let res = dangle(); // 接收返回 println!(\"{}\", res);}fn dangle() -&gt; String { let s = String::from(\"hello\"); // s进入作用域 s // 将s返回} // 函数结束, s触发了所有权的移动 slices slice是没有所有权的. slice允许你引用集合中某一短连续的元素序列, 而不引用整个集合 假设有这样的需求, 写一个函数, 接受一个字符串, 返回字符串中的第一个单词. 如果函数在该字符串中没有找到空格, 那么这整个就是一个单词, 如果有空格, 则第一个空格前的是一个单词 初版代码如下 123456789101112fn first_word(s: &amp;String) -&gt; usize { // 接收引用, 返回索引 let bytes = s.as_bytes(); // 转换成bytes元组 for (i, &amp;item) in bytes.iter().enumerate() { // 生成迭代器并循环他 // i是当前遍历到的索引, &amp;item是当前内容的引用 if item == b' ' { // 如果遇到了空格 return i; // 将索引return } } // 如果没有找到, 证明全部都是一个单词, 所以返回整体的索引 s.len()} s是原本的字符串的引用, 因为我们并不需要该字符串的所有权 我们返回的是该字符串中第一个单词的索引 .as_bytes()是将字符串转换成bytes元组, .iter()是返回里面的每一个值, 而.enumerate() 则是接收.iter()返回的值进一步包装. 返回一个元组, 分为索引和值的引用, 当当前字节为空格的时候, 证明需要返回了, 单词结束, 于是将索引直接返回, 当遍历完也没有的时候证明整个字符串都是一个单词, 此时将整个长度返回 这样看起来没什么问题, 但是这里返回的索引长度其实与我们传入的s不是绑定的, 我们在开发中可能遇到这样的问题, 在某一个地方求出结果, 在后面调用时发现不匹配, 原来是源数据被改动了, 例如 1234567fn main(){ let mut s = String::from(\"word\"); let k = first_word(&amp;s); s.clear(); // 这里调用clear方法, 会获取s的可变引用, 字符串变成初始值, 也就是空串 println!(\"{}\", k) // k依旧是原来的\"word\"时的结果 // 后续中使用 k 就会出现问题, 因为s已经变更} 因为 first_word 虽然需要了s的不可变引用, 但是返回值是普通的数字, 与s无关, 所以执行 first_word 之后不可变引用退出作用域了, 所以可以在 clear 里顺利的申请可变引用, 从而修改值 字符串slice 字符串slice是String中一部分值的引用 123456fn main(){ let s = String::from(\"hello world\"); let h = &amp;s[0..5]; let w = &amp;s[6..11]; println!(\"h={},w={}\", h, w)} 如上面的代码. &amp;s[0..5]代表引用了s的索引0-5之间的内容, 语法是[start_index..end_index], start_index是slice中的开始索引, end_index是slice中最后一个位置的后一个值索引. 例如[0..5]实际上是s的索引0到索引4, 也就是字符串hello的引用, 我们运行查看结果 1h=hello,w=world 这种方法不是引用整个字符串, 而是字符串中的某一段 Rust的..range语法, 还有多种简略写法 如果从索引0开始, 可以忽略0, 可以达到一样的效果 1234let s = String::from(\"hello\");let slice = &amp;s[0..2]; // helet slice = &amp;s[..2]; // he 如果一直到索引最后, 也可以舍弃尾部的数字 123456let s = String::from(\"hello\");let len = s.len();let slice = &amp;s[3..len]; // llolet slice = &amp;s[3..]; // llo 如果是同时舍弃开头和结尾, 则是将整个字符串获取 123456let s = String::from(\"hello\");let len = s.len();let slice = &amp;s[0..len]; // hellolet slice = &amp;s[..]; // hello 我们将之前的代码修改为新的字符串slice引用的方式, 之后会解释为什么这样做 12345678910fn first_word(s: &amp;String) -&gt; &amp;str { let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return &amp;s[..i]; // 返回s的引用, 从0到当前空格的索引 } } &amp;s[..] // 全部都是一个单词, 就把整个返回} 那么这样写的好处是什么呢? 回忆一下借用的规则, 当某个值已经有不可变引用时, 无法生成可变引用了, 对于s来讲, 函数 fiest_word 返回的是s的不可变引用, 而后我们在尝试改变s的值的时候.clear()尝试申请s的可变引用, 这样就会导致编译时出现问题, 避免出现BUG, 我们按照之前的调用, 尝试 .clear() 12345678910111213141516error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --&gt; src/main.rs:17:5 |15 | let word = first_word(&amp;s); | -- immutable borrow occurs here16 | 17 | s.clear(); | ^^^^^^^^^ mutable borrow occurs here18 | 19 | println!(\"the first word is: {}\", word); | ---- immutable borrow later used hereerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0502`.error: could not compile `ownership`. 会在编译器就报错, 防止出现BUG 字符串字面值其实就是slice 原来在Rust中, 直接给变量赋值字符串 1let s = \"s\"; 这里, s类型就是 &amp;str, 他是一个指向程序特定内部位置的slice, 所以他是不可变的, 因为就是不可变引用 字符串slice作为参数 修改后的获取单词函数定义是 1fn first_word(s: &amp;String) -&gt; &amp;str {} 而更好的方式是定义为 1fn first_word(s: &amp;str) -&gt; &amp;str {} 这样的目的是提高兼容性, 上面说了, 使用let s = \"s\"; 类型是 &amp;str, 所以新写法可以兼容这种字符串, 当然对于String类型, 我们可以通过转化成slice来使用 12345678910111213141516fn main() { let my_string = String::from(\"hello world\"); // first_word 中传入 `String` 的 slice let word = first_word(&amp;my_string[..]); let my_string_literal = \"hello world\"; // 因为字符串字面值就是字符串 slice， // 这样写也可以，即不使用 slice 语法！ let word = first_word(my_string_literal); // &amp;str 也可以继续的生成 slice let word = first_word(&amp;my_string_literal[..]);} 其他类型的slice 字符串slice里面存放的是字符串, 其实其他类型也是可以的 12let a = [1, 2, 3, 4, 5];let b = &amp;a[..2]; 那么这个slice的类型就是 &amp;[i31], 使用方法与字符串slice并无区别, 你可以对索引集合使用slice, 具体的信息会在之后详解 总结 所有权到这里就结束了, 所有权, 借用和slice可以让Rust程序变得更加的安全, 当你耐心的看到这里, 可能你对Rust的独特的编程思想有了大致的理解 Rust设置了诸多限制, 并且希望你写出故意设卡(qia)的代码, 目的是让程序更加安全, 在编译期就把可能出现的问题暴露出来, 让你去主动解决, 而不是在运行时, 或者是生产环境中才出现问题. 这需要开发者时刻留意遵循Rust的规范, 但是这一切都是值得的. 而Rust的所有权系统, 让你无需关注垃圾的回收, 当然搭配作用域/引用/借用一起使用需要开发者关注变量的使用和作用域","link":"/2021/09/04/rust_programming_language(4)/"},{"title":"Rust程序设计语言(5)","text":"结构体使用结构体来组织关联数据 golang里有同样的类型, 学到这里感觉有点舒服了 struct, 是一个自定义的数据类型, 其中可包含若干个值, 从而形成适合你业务的组合, 比如go的struct(结构体) 定义和实例化 结构体的每一个部分可以是不同的类型, 跟元组不同的是, 结构体需要对每一个数据进行命名, 这是为了定义这个值, 也是为了给这个值声明意义. 因为有了这些名字, 使得结构体比元组更加灵活, 不需要依赖顺序来方式实例中的某一个值, 而是通过其名字. 定义结构体的关键字是 struct, 后面是这个结构体的名字, 一般情况下结构体的名字都应该能体现出这个结构体的作用, 在 {} 中每一个部分, 都被称为一个字段(field) 123456struct User { name: String, // 用户名 email: String, // 邮箱 age: u64, // 年龄 active: bool, // 活跃状态} // 结构体 User, 代表用户信息 要使用结构体, 我们就需要实例化, 创建实例时需要指定要实例化的结构体是哪个, 并在 {} 内使用 key: value 的形式对某个字段赋值, 注意这里的字段顺序可以与定义结构体时的字段顺序不同 123456let user1 = User { name: String::from(\"user1\"), age: 23, active: false, email: String::from(\"user1@outlook.com\")}; 我们也可以在实例化后修改字段的值, 此时这个实例应当是可变的 1234567let mut user1 = User { name: String::from(\"user1\"), age: 23, active: false, email: String::from(\"user1@outlook.com\")}; // mut 可变user1.age = 24 // 通过 .key 的方式来找到值 也可以将实例作为表达式的返回值 12345678fn build_user(name: String, email: String) -&gt; User{ User{ name: name, email: email, active: false, age: 18 }} // 返回结构体 User 的实例 注意, 当变量或者参数名和类型与结构体的字段完全一致时, 可以使用简略的写法 123456789fn build_user(name: String, email: String) -&gt; User{ let active = false; User{ name, // name: name, User的字段name与参数name一致 email, // email: email, User的字段email与参数email一致 active, // active: active, User的字段active与变量active一致 age: 18 }} 我们也可以借用已经存在的实例的某些字段创建新的实例 123456789101112let user1 = User { name: String::from(\"user1\"), age: 23, active: false, email: String::from(\"user1@outlook.com\")}; // user1let user2 = User { name: user1.name, // 借用user1的字段 age: user1.age, // 借用user1的字段 email: String::from(\"user2@outlook.com\"), active: true}; 如果剩下的字段值都使用老的实例的值, 还可以使用简略的写法 12345678910let user1 = User { name: String::from(\"user1\"), age: 23, active: false, email: String::from(\"user1@outlook.com\")}; // user1let user2 = User { email: String::from(\"user2@outlook.com\"), ..user1 // name/age/active 都使用user1}; 元组结构体 有时我们想给某个元组定义一个名字, 让这个元组结构可以复用并且与普通元组分开, 此时你可以使用 元组结构体, 元组结构体不同于普通的结构体, 他没有具体的每个字段的名字, 只有字段的类型, 但是整个元组结构体拥有一个名字 12345struct Color(i32, i32, i32); // 元组结构体定义struct Point(i32, i32, i32); // 同上let black = Color(0, 0, 0); // 赋值let origin = Point(0, 0, 0); 上面的 Color 和 Point 虽然都是 i32, 长度为3 的元组, 但是因为不是一个结构体所以无法混用 同时因为没有字段的名字, 想要访问其中某一个值, 可以通过索引来获取 结构体的生命周期 你可能注意到了, 我们定义的结构体, 并没有使用引用, 比如使用 String 而不是&amp;str, 是因为这设计到了生命周期的概念, 这个是之后的内容, 目前我们需要让这个结构体内的字段的所有权在自己手中, 以便正常运行, 如果你使用了引用, 目前是无法编译的 123456struct User { name: &amp;str, // 用户名 email: String, // 邮箱 age: u64, // 年龄 active: bool, // 活跃状态} // 结构体 User, 代表用户信息 12345678910111213141516error[E0106]: missing lifetime specifier --&gt; src/main.rs:3:15 |3 | name: &amp;str, // 用户名 | ^ expected named lifetime parameter |help: consider introducing a named lifetime parameter |2 | struct User&lt;'lifetime&gt; {3 | name: &amp;'lifetime str, // 用户名 |error: aborting due to previous errorFor more information about this error, try `rustc --explain E0106`.error: could not compile `t_struct`. 等到之后, 我们会讲到怎样解决这个问题 使用结构体编写示例代码 我们使用之前学的知识, 编写一段代码, 他的功能是求出长方形的面积 123456789fn main() { let width1 = 30; let height1 = 50; println!(\"area={}\", area(width1, height1))}fn area(width: u32, height: u32) -&gt; u32{ width * height} 上面的代码能够完成我们的需求, 但是仔细想, 一个长方形, 长和宽应该是绑定的关系, 如何体现绑定关系呢? 我们将长和宽使用元组绑定到一起 12345678fn main() { let rect1 = (30, 50); println!(\"area={}\", area(rect1))}fn area(dimensions: (u32, u32)) -&gt; u32{ dimensions.0 * dimensions.1} 这样就增加了一些结构性. 但是问题出现了, 使用元组的方式, 我们没法知道哪一个是长, 哪一个是宽, 假如说我们需要根据长宽不同进行不同操作, 比如在屏幕中绘制, 那就可能让调用者产生疑问, 不知道参数的意义 于是我们使用结构体来进行代码的编写 123456789101112131415fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; println!(\"area={}\", area(&amp;rectange1))}struct Rectangle { width: u32, height: u32}fn area(rectangle: &amp;Rectangle) -&gt; u32{ rectangle.height * rectangle.width} 这里的函数 area 为了防止所有权的转让, 我们使用了引用的方式 通过派生 trait 增加功能 有时候我们想打印一个结构体实例的内容, 使用println!是不行的, 例如 1234567fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; println!(\"rec = {}\", rectange1);} 1234567891011121314error[E0277]: `Rectangle` doesn't implement `std::fmt::Display` --&gt; src/main.rs:6:26 |6 | println!(\"rec = {}\", rectange1); | ^^^^^^^^^ `Rectangle` cannot be formatted with the default formatter | = help: the trait `std::fmt::Display` is not implemented for `Rectangle` = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead = note: required by `std::fmt::Display::fmt`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0277`.error: could not compile `t_struct`. 这是因为, println! 宏默认使用类型的Display格式输出, 意思是打印出来的输出, 之前所有的基本类型都实现了Display, 但是因为结构体, rust并不知道你想要输出什么, 所以没有提供Display实现 但是rust给了我们建议, 查看输出, 有一行 1note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead 似乎是告诉我们应该这样输出, 于是我们将打印修改为 1println!(\"rec = {:?}\", rectange1); 运行后发现还是不行, 但是又给了一个提示 12345678910111213error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug` --&gt; src/main.rs:6:28 |6 | println!(\"rec = {:?}\", rectange1); | ^^^^^^^^^ `Rectangle` cannot be formatted using `{:?}` | = help: the trait `std::fmt::Debug` is not implemented for `Rectangle` = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug` = note: required by `std::fmt::Debug::fmt`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0277`. 12= help: the trait `std::fmt::Debug` is not implemented for `Rectangle`= note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug` 这里告诉我们rust确实有打印, 但是是Debug模式, 需要我们显式的开启, 我们将代码修改为 12345678910111213fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; println!(\"rec = {:?}\", rectange1);}#[derive(Debug)]struct Rectangle { width: u32, height: u32} 运行 123 Finished dev [unoptimized + debuginfo] target(s) in 0.40s Running `target/debug/t_struct`rec = Rectangle { width: 20, height: 30 } 可以打印出结构体数据了 我们回看新加入的注释, #[derive(Debug)], 实际上是为结构体 Rectangle 加入了 Debug 的 derive, rust中还有很多这样的用法, 我们之后再说 方法语法 当我们写python的时候, 总会使用到类/方法, 使用类生成对象, 调用对象的方法, 让这个方法与类有紧密的联系 再比如Go, 也有类似的概念, 其实rust也是有的, 依附于结构体struct, 可能更像go, 被称之为结构体的 方法 定义方法 123456789101112131415161718fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; println!(\"area={}\", rectange1.area()) // 调用结构体定义的方法}struct Rectangle { width: u32, height: u32}impl Rectangle{ // impl 结构体名称 fn area(&amp;self) -&gt; u32 { // 定义方法 area self.height * self.width }} 其中, impl 是关键字, 意为定义结构体的方法, 在其中定义了方法area, 注意参数变成了 &amp;self, 学过其他语言的一把都知道这个是代表实例自身, 因为这里我们不想获取实例的所有权, 而是只想获取长和宽, 所以使用了 &amp;, 如果想要在一个方法中修改实例, 可以将参数修改为 &amp;mut self 将参数设置为 self 是不常见的, 这代表获取了实例的所有权, 通常只有将self 转换成别的实例时才适用. 调用结构体方法的时候使用 实例.方法 即可, 参数&amp;self 是自己会传递的, 无需手动的写入 在C/C++中, 参数self为指针时, 调用其方法需要-&gt;, 而.是不为指针时调用的方式, 在Rust中会自己为你识别, 而不必关注参数是 slef/ &amp;self/ &amp;mut self 带有更多参数的方法 很多时候调用方法时肯定需要传入更多参数, 这些参数与实例本身并无联系 1234567891011121314151617181920212223242526fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; let rectange2 = Rectangle{ width: 30, height: 50 }; println!(\"area={}\", rectange1.area()); println!(\"r2 can_hold r1 = {}\", rectange1.can_hold(&amp;rectange2)) // 调用, 额外参数手动指定}struct Rectangle { width: u32, height: u32}impl Rectangle{ fn area(&amp;self) -&gt; u32 { self.height * self.width } fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool { // 接受一个额外参数 other 类型是 &amp;Rectangle self.width &gt; other.width &amp;&amp; self.height &gt; other.height }} 这时候在 self 之后追加即可, 传入参数时需要手动传递, 一样无需传入self 关联函数 impl还可以定义不需要slef作为参数的函数, 这种被称作 关联函数, 他们与结构体相关联, 但是因为不依赖self, 所以依旧是函数而不是方法, 例如 1234567891011121314fn main() { let sq = Rectangle::square(20); // 通过 :: 调用, 因为不依赖实例, 所以不需要通过实例去调用, 直接使用结构体}struct Rectangle { width: u32, height: u32}impl Rectangle { fn square(size: u32) -&gt; Rectangle { // 不依赖实例本身 Rectangle { width: size, height: size } }} ::的语法是不是很熟悉? 更多的使用方法之后会详解 多个impl块 每个结构体都允许有多个impl块, 比如 123456789101112131415161718192021222324struct Rectangle { width: u32, height: u32}impl Rectangle { fn square(size: u32) -&gt; Rectangle { // 不依赖实例本身 Rectangle { width: size, height: size } }}impl Rectangle { fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool { // 接受一个额外参数 other 类型是 &amp;Rectangle self.width &gt; other.width &amp;&amp; self.height &gt; other.height }}impl Rectangle{ fn area(&amp;self) -&gt; u32 { self.height * self.width }} 这样是可以正常使用的, 但是一般不建议这样做, 因为没有意义, 可能在特殊的需求下有用, 我们之后会说 枚举与模式匹配 枚举(enumerations/ enums)开发者应该都很熟悉, 枚举让你可以通过列举可能的 成员(variants) 来定义一个类型 定义枚举 通过一个场景来理解枚举, 我们知道, IP地址目前主要有两种, IPv4 和 IPv6, 这两个都属于IP, 假设我们的程序有可能会且只会处理这两种IP, 那么我们可以将两个归属为一起, 当代码在处理IP时将其当做一样的来处理, 我们可以使用 枚举 来做. 定义一个枚举 IpAddrKind 来整合这两种类型, 分别为 v4 和 v6 12345enum IpAddrKind { // 枚举名 v4, // ipv4 v6, // ipv6} 现在, 对于程序来讲, IpAddrKind是一个可以使用的数据类型了 枚举值 使用定义的枚举 12let four = IpAddrKind::v4;let six = IpAddrKind::v6; 枚举的每一个成员都在其枚举的命名空间中, 使用 :: 呼出, v4和v6都属于IpAddrKind, 所以可以当做一个类型处理 123456789101112131415enum IpAddrKind { // 枚举名 v4, // ipv4 v6, // ipv6}fn a(ip: IpAddrKind){}fn main() { let four = IpAddrKind::v4; let six = IpAddrKind::v6; a(four); a(six)} 如果我们想要将IP地址和IP类型形成关联关系, 我们可能优先想到使用结构体 123456789101112131415161718192021enum IpAddrKind { // 枚举名 v4, // ipv4 v6, // ipv6}struct IpAddr { // ip地址结构体 address: String, // ip kind: IpAddrKind // 类型}fn main() { let address1 = IpAddr{ kind: IpAddrKind::v4, address: String::from(\"123.234.111.222\") }; let address2 = IpAddr{ kind: IpAddrKind::v6, address: String::from(\"::1\") };} 其实在枚举IpAddrKind时, 我们就已经知道了是v4还是v6, 而在结构体IpAddr中只多出来了字段address, 那么我们可以给枚举设置value, 来让代码更简单 12345678910enum IpAddr { // 枚举名 v4(String), // ipv4, String类型 v6(String), // ipv6, String类型}fn main() { let address1 = IpAddr::v4(String::from(\"127.0.0.1\")); let address2 = IpAddr::v6(String::from(\"::1\"));} 因为IP地址实在是太常见了, 很多时候我们都会用到, 所以Rust内置了数据结构专门存放IP地址, IpAddr in std::net - Rust (rust-lang.org), 内部是这样定义的 123456789101112struct Ipv4Addr { // --snip--}struct Ipv6Addr { // --snip--}enum IpAddr { V4(Ipv4Addr), V6(Ipv6Addr),} 将枚举的value设置成结构体, 而这个结构体可以存放任何数据, 这样来增加兼容性 因为我们的例子中都没有引用标准库中的定义, 所以即使我们自己定义了IpAddr枚举, 也不会产生冲突 下面我们再看一个新的枚举 123456enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32),} 这个枚举Message 下面有4个成员, Quit没有关联任何数据, Move对应一个匿名结构体, Write关联一个元组String, ChangeColor关联一个元组 如果我们单纯使用结构体也可以达到效果 1234567struct QuitMessage; // 类单元结构体struct MoveMessage { x: i32, y: i32,}struct WriteMessage(String); // 元组结构体struct ChangeColorMessage(i32, i32, i32); // 元组结构体 问题是, 这样的话就没有将这几个Message形成关联关系, 如果使用枚举, 因为枚举本身是一种类型, 就能将这些Message以成员的方式合到一起 对于枚举类型, 我们也可以通过使用impl关键字来为枚举类型定义方法(和结构体类似) 12345678impl Message { fn call(&amp;self) { // 方法call }}let m = Message::Write(String::from(\"hello\"));m.call(); // 调用 具体的调用, self方式, 可以参照上方的结构体impl option枚举 Option是标准库定义的另一个枚举, 他的应用很广泛, 他代表了一个值要么有值要么没值. 你可能现在不明白有什么作用 Rust中没有其他语言有的空值功能, 空值(Null)也是一个值, 他代表了没有值. 在其他语言中, 变量都有两种状态: 空值和非空值 Tony Hoare，null 的发明者，在他 2009 年的演讲 “Null References: The Billion Dollar Mistake” 中曾经说到： I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. 我称之为我十亿美元的错误。当时，我在为一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所有引用的使用都应该是绝对安全的。不过我未能抵抗住引入一个空引用的诱惑，仅仅是因为它是这么的容易实现。这引发了无数错误、漏洞和系统崩溃，在之后的四十多年中造成了数十亿美元的苦痛和伤害。 空值的问题主要在于, 当你想像使用非空值一样使用空值, 就会出现某种形式上的错误, 因为空和非空无处不在, 所以很容易出现这种问题 rust中没有空值, 他有一个在编码时可以存在或者不存在的概念的枚举, 这个就是Option 1234enum Option&lt;T&gt; { Some(T), None,} 因为Option太多常用, 所以不需引用标准库也直接存在, Option下拥有两个成员, Some(T)和None, &lt;T&gt;是我们还没有讲到的功能, 他指的是一个泛类型参数, 目前你可以理解成可以包含任何类型的数据, 我们之后会详细讲解 因为对Option做了特殊处理, 所以Option下面的成员Some和None也可以直接使用, 无需Option::Some 1234let some_number = Some(5);let some_string = Some(\"a string\");let absent_number: Option&lt;i32&gt; = None; 如果你使用成员None, 则需要告诉Rust Option 是什么类型, 因为Rust无法自己知道None是什么类型 并且, 因为你通过Option创建的值是Option类型, 他无法直接与普通的类型进行操作 123456fn main() { let x: i8 = 5; let y: Option&lt;i8&gt; = Some(5); let sum = x + y;} 会报错 123456789101112error[E0277]: cannot add `std::option::Option&lt;i8&gt;` to `i8` --&gt; src/main.rs:5:17 |5 | let sum = x + y; | ^ no implementation for `i8 + std::option::Option&lt;i8&gt;` | = help: the trait `std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is not implemented for `i8`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0277`.error: could not compile `t_enum`. 告诉你无法将 i8 与 Option&lt;i8&gt; 进行相加, 因为他们的类型不同, 而对于i8这种类型, Rust可以保证他一定是有值的, Option&lt;i8&gt; 也有可能是为None的, Rust为了避免这个错误不允许直接计算. 而要想进行操作, 必须将 Option&lt;T&gt; 转换成 T , 在这个过程中就会让我们预先的处理空值的问题. 当我们发现一个变量为Option&lt;T&gt;是, 牢记可能是空值, 而其他的普通类型, 他一定是非空, 就不用考虑空值的问题 怎么将Option&lt;T&gt;转换成T, 在之后会告诉你, 你也可以查看Option in std::option - Rust (rust-lang.org) match控制流运算符 类似Golang有switch语法, Python可以使用else if ,达到对某个值进行多个分支判断的逻辑, Rust里当然也是有的, match, Rust会在编译期检查所有可能的情况你都做了处理, 当匹配到符合条件的分支时, 就进入对应模式的代码中处理 123456789101112131415enum Coin{ // 枚举 Penny, Nickel, Dime, Quarter,}fn value_in_cents(coin: Coin) -&gt; u8 { match coin { // match Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, }} 上面是一个枚举和以枚举成员当做模式的match表达式 这里的函数value_in_cents 接收一个枚举的实例, 然后进入match表达式, match关键字之后跟一个表达式, 在这里跟的是coin的实例. 没错, match之后可以跟任何类型. 而{}中的则是这个match的分支, 对于分支来讲, 有两个部分组成, 一个模式和一些代码. 比如第一个分支 Coin::Penny =&gt; 1 , 这里的Coin::Penny就是模式, =&gt; 后跟的就是代码, 当匹配到模式之后, 会运行定义的代码 一个match有多个分支, 在匹配时, 会从上到下匹配, 直到匹配成功后就退出match 匹配到的代码如果很短, 通常不使用大括号, 如果有多行代码则需要使用, 例如 1234567891011fn value_in_cents(coin: Coin) -&gt; u8 { match coin { // match Coin::Penny =&gt; { println!(\"Penny\"); // 打印 1 // 返回 }, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, }} 绑定值的模式 枚举可能是有值的, match 同样也可以获取到枚举实例的值 123456789101112#[derive(Debug)] // debugenum UsState { Alabama, Alaska,}enum Coin { Penny, Nickel, Dime(u8), Quarter(UsState),} 我们为枚举Coin的成员Quarter 设置值为另一个枚举 1234567891011fn value_in_cents(coin: Coin) -&gt; u8 { match coin { Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter(state) =&gt; { println!(\"State quarter from {:?}!\", state); 25 }, }} 然后在 match 时, 如果是 Quarter 则打印其值 12345678910111213141516171819202122232425262728293031323334#[derive(Debug)] // debugenum UsState { Alabama, Alaska,}enum Coin { Penny, Nickel, Dime(u8), Quarter(UsState),}fn value_in_cents(coin: Coin) -&gt; u8 { match coin { Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime(v) =&gt; { println!(\"{}\", v); 8 }, Coin::Quarter(state) =&gt; { println!(\"State quarter from {:?}!\", state); 25 }, }}fn main(){ let d = Coin::Dime(20); let q = Coin::Quarter(UsState::Alaska); let dp = value_in_cents(d); let qp = value_in_cents(q);} 在这里使用cargo run 会出现几个报警, 这是因为没有将一些枚举使用起来, 这里不作理会 使用()的方式可以接受处理枚举中包含值的情况 匹配 Option&lt;T&gt; match同样可以处理Option&lt;T&gt; 123456789101112fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; { match x { None =&gt; None, Some(i) =&gt; Some(i + 1), }}fn main(){ let five = Some(5); let six = plus_one(five); let none = plus_one(None);} 因为Optione&lt;T&gt;可能存在为None的情况, 所以通过match进行分别处理, 这里的x 就是为None时不做任何处理, 有值时进行 +1 处理 匹配是穷尽的 Rust的匹配是穷尽的, 你必须为match设置能覆盖所有情况的分支, 否则会编译失败 12345678910fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; { match x { Some(i) =&gt; Some(i + 1), }}fn main(){ let five = Some(5); let six = plus_one(five);} 1234567891011121314151617181920error[E0004]: non-exhaustive patterns: `None` not covered --&gt; src/main.rs:2:11 |2 | match x { | ^ pattern `None` not covered | = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match armswarning: unused variable: `six` --&gt; src/main.rs:9:9 |9 | let six = plus_one(five); | ^^^ help: consider prefixing with an underscore: `_six` | = note: `#[warn(unused_variables)]` on by defaulterror: aborting due to previous errorFor more information about this error, try `rustc --explain E0004`.error: could not compile `t_enum`. 这里就是没有处理为None的情况, Rust会避免出现这种问题 _通配符 其他语言类似的分支处理, 通常会有一个default, 如果都匹配不上, 则会进入default分支, 通常default分支是写在最后的 123456789101112fn main() { let some_u8_value = 0; match some_u8_value { 1 =&gt; println!(\"one\"), 3 =&gt; println!(\"three\"), 5 =&gt; println!(\"five\"), 7 =&gt; println!(\"seven\"), _ =&gt; { println!(\"kkkkk\") }, }} Rust有一个_, 作用是通配符, 能匹配所有的情况 比如这里, 如果some_u8_value不是1/3/5/7的其中一个, 则最后会匹配到_分支 _分支需要写在最后, 因为他是通配的, 假如写在第一位, 那么所有的值都能匹配进_, 这样就会导致逻辑出现问题 if let简单控制流 如果有需求, 如果值为3则进行操作, 其他则不处理 1234567fn main(){ let some_u8_value = Some(0); match some_u8_value { Some(3) =&gt; println!(\"three\"), _ =&gt; (), }} 实际上, 如果使用match的话, 为了适应无穷性, 必须进行通配符适配, 难免会增加样板代码, 不简洁 Rust提供了if let, 来处理只匹配一个模式忽略其他模式的情况 123456fn main(){ let some_u8_value = Some(3); if let Some(3) = some_u8_value { println!(\"three\"); }} if let 后跟一个由=分割的模式和表达式, 比如这里, Some(3)就是模式, 表达式是 123{ println!(\"three\");} 当模式匹配后进行表达式的运行, 不匹配则不运行, 例如 123456fn main(){ let some_u8_value = Some(1); if let Some(3) = some_u8_value { // 不运行 println!(\"three\"); }} 相比普通的match 更加简单, 但是, 这种写法会失去编译时的穷尽检查, 让代码可能会超出你期望的方式运行, 因此使不使用需要自己衡量 if let 也可以加 else , 作用与通配符_一致, 例如 12345678fn main(){ let some_u8_value = Some(1); if let Some(3) = some_u8_value { println!(\"three\"); }else{ println!(\"other\") // 打印 }} 也可以和多个 if let 一起使用 1234567891011fn main() { let some_u8_value = Some(4); if let Some(3) = some_u8_value { println!(\"three\"); } if let Some(4) = some_u8_value { println!(\"four\") } else { println!(\"other\") }} 需要说明的是, 如果多个分支了, 最好还是使用 match, 这样反而会提高代码简洁性","link":"/2021/09/07/rust_programming_language(5)/"},{"title":"浅谈双重认证","text":"什么是双重认证 两步认证是一个概念, 并不是指必须经过某种方式去实现, 而是指对于鉴权来讲, 在之前的通过账号密码的方式再加一层校验, 至于怎么加, 加的方式是什么并不是规定的, 当然, 目前国外比较通用的是使用 谷歌身份验证器/微软认证器 等来做, 国内的有使用短信的, 本文着重来说 谷歌身份验证器/微软认证器 等一些国外的认证流程, 因为他们都遵循了统一的标准(统一的算法) 为什么需要双重认证 传统的一步认证一般是账号密码, 因为账号密码是固定的, 所以如果密码泄露, 基本这个账户的一切都不再属于你, 而双重认证的原理决定了他是动态的, 是每一段时间变化一次的(一般30秒), 所以他相对来说比较安全, 如果你的密码暴露了但是二次认证生成的Code无法获取到照样无法进行操作, 所以双重认证的安全性更高 双重认证流程 一般的双重认证采用 TOTP 算法, 其算法保证了相同Key的情况下每一段时间内都可以生成同样的一个6位Code, TOTP算法资料可看 百度百科 wiki TOTP具体实现可看github 以 atlassian 为例, 来我们开启走流程开启双重认证, 当我们选择开启时 可以看到该网站提供了一个二维码给我们, 此时我们需要在手机上下载 谷歌身份验证器 app, 打开可以看到添加一个双重认证的方式有两种, 扫描二维码和手动输入, 我们来提取这个二维码的信息, 发现里面是一个链接, 类似于 1otpauth://totp/user@example.com?secret=PVKG6TZFHJUEMSK5ORYD3LI&amp;issuer=Atlassian 我们按照规则来解析, 实际上是 1otpauth://totp/认证项目名称?secret=唯一KEY&amp;issuer=签发者 需要注意的是, 我们每次重新申请开启双重认证时出现的二维码解析出的Key都是变化的 当我们使用 谷歌身份验证器 扫描后, 会出现一条新的记录 你也可以按照此规则编出来一个链接通过生成二维码的小工具让软件扫扫看 我们还原此过程, 当app扫到码之后, 获取到项目名称和Key与签发者, 按照TOTP算法生成6位Code, 展示出来, Code是30s一变, 但是注意, 此时网站与App并无联系, App也并不负责对Key等信息校验真实性 而我们需要将生成的Code输入进网站的下方验证码这里, 通过后才会与App建立绑定关系(网站端单纯的建立逻辑的绑定关系) 还原此过程, 网站端并不知道App有没有生成, 但是因为App都遵循统一的 TOTP 算法, 因此网站端也可以生成当时的正确Code, 当我们提交的Code与网站端生成的Code相符时, 即网站将该Key绑定(也就是图上说的 连接后，我们会记住您的手机，以便您每次登录时都可以使用。), 绑定后, 网站对这个通过的Key进行记录, 每次需要验证时网站根据Key生成Code, 与用户提交的Code比对, 通过即可 通过上述流程, 我们可以发现, 实际上App端只掌握了一个Key, 但是App本身并不知道Key是否是正确的, 他们两个实际上永远没有交流, 这样就很安全 经测试, 网站一般会只允许一个Key存活, 也就是当我们重新申请一个Key, 原先的Key则失效, 当然对于App是不知道的, 但是当我们提交认证时网站就会报错.","link":"/2021/09/04/two_auth/"},{"title":"大型网站技术架构-笔记(1)","text":"大型业务的系统特点 高并发 大流量 高可用 海量数据 用户分布广泛 网络情况负载 安全环境恶劣 需求快速变更 快速迭代 最初的小型业务的架构 LAMP = Linux+Apache+MySQL+PHP 网站的架构变化 一台服务器放置LAMP 三台服务器存放 应用/文件服务/数据库服务 增加本地缓存/分布式缓存服务器 应用服务器增加集群 数据库读写分离 CDN和反向代理 分布式文件系统和分布式数据库 使用NOSQL和ES 将业务进行拆分 根据业务来确定网站架构, 多大的业务量决定使用什么架构, 合适的才是最好的 技术架构为业务服务, 切勿本末倒置 网站架构的设计误区 一味追寻大公司的解决方案 为了技术而技术, 脱离实际情况 企图使用技术解决所有问题(为什么不试试调整业务呢?) 网站架构模式 分层 应用层: 负责具体业务和视图展示, 网站首页和搜索输入和结果展示(前段) 服务层: 为应用层提供服务支持, 用户管理服务, 购物车服务(接口) 数据层: 数据的存储和访问服务, 数据库/缓存/文件/搜索(数据) 分割 将网站按照模块进行分割, 逻辑与物理都分割, 提高并发处理能力和功能扩展能力 分布式 将分割后的模块进行分布式部署 好处 提高并发与数据处理能力 问题 网络通讯造成的性能损耗 某一个服务器宕机造成的网站可用性降低 数据在分布式环境中的数据一致性问题 事务问题 网站依赖关系复杂, 开发/管理/维护困难 分布式方案 分布式应用和服务: 将分割后的接口进行分布式部署, 可以改善网站性能和并发性,有利于业务功能扩展, 对于开发这个模块的人来说, 可以加快开发速度 分布式静态资源: 将静态资源独立分布式部署, 动静分离, 加快加载速度, 优化用户体验 分布式数据和存储: 将数据分布式存储, 提高效率 分布式计算: 将对计算要求高的逻辑使用分布式计算框架分配到其他机器进行计算, 提高效率 缓存 CDN: 将一些静态资源和较少变化的数据和热点数据存放在缓存中, 用户访问时优先访问缓存 反向代理: 反向代理服务配置缓存 本地缓存: 在应用程序设计的本地存放缓存, 一般是存放在内存中 分布式缓存: 将缓存存放在分布式缓存集群中 什么时候适合使用缓存: 需要频繁访问的数据/在某个时段内有效的数据 异步 将要处理的数据存放进队列中, 由消费者去消费 提高系统可用性: 消费者发生问题时生产者可以继续入队 加快响应速度: 耗时的操作不需要等待即可返回, 减少响应延迟 消除并发访问高峰: 访问量大的时候也由消费者依次处理, 减轻压力 异步要和产品的业务相关, 有些时候无法使用异步 冗余 某个服务器宕机时一定要保持重要数据的不丢失, 所以需要一定数量的服务器 冗余运行, 目的是在正常情况下, 这些服务器是不参与正常的业务流程的, 当线上的服务器发生故障时, 再启动对应的冗余服务器承接业务, 保证服务的正常运行, 一般的, 像网关之类的(一台服务器即可, 但是挂掉对整个架构的影响较大)服务必须要设置冗余 冗余可以实现服务的高可用 备份 冷备份:数据库中的数据也需要定时备份与存档, 这叫数据冷备份 热备份:数据库的高可用就是总从分离, 数据库会进行同步更新数据, 这种随时更改随时同步的方法叫热备份 灾备数据中心:特别大的业务, 为了抵御遇到大停电/地震/海啸等不可抗力导致的业务瘫痪, 在各地有灾备数据中心, 尽可能的减少损失 自动化 发布过程自动化: 自动化发布系统, 减少发布过程因为人为失误导致的问题 自动化代码管理: 代码版本控制/分支控制等自动化 自动化测试: 提交测试后由系统进行自动化用例测试 自动化安全检测: 通过安全检测工具检测代码 自动化部署: 自动部署到线上环境 自动化监控: 对线上的各项指标进行监控, 通过服务中心对集群机器性能进行监控 自动化报警: 检测到指标达到某一个阀值时自动向相关人员通过短信/手机等方式报警 自动化失效转移: 检测到集群的某个服务器挂掉后自动将其剥离出业务, 等待开发人员修复 自动化失效恢复: 监测到服务正常后自动加入到业务中 自动化降级: 网站持续告警时, 关闭一些不重要的服务, 将资源释放出来給重要的服务保障业务的安全可用 核心架构要素 性能 一个打开缓慢的网站会导致严重的用户流失, 除非是没的选择 优化措施: 前端利用浏览器缓存/页面压缩/合理布局页面/减少cookie传输来改善性能 架构使用CDN/反向代理/缓存热点文件来加快响应速度减轻服务器压力 后端使用本地缓存和分布式缓存加快请求处理过程,减轻数据库压力 是否可以将业务修改为异步 集群/多线程/SQL优化等 可用性 网站宕机/服务不可用属于重大失误, 轻则影响网站声誉, 重则摊上官司. 而且大概率会损失金钱和用户 优化措施: 冗余, 应用部署在多个服务器同时提供服务, 数据在多个服务器互相备份 服务集群, 负载均衡, 前提是应用服务器不能保存请求的会话信息以免出现问题切换到另一台机器时无法完成业务处理 数据库集群, 数据采用冷备份和热备份同时运行的方式 伸缩性 伸缩性指通过不断向集群中加入服务器来缓解不断上升的业务量和数据存储需求 衡量伸缩性的主要标准就是是否可以使用堕胎服务器构建集群, 是否容易向集群中添加新的服务器, 加入新的服务器后是否可以提高和原来的服务器无差别的服务, 集群中可以容纳的总服务器数量是否有限制 应用服务器集群: 服务器上不保存数据, 所有服务器都是对等的, 通过使用合适的负载均衡设备就可以向集群中不断加入服务器 缓存服务器集群: 加入新的服务器可能导致缓存路由失败, 导致集群中大部分缓存数据无法访问. 虽然缓存的数据可以通过数据库重新加载, 但是如果应用严重依赖缓存, 可能会导致整个网站崩溃, 需要改进缓存的路由算法保证缓存数据的可访问性 关系型数据库: 数据库本身很难做到大规模集群的可伸缩性,所以必须在数据库外实现, 例如通过逻辑分区将某一部分逻辑的多个数据库服务器组成集群 NoSQL: 天生就为海量的数据而生, 因此对伸缩性支持很好 扩展性 网站的扩展性架构直接关注网站的功能需求, 网站的功能快速迭代, 扩展性的提高可以使其快速响应需求的变化 衡量网站架构性的标准是在网站增加新的业务产品时, 是否影响现有产品, 是否不需要改动或很少改动现有产品即可上线新的产品, 不同产品之间是否很少耦合, 一个产品的改动是否对其他产品有影响, 其他产品是否不需要改动 优化措施: 事件驱动架构: 事件驱动通常使用消息队列实现, 消息产生后加入队列, 由消费者服务进行消费, 通过这种方式将消费者和生产者分开, 透明的增加新的生产者或消费者 分布式服务: 将业务和可复用服务分离, 通过分布式框架调用, 新增产品通过调用可复用的服务实现自身的业务逻辑, 对现有的产品没有任何影响. 可复用服务升级时要注意多版本的兼容, 实现透明升级 大的网站为了保持市场地位和覆盖率, 会提供开放平台接口供第三方开发者调用 安全性 互联网是开放的, 任何人在任何地方都可以访问网站, 网站的安全架构就是保护网站不受恶意访问和攻击, 保护重要数据不被窃取","link":"/2021/09/04/website_architecture(1)/"},{"title":"大型网站技术架构-笔记(3)","text":"网站可用性度量 业界通过用多少个9来衡量网站的可用性 网站不可用时间 = 故障修复时间点 - 故障发现(报告)时间点 网站年度可用性指标 = (1 - 网站不可用时间 / 年度总时间) x 100% 达到4个9就很难了(99.99%) 高可用的网站架构 典型的网站设计通常为三层的架构模型, 即 应用层/服务层/数据层 (从上到下) 各层之间具有相对独立性 应用层负责具体业务逻辑的处理 服务层负责提供可复用的服务 数据层负责数据的存储与访问 大型网站的分层架构及物理服务器的分布式部署使得位于不同层次的服务器具有不同的可用性, 关闭服务器或者宕机时产生的影响也不一样. 高可用的解决方案也差异很大 应用层 - 通过负载均衡将一组服务器组成集群对外提供服务, 当负载均衡设备通过心跳等方式检测到某台服务器不可用时将其从集群列表中剔除来实现高可用 服务层 - 通过集群方式实现高可用, 只是这些服务被上层的应用层调用, 分布式服务调用框架会在应用层客户端内实现软件负载均衡, 并通过服务注册中心对提供服务的服务器进行心跳检测, 如服务不可用则通知客户端程序修改服务访问列表, 将不可用的服务器剔除 数据层 - 为保证数据不丢失, 需要在数据写入时进行数据的同步复制, 将数据写入到多个服务器上实现冗余备份. 服务器宕机时切换到备份服务器 高可用应用 应用层处理网站应用的业务逻辑, 所以也有人叫业务逻辑层, 应用的一个显著的特点是应用到的无状态性 无状态性指应用服务器不保存业务的上下文信息, 而是根据每次请求提交的数据进行业务处理, 多个服务器之间完全对等, 请求提交到任何服务器, 处理的结果都是一样的 通过负载均衡进行无状态服务的失效转移 对于无状态服务来说, 将某个请求交给哪个服务器都是一样的处理结果, 那么, 我们可以通过搭建集群来进行负载均衡, 同时, 当某台服务器出现问题时, 负载均衡服务器通过心跳检测发现该服务器异常, 将其从提供服务的列表中删除, 因为服务是无状态的所以不会影响最终的处理结果 负载均衡实际上在应用层起到了高可用的架构, 因此健全的架构应该是即使某个服务访问量非常少, 一台服务器足够处理, 也最好至少部署两台服务器加上负载均衡技术构建一个小型的集群 集群架构的Session管理 应用服务器的高可用架构主要基于服务无状态这一特征, 但是实际中业务总是有状态的, 比如说有的电商网站可能会有服务是购物车商品的加减等, 这种多次请求修改使用的上下文对象称之为会话(Session), 在负载均衡中, 由于负载均衡服务会将请求分发到集群中的任何一台服务器上, 所以对Session的处理比单机复杂得多, 一般有以下几种方法 Session复制 早期的应用系统使用较多的是在集群里的服务器之间开启Session的同步机制, 达到在每台服务器之间都保存所有用户的Session信息, 即使请求分配到不同的服务器也不会对结果产生影响 这种方法虽然简单粗暴, 从本机直接获取Session也是最快的途径, 但是如果集群的规模变大时服务器间仅仅同步Session就需要占用很大的资源和带宽, 系统不堪重负, 而且每台服务器都保存了这个集群每个用户的Session, 也可能会出现内存不够用的情况, 而且同步需要耗费时间, 有可能出现同步不及时导致的异常情况 Session绑定 负载均衡服务一般自带的有根据来源地址Hash算法来将同一来源的IP请求分发到同一台服务器, 也可以根据Cookie识别, 这个时候负载均衡服务必须工作在HTTP协议层之上, 这样集群中的某个服务器只需保存到达本机的Session即可. 这种又被称作 会话粘滞 但是如果集群中的某个服务器宕机则该机器上面的Session则丢失, 原有的用户被分配到新的服务器, 此时Session丢失, 对业务就产生了影响 利用Cookie记录Session 也有方法是将Session保存在客户端中(以Cookie的形式), 在请求时携带給服务端 这样每次都需要携带Cookie, 影响性能, 同时浏览器可手动阻止Cookie的传输造成请求不正常. Session服务器 推荐的方法是部署一套Session服务器(最好是集群)来管理Session, 每次请求进入业务服务器后服务器根据逻辑去Session服务器请求获取Session再进行逻辑处理即可 对于Session服务器, 简单的方法是使用分布式缓存(redis/…)实现. 但是如果对Session管理有比较高的要求, 比如SSO(单点登录)等可能需要开发专门的Session服务平台 高可用服务 对于基础的公共服务, 大型网站中通常将其独立出来分布式部署来被具体的逻辑应用远程调用, 可复用的服务也是无状态的, 所以可以使用负载均衡技术的失效转移来实现高可用 分级管理 在服务部署时, 将核心的应用和服务优先分配给更好的硬件, 在运维过程中优先级也更高, 比如购物网站, 付款比评论优先级更高 同时在服务的部署上也进行必要的隔离, 避免发生连锁反应. 比如将低优先级的服务部署在虚拟机上, 高优先级的部署在物理机上等 超时设置 设置调用的超时, 如果在指定时间内被调用的服务没有响应, 此时通信框架应抛出异常, 根据服务调度策略重试漷请求转移 异步调用 对于某些业务, 比如注册, 背后可能需要多步操作, 比如像用户邮箱发送注册成功邮件, 开通对应权限等, 其中邮件服务一般是不具有同步性的. 此时应将邮件服务设置为异步调用, 不对整体的服务产生影响 并不是所有的业务都能通过异步来完成, 因此是否使用需要根据具体的业务来判断 服务降级 在网站访问的高峰期, 服务可能会因为大量的请求而导致性能的下降, 严重时可能会引发宕机. 所以为了保证高峰时核心应用和服务的正常运行, 需要对服务进行降级, 一般有拒绝服务和关闭服务两种 拒绝服务 拒绝低优先级的应用调用, 减少调用并发数量, 确保核心应用的正常使用. 当达到并发数量限制时新进入的请求返回错误给客户端. 或者是随机拒绝请求, 随机ban掉一些请求给客户端, Twitter喜欢这样 关闭功能 直接将服务的入口关闭, 或在服务内部关闭, 让所有用户都无法访问该功能, 淘宝在双11时会关闭 评价/确认收货 等功能保证核心服务顺利完成 幂等性设计 当应用调用服务失败时, 会将调用请求重新发送到其他服务器, 但是这个调用失败有可能失败在了中间一步, 有可能逻辑已经走了一半, 此时发送到其他服务器, 其他服务器重新执行流程可能会出现意想不到的问题 但是服务的重复调用是无法避免的, 应用层也不需要关心服务是否真的失败了, 只要没有接收到调用成功的响应即认为失败, 因此必须在服务层保证服务重复调用和调用一次产生的结果相同, 即服务具有 幂等性 高可用的数据 数据是最宝贵的物质资产, 保护网站的数据就是保护网站的命脉 因此数据的存储和高可用对网站很重要, 对于数据的保存, 一般使用专门的数据存储服务器, 当这个数据存储服务器宕机时, 数据的访问请求一般不能任意的切换到其他的数据服务器上 对于数据存储来讲, 一般使用数据的备份和失效转移机制, 数据备份即保证一份数据有多个副本, 任意副本的失效都不会导致数据的永久丢失. 从而实现数据完全的持久化, 失效转移即当一个数据副本不可访问时, 可以快速切换访问数据的其他副本保证系统可用. 对于缓存服务来说, 业内有两种观点, 一种是随着缓存的大量使用, 缓存的数据也成为了网站数据的一部分, 因此缓存也需要和数据一样实现高可用 一种是缓存部署数据存储服务, 缓存服务器宕机引发缓存数据丢失导致服务器压力高应该通过其他手段解决, 因为缓存本来就是只作用于提高访问速度, 而不是存储数据 CAP原理 在讨论高可用数据服务架构之前, 必须先知道, 为了保证数据的高可用, 网站通常会牺牲一定的数据一致性 什么是高可用? 数据持久性 保证数据可以持久的存储, 在任何情况下都不会丢失数据, 即在写入数据时写入到持久性的存储硬件中, 同时将数据备份到多个副本中, 存放在不同的物理硬件上保证数据不丢失 数据可访问性 如果一个数据存储设备损坏, 需要尽快将数据访问切换到另外一个存储设备上, 在切换期间, 该数据无法被访问 数据一致性 在数据有多个副本的情况下, 如果网络出现故障, 导致部分副本数据写入成功, 部分副本失败, 就会导致数据不一致的问题. CAP的C为数据一致性, A为数据可用性, P为分区耐受性(跨网络分区的伸缩性) 需要知道的是, CAP不可能面面俱到 具体来说, 数据一致性分为下面几种 数据强一致性 各个副本的数据在物理存储中总是一致的, 数据的更新操作结果和操作响应总是一致的, 即操作响应通知更新失败时数据一定没有更新, 而不是处于不确定的状态 数据用户一致 数据在物理存储中的各个副本的数据不一定是一致的, 但是用户访问时通过纠错和校验机制, 可以确定一个一致的正确的数据返回给用户 数据最终一致 这是数据一致性中比较弱的一种, 即物理存储的数据可能是不一致的, 终端用户访问到的数据也可能是不一致的, 但是系统经过一段时间的自我修正后数据会最终一致 因为现实情况里很难满足数据的强一致性, 所以网站通常会综合成本/技术/业务场景等条件综合考虑来保障数据的正确性 数据备份 数据备份是最有效的数据保护手段, 早期的数据备份手段是冷备份, 即定期将数据复制到某种物理的存储介质中并存档保管, 如果系统存储损坏泽从冷备份的数据中恢复 冷备的优点是简单和廉价, 成本和技术难度都较低, 缺点则是无法保证数据的最终一致性, 由于数据是定期复制, 导致备份中的火速句永远比系统的数据陈旧. 如果系统的数据丢失, 那么从上次备份到系统数据损坏中的数据会永久丢失, 不能从备份中恢复. 同时也无法保证数据可用性, 而且从冷备份中恢复数据需要时间较长, 并且恢复中时无法访问数据, 系统也不可用 因此, 数据的冷备份作为一种传统的方案, 依然在使用, 但是还需要热备份双管齐下以提高数据的可用性 热备份可分为两种: 异步热备份与同步热备份 异步热备 异步指多份数据副本的写入操作异步完成, 应用程序收到数据服务系统返回成功时, 实际上只写成了一份, 然后再异步的同步到其他副本中(也有可能会失败) 在异步的情况下, 存储服务器分为主存储和从存储, 正常情况下应用只链接主存储服务器, 数据写入时写入到主存储中, 然后返回成功, 再异步的同步到从存储服务器中 同步热备 每份数据副本同时写入成功后再返回成功, 也有可能出现写入失败其实已经有几个成功的情况 为了提高速度, 应用程序在接收到指令后同时向多个存储服务器写入数据, 等待所有存储服务器都返回成功后再通知程序写入成功 此种情况下, 存储服务器之间没有主次之分, 完全对等, 便于管理和维护. 失效转移 若数据服务器集群中的其中一个服务器宕机, 那么应用程序针对这个服务器的所有读写操作都需要重新路由到其他的机器, 保证数据访问不失败, 这个过程叫做失效转移, 失效转移一般分下面几步 失效确认 系统首先要确认这个服务器是否宕机, 大多是有两种: 心跳检测和应用程序访问失败报告 一般的, 如果应用程序报告访问失败, 控制中心还需要发送一次心跳进行确认, 避免一次错误的判断导致触发失效转移, 因为失效转移过程复杂 访问转移 确认某台服务器宕机后, 就需要将数据读写的访问请求重新路由到其他正常的服务器上, 如果存储服务器之间完全对等, 其中一台宕机可根据配置重新切换到对等的服务器上. 如果存储不对等, 则需要重新计算出对等的路由选择存储服务器 数据恢复 某台服务器宕机后, 数据存储的副本数量 -1, 应当在后续将副本的数量恢复上, 才能保证访问转移 高可用的网站软件质量保证 在网站的实践中, 除了硬件可能导致的风险外, 还有软件本身的问题 网站发布 网站通常需要保证 7X24 的高可用运行, 同时网站需要不断的发布新功能来吸引用户以维持运营, 很多网站需要一周发布一到两个版本, 在刚上线的时期可能更加的频繁 不管发布的功能是修改了一个按钮布局还是增加一个业务, 都需要关闭原有的应用在重新部署新的应用再启动, 相当于给飞行中的飞机更换一个引擎, 既不能让飞机有剧烈的晃动(影响用户体验), 也不能让飞机降落(停机维护), 也不能让飞机坠毁(宕机) 网站的发布的过程其实和网站的服务器宕机效果一致, 对其系统可用性的影响也差不多, 所以在设计之初就需要考虑服务器宕机其实不是概率上的一年一两次, 而是快速迭代造成的一周一两次, 那么用户可以接受一周一两次的宕机吗? 对于网站的发布来说, 在发布之前肯定可以提前预知到服务器会宕机, 所以针对发布, 我们可以预先制定好流程来尽量减少对用户的影响 一半采用分批更新的策略, 一次更新一小批服务器, 更新完成后再将其重新加入到负载均衡中供使用 自动化测试 代码在发布到线上之前需要进行严格的测试, 测试一般需要的时间和人力较多, 我们也可以使用自动化测试来减少一些人工的工作量 目前大部分网站都适用自动化测试技术, 比如网站端使用 Selenium 技术模拟访问和点击, 大型网站也会自己开发测试工具 预发布验证 在自动化测试和测试人员测试完成后, 还需要进行预发布验证, 因为线上环境多种多样, 并不能保证一定不出问题, 所以也需要预发布验证的步骤 在网站发布时, 并不是直接发布到线上服务器, 而是先发布到预发布服务器, 由开发工程师和测试工程师进行验证, 即执行一些典型的业务流程, 确定无问题再发布 预发布服务器应与正式服务器一致, 唯一的不同就是预发布服务器无法被外网用户访问 因为预发布环境与正式环境连接的同一个数据库, 一些操作可能会引起正式环境的数据出现问题, 因此必须注意 代码控制 对于大型网站, 核心应用系统和公用业务系统涉及到多个团队和开发工程师, 很大概率会一个项目由多个团队参与的情况, 如果代码控制环节出现问题会导致系统故障 网站代码控制核心是如何进行代码管理, 即能保证代码稳定又能保证不同团队直接开发互不影响 一般的使用GIT来进行版本控制 一般使用 git flow 的形式来进行版本管理 自动发布 网站的版本发布频繁, 发布过程需要很多团队一起合作, 首先在发布前可能会出现代码冲突, 其次, 各个团队之间的逻辑也可能出现了变化, 发布又相当于一次宕机事故, 因此网站的发布过程险象环生 一般的会将更新日期放在周三或周四, 这是因为发布之前的时间可以用来准备, 发布后留有一到两天时间可以修复问题 有人提出了一个 火车发布模型 ,即将每一次发布都看作是一次火车旅行, 每个修改的功能点视作旅行间的站台, 发布时对每一站都进行检查, 不通过的则不向车上装载, 确保到达终点时车上都是通过检查的功能 然而理想很美好, 现实中有可能会出现所有都有问题的现象, 或者某个功能点是领导迫切需要的, 其他的必须等着他等等问题 因为火车发布模型是基于规则的, 所以这个流程可以做到自动化, 自动构建代码分支来进行自动化测试和合并 灰度发布 自动化测试并不是万能的, 有的问题只有到了线上才能暴露出来, 这个时候就需要回滚, 即将老的版本上线, 等待开发人员修复问题, 但是大型网站的集群规模庞大, 回滚是很难的事情, 所以一般会进行灰度发布 即将集群分为很多部分, 第一次上一点点服务器, 查看问题是否出现, 没发现问题再上另一点点服务器, 一直到稳定后再全部更新, 如果发现问题回滚的机器就不多了 有时候, 上线一个新的功能, 可能有多个版本, 需要查看用户的反馈再决定上哪一个版本,此时就需要给一部分人看某个版本, 这也是小批量的, 业内称为 AB 测试, 其逻辑和灰度差不多 网站运行监控 网站的运行监控对于网站的结构和运维极为重要 监控数据采集 网站监控是一个广义的概念, 其包括了很多种类 用户行为日志 指用户在浏览器上做的所有操作及其所在的环境,包括 浏览器版本/OS/IP/地址/网络运营商/访问路径/停留时间 等等,这些数据可以统计出 PV/UV, 分析用户行为, 优化网站设计等, 搜集日志分为两个途径 服务端搜集: 负载均衡都带有日志系统, 所以很简单, 但是有些信息并不是真实的, 比如爬虫可以伪造请求参数 客户端搜集: 一般使用JS来记录和回传, 但是这样对服务器的压力很大, 因为是客户端搜集所以比服务端可靠性高, 因为并发很大所以一般使用分布式实时计算框架 Strom 来做或者是基于 Storm 自己开发 服务器性能监控 搜集服务器的实时 内存/CPU 等信息, 方便运维人员查看, 一般带有自动报警机制 比较出名的框架有 Ganglia 运行数据报告 比如缓存命中率/平均响应时间等数据,一般由运维人员部署 监控管理 监控的目的并不是简单的看, 还需要更加自动化 系统报警 当监控系统检测到某个指标超出阀值, 会向指定的邮箱发送告警邮件, 更高级的还有手机短信/语言等 失效转移 当某个服务器发生问题时, 自动的通知调度系统将此服务器下线 自动降级 当负载很高时, 通知调度系统将其服务降级或者暂时关闭","link":"/2021/09/04/website_architecture(3)/"},{"title":"大型网站技术架构-笔记(2)","text":"瞬时响应: 网站的高性能架构 A网站在100并发的时候, 接口响应时间是1s, 200并发时是10s B网站在100并发时是1.5s, 200并发是还是1.5s 这种情况下, 用户认为哪个网站访问快呢? 网站性能是客观的指标, 可以具体到响应时间/吞吐量等技术可以衡量的技术指标, 同时也是使用者的主观感受, 感受这个东西就比较微妙, 不好用技术指标来统计 网站性能测试 性能测试是性能优化的前提和基础, 也是性能优化结果的检查的度量标准. 不同视角下的网站性能有不同标准和优化手段 用户视角 从用户角度, 网站性能指用户在浏览器上直观的感受慢还是快, 那么, 用户感受到的时间, 其实流程是: 用户点击鼠标 &gt; 计算机浏览器解析指令 &gt; 找到需要发生的请求 - 发起请求 &gt; 网络通信 &gt; 服务器端接收到请求 &gt; 返回结果 &gt; 网络通信 &gt; 浏览器接收到结果 &gt; 解析结果 &gt; 展示到浏览器上 所以, 不同的浏览器/不同的计算机/不同的网络情况 可能导致用户感受到的延迟远远大于服务器请求的耗时. 在实际情况, 考虑使用前端手段优化速度, 比如 优化HTML样式 利用浏览器缓存 使用CDN/反向代理 目的是使浏览器更快显示用户感兴趣的内容, 尽可能近的获取页面内容, 即使不优化程序和架构, 也可以很大程度改善用户视角下的网站性能 开发人员视角 开发人员主要考虑程序本身及相关子系统的性能, 包括 响应延迟/系统吞吐量/并发处理能力/系统稳定性 等技术指标. 在实际情况, 考虑使用技术方面的优化手段, 比如 使用缓存加速数据读取 使用集群提高吞吐 使用异步加快请求响应与实现削峰 使用代码优化手段 运维人员视角 运维人员更关心基础设施的性能和资源利用率, 比如网络带宽/服务器硬件配置/数据中心网络架构/服务器/资源利用率 优化手段有: 建设骨干网络提高带宽 使用高性价比服务器 利用虚拟化技术提高资源利用率 性能测试指标 不同视角下有不同的性能标准, 不同标准有不同的指标 响应时间 一般指执行一个操作需要的时间, 从请求发送到收到最后的响应需要的时间, 是重要的指标, 直接反映系统的‘快慢’ 测试响应时间需要请求很多次, 比如一万次, 计算其平均值 并发数 指系统同时处理请求的数目, 可反映系统的负载特性 测试并发数时一般通过多线程模拟多个用户来模拟用户进行操作, 为了更加真实, 通常在两个请求间加入一个随机的等待时间, 这个时间被称作思考时间 吞吐量 指单位时间内系统处理的请求数量, 体现系统的整体处理能力. 常用的量化指标有: TPS-每秒事务数-事务指一系列正常操作(最常用) HPS-每秒HTTP请求数-并发 QPS-每秒查询数 在系统并发数由小到大的过程中. 服务器资源消耗也逐渐增大, 一般的, 系统吞吐量应该先逐渐增加, 到一定极限后继续增加会导致吞吐量下降, 然后到达崩溃点后资源耗尽, 吞吐量为0 对应的, 响应时间先是小幅度的上升, 到达吞吐量极限后快速的上升, 到达崩溃点后失去响应 网站优化需要尽量提高系统吞吐量, 最大限度利用服务器资源 性能计数器 是描述服务器和操作系统性能的一些指标, 包括 线程数量/内存使用/CPU使用/网络IO/磁盘占用 等指标, 当发现指标超过预定的报警阀值时应及时联系运维与开发人员处理 性能测试方法 性能测试 以系统设计时的性能指标为目标, 对系统不断施加压力, 验证系统在资源的可接受范围内是否能达到性能预期 负载测试 向系统不断的增加并发请求来增加系统压力, 一直到系统的某项或者多项性能指标达到安全临界值, 安全临界值的表现为超过该值之后系统处理能力会下降 压力测试 超过安全负载的情况下继续对系统施加压力, 直到系统崩溃 稳定性测试 被测试的系统在指定的 硬件/软件/网络环境 下, 给系统加载一定的业务压力, 使系统运行较长时间来观测系统是否稳定 性能优化策略 问题分析 如果有用户上报网站使用起来‘慢’, 必须对请求经历的各个环节进行排查, 定位问题 必须检查请求处理的各个环节的日志, 分析响应时间, 检查监控数据, 分析问题是代码问题还是硬件或者网络问题 Web前端优化 一般指网站业务逻辑前的部分, 比如: 浏览器加载/网站视图模型/图片服务/CDN服务 等 减少HTTP请求 - HTTP是无状态的应用层协议, 每次HTTP都要去建立链接和传输, 所以减少HTTP请求数量可提高性能, 比如合并 CSS/JS/图片 等资源 使用浏览器缓存 - 一般的, CSS/JS/ICON 等静态资源文件更新频率较慢, 将这些文件缓存在浏览器中可以很大的改善性能. 可以设置 HTTP 头的 Cache-Control 和 Exprise 属性来控制. 还要保证在发生更改时需要及时同步到用户的客户端中(不使用缓存), 可放置一个新的JS并更改主页面的HTML的JS引用将其引用到新的JS中, 需要更新N个JS时, 最好一次更新几个或一个避免访问量激增造成的网络堵塞 启用压缩 - 对文件(JS/CSS/HTML…)进行压缩, 在浏览器端进行解压缩可减少网络传输时间, 但是会对服务器和浏览器产生一定的压力 CSS放在页面最上面, JS放在页面最下面 - 浏览器在下载完CSS才会对页面进行渲染, 所以将CSS放置在页面最上方让浏览器尽快下载, JS在加载后立刻执行, 有可能对页面进行阻塞, 造成页面显示缓慢, 因此JS放在页面最下面. 例外是页面解析需要使用JS, 那么就不要放置在底部 减少Cookie传播 - Cookie一般保存一些用户的信息, 有可能比较大, 会对数据的传输造成负担, 因此要对写入Cookie的数据进行慎重考虑, 同时为了避免访问静态资源时也携带Cookie造成无意义的损耗, 可将静态资源设置成独立域名避免请求静态资源时发生Cookie CDN加速 CDN(内容分发网络)的本质是一个缓存, 将缓存放置在离用户最近的地方(物理), 使用户最快的获取数据 CDN部署在网络运营商的机房, 运营商又是终端用户的网络服务提供商, 因此用户请求数据会先到达CDN服务器, 当CDN存在用户需要的数据时直接从CDN返回, 这样可以加快用户访问速度, 同时减少数据中心的负载 CDN一般缓存静态资源, 比如图片/文件/css/JS等, 将其缓存到CDN会极大改善网页速度 反向代理 用户的请求发送到反向代理服务器, 反向代理服务器再转发到内部的服务, 因此, 反向代理服务器也可以保护网站的安全, 来自于互联网的请求必须经过代理服务器, 相当于在Web服务器和网络之间建立了一堵墙, 现在一般使用 Nginx 作为反向代理的服务, 可以完成多个操作, 比如 使用缓存 - 用户第一次访问静态资源时将该资源缓存到反向代理服务器中, 另一位用户访问时直接从代理服务器返回, 也可以将弱动态数据(博客/帖子/词条等一些实时性不强的数据)存储在缓存中, 当有数据变化时内部通知反向代理服务器将该缓存失效 负载均衡 - 如某个功能有多台服务器处理, 可将请求按照规则转发到某一台服务器, 提高系统处理能力和性能 应用服务器性能优化 分布式缓存 缓存一般指将数据存储在访问速度相对较高的存储介质中供系统使用, 缓存的访问速度快, 可以减少数据的访问时间, 另一方面如果缓存的数据是经过计算得到的, 那么该数据无需每次重新计算即可直接使用, 还起到了减少计算时间的作用 但是以下几种情况不适合使用缓存 频繁修改的数据 - 一般来说数据的读写比在2:1以上才需要加入缓存 没有热点的访问 - 访问量不大的数据没必要放置进缓存 数据不一致/脏读 - 缓存有过期时间, 有可能会出现缓存还没有过期时实际的数据已经更新的情况, 所以缓存的过期时间需根据实际情况确定, 有一种策略是数据更新时立即更新缓存, 这会带来更多系统开销和事务一致性的问题 缓存可用性 缓存的目的是提高数据读取性能, 理论上讲, 缓存数据的丢失或者不可用不会影响到程序的处理 但是随着业务的发展, 缓存会承担大部分的数据访问压力, 此时数据库的架构有可能会更多的依赖缓存, 如果缓存服务崩溃, 数据从数据库读取, 数据库可能会因为巨大的压力而宕机, 这种一般叫做缓存雪崩 为避免这种情况, 有的方法是对缓存进行热备, 但是这种设计本末倒置, 缓存本来就不应该当作可靠的数据源使用 比较好的方法是建立分布式缓存服务集群, 将缓存数据分布式存储. 就算其中一台宕机也不会对数据库产生多大压力 产品在设计之初就需要一个明确的定位, 什么产品实现什么功能, 什么不是产品的特征, 在产品的生命周期中, 会有很多困难和诱惑来修改产品的发展方向. 左右摇摆/什么都想做 的产品, 最后很有可能会成为一个没有生命力的四不像 缓存预热 缓存中存放热点数据, 热点数据是缓存系统使用LRU(最近最久未使用算法)对数据筛选淘汰出来的, 这个过程时间较久, 新启动的缓存系统在重建缓存数据的过程中, 对性能和数据库的提升都不高, 所以最好在缓存系统启动时把热点数据加载好, 这种手段叫 缓存预热, 比如 省市区三级联动/类目信息 等, 可以在缓存系统启动时加载到系统中 缓存穿透 对于不恰当的业务, 或者遭受到了恶意的攻击, 持续的高并发的请求某个不存在的数据, 缓存没有获取到这个不存在的数据, 那么会到数据库检索, 导致数据库压力大, 一般的对策是在这个频繁访问的数据到达阀值后将该数据也加入缓存, 其Value为Null Memcached https://www.memcached.org/ Memcached 是非常出名的分布式缓存框架, 被大量网站使用. 他的优点是 设计简单/服务器集群间互不通信/海量数据可伸缩 通信协议 Memcached使用TCP协议进行通信, 其序列化协议是基于文本的自定义协议, 非常简单, 大概是以一个命令关键字开头, 后面是命令操作 丰富的客户端 因其通信协议很简单, 因此主流的语言都有对应的客户端, 开发很方便 高性能的网络通信 服务端的通信模块基于 Libevent, Libevent是一个支持事件触发的网络通信库©, 其有 稳定/轻量/快速 等特点 高效的内存管理 使用固定内存分配, 避免了内存碎片管理的问题 集群架构互不通信 其分布式架构, 多台节点之间互不通信, 由客户端分布式算法来确定缓存存放在哪个节点, 取时根据key确定存储机器再进行获取, 我们可以将其比喻成一个圆, 有两个节点就相当于将这个圆分两半, 通过客户端hash一致性算法计算出来key是哪一个区间. 当添加或者减少某个节点, 也只影响这个节点相关的一个节点的数据 异步操作 任何可以晚点做的事情都应该晚点再做 异步一般搭配消息队列, 不仅可改善网站的扩展性. 还可以改善网站的性能. 需要注意的是, 用户在接收到返回时可能只是入了队列还未执行完成, 因此业务要相应的进行调整 使用集群 将业务搭载在集群中, 由负载均衡服务进行任务的分配, 比如我有三台机器进行负载均衡, 那么每台机器的压力则为全部的 3/1, 能有效提高效率和减少负载 代码优化 多线程 多线程带来的是效率的提升, 但是随之而来的是BUG的难以调试和线程安全问题, 线程安全的解决一般如下 将对象设计为无状态 使用局部对象 并发访问资源时使用锁 资源复用 系统运行时, 一定要减少开销很大的系统资源的创建和销毁, 比如 数据库的连接/网络通信连接/线程/复杂对象 等, 资源复用有两种模式 单例模式 对象池 数据结构 pass 垃圾回收 现在好多语言自己处理垃圾回收 存储性能优化 使用SSD(固态硬盘), 但是成本会提高","link":"/2021/09/04/website_architecture(2)/"},{"title":"zap包简单使用","text":"zap 是 uber 开源的一个日志记录的包, uber 在 go 的领域建树颇多, zap 更是优秀, 相比于自带的 log ,他有更多的功能, 当然, 最显眼的还是他很快, 本文介绍 zap 模块的基本使用 简单使用 zap的使用由 编码器 和 初始化 组成, 编码器表示输出的格式, DEMO如下(使用默认的编码器) 1234567891011package toolimport ( \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\")// Log zapLog对象var Log *zap.LoggerLog, _ = zap.NewProduction() 使用方法为直接调用生成的 Log, 比如 123456_, err := tools.DB.Exec(sqlStr, formPassWord, time.Now(), formPhone)if err != nil { tools.Log.Error(\"1002\", zap.Error(err)) // log tools.FormatError(c, 1002, \"error\") return} 将日志保存在本地 如果项目有日志服务进行日志收集那么到这里就结束了, 如果需要将日志写在本地你还需要看下去 我们使用第三方包来达到这个效果 lumberjack 该包可以自己进行日志的切割, 避免日志推挤过多, 当然你不需要日志切割等高级功能的话你完全可以直接使用 os.Create 来适配 结合 zap 使用如下 1234567891011121314151617181920212223242526272829303132333435363738394041package toolsimport ( \"github.com/natefinch/lumberjack\" \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\")// Log zapLog对象var Log *zap.Logger// 日志切割设置func getLogWriter() zapcore.WriteSyncer { lumberJackLogger := &amp;lumberjack.Logger{ Filename: \"api.log\", // 日志文件位置 MaxSize: 10, // 日志文件最大大小(MB) MaxBackups: 5, // 保留旧文件最大数量 MaxAge: 30, // 保留旧文件最长天数 Compress: false, // 是否压缩旧文件 } return zapcore.AddSync(lumberJackLogger)}// 编码器func getEncoder() zapcore.Encoder { // 使用默认的JSON编码 encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewJSONEncoder(encoderConfig)}// InitLogger 初始化Loggerfunc InitLogger() { writeSyncer := getLogWriter() encoder := getEncoder() core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) Log = zap.New(core, zap.AddCaller())} 使用方法与上方一致 Log.Error 代表生成一条 Error 的log, 参数一是 msg 内容, 这个是自定义的, 根据团队的规范来, 参数二是 err 信息, 使用 zap.Error 包装可生成额外的信息比如报错的路径/文件/行 等信息, 输出的日志类似 1{\"level\":\"ERROR\",\"ts\":\"2020-04-19T12:38:14.587+0800\",\"caller\":\"property/view.go:464\",\"msg\":\"1002\",\"error\":\"Error 1054: Unknown column 'propertyid' in 'on clause'\"}","link":"/2021/09/04/zap/"}],"tags":[{"name":"架构","slug":"架构","link":"/tags/%E6%9E%B6%E6%9E%84/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"做好自己","slug":"做好自己","link":"/tags/%E5%81%9A%E5%A5%BD%E8%87%AA%E5%B7%B1/"},{"name":"心理学","slug":"心理学","link":"/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"逻辑学","slug":"逻辑学","link":"/tags/%E9%80%BB%E8%BE%91%E5%AD%A6/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"}],"categories":[{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"人生","slug":"人生","link":"/categories/%E4%BA%BA%E7%94%9F/"}]}