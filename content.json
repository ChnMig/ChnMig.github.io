{"posts":[{"title":"个人常用的gitignore文件模板","text":"作用 git提交时忽略的文件 文件名 .gitignore Python 1234567891011121314151617181920212223242526272829303132333435# Byte-compiled / optimized / DLL files__pycache__/*.py[cod]*$py.class# Distribution / packaging.Pythonenv/build/dist/*.log# pyenv.python-version# dotenv.env# virtualenv.venv/venv/ENV/# VSCode settings.vscode# IDEA files.idea# OSX dir files.DS_Store# Sublime Text settings*.sublime-workspace*.sublime-project Go 1234567891011121314151617181920212223242526# Buildbulid/*.exe# dotenv.env# venv/vendor/# Log*.log# VSCode settings.vscode# IDEA files.idea# OSX dir files.DS_Store# Sublime Text settings*.sublime-workspace*.sublime-project","link":"/2021/09/04/commonly_used_gitignore/"},{"title":"Golang交叉编译","text":"前言 什么是交叉编译? 交叉编译指在某个平台编译另一平台能使用的文件 本文列出交叉编译的命令, 全程干货, 不多BB 正文 本文参考官方文档 12https://golang.google.cn/doc/install/source#introductionhttps://golang.google.cn/doc/install/source#environment 一条基本的编译命令结构如下(mac/linux) 1GOOS=linux GOARCH=amd64 go build main.go windows版比较特殊(目的一致,只是win加set) 123set GOOS=linuxset GOARCH=amd64go build main.go 这个命令有两个参数(main.go不做解释了) GOOS --&gt; GO,OS 生成文件执行的平台 GOPACH --&gt; GO,PACH 平台的架构 以上这条命令就是生成在amd64架构的linux上的可执行文件 注意的是, 如果你是在同等架构和系统上编译,例如在linux上编译linux的文件,则什么都不用带,go会自己判断 GOOS和GOARCH都有多个选项,可组合,对照如下 $GOOS $GOARCH aix ppc64 android 386 android amd64 android arm android arm64 darwin amd64 darwin arm64 dragonfly amd64 freebsd 386 freebsd amd64 freebsd arm illumos amd64 js wasm linux 386 linux amd64 linux arm linux arm64 linux ppc64 linux ppc64le linux mips linux mipsle linux mips64 linux mips64le linux riscv64 linux s390x netbsd 386 netbsd amd64 netbsd arm openbsd 386 openbsd amd64 openbsd arm openbsd arm64 plan9 386 plan9 amd64 plan9 arm solaris amd64 windows 386 windows amd64 当然,有些架构编译可能会出现错误,因为对他的支持还不完善,具体请看最上方的官方文档","link":"/2021/09/04/cross_compilation/"},{"title":"默认参数的坑","text":"在 https://docs.python.org/3/tutorial/controlflow.html#default-argument-values 中,有这样一段话 Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls: 大致意思为 重要警告：默认值仅计算一次。 当默认值是可变对象（例如列表，字典或大多数类的实例）时，这会有所不同。 例如，以下函数累积在后续调用中传递给它的参数： 下面给出了一个例子 1234567def f(a, L=[]): L.append(a) return Lprint(f(1))print(f(2))print(f(3)) 打印出来的结果是 123[1][1, 2][1, 2, 3] 这是因为, 作为默认参数, python在启动时就会将变量 L 建立, 我们在函数 f 内对 L 处理就会导致后来调用的 L 已经是修改过的 L 了, 我们可以通过打印 L 的内存地址来验证 123456789def f(a, L=[]): print(id(L)) L.append(a) print(id(L)) return Lprint(f(1))print(f(2))print(f(3)) 结果是 12345678945132896004513289600[1]45132896004513289600[1, 2]45132896004513289600[1, 2, 3] 当然, python的文档中也给出了一个推荐的方法 If you don’t want the default to be shared between subsequent calls, you can write the function like this instead: 12345def f(a, L=None): if L is None: L = [] L.append(a) return L 即: 将 L 默认为 None, 当该参数未传时, 将 L 设置为空列表, 在Python启动时 L 会设置为 None, 而当我们调用而不传参数 L 时, 在函数 f 内部重新给 L 赋值, 此时 L 为函数 f 内的一个私有变量, 其不会影响到参数 L 本身, 同样的我们可以通过打印内存地址来验证 1234567891011def f(a, L=None): print(id(L)) if L is None: L = [] print(id(L)) L.append(a) return Lprint(f(1))print(f(2))print(f(3)) 输出 12345678944673957764469232960[1]44673957764469232960[2]44673957764469232960[3] 当然我们也可以在不更改函数 f 的情况下, 在每次调用 f 的时候都传输参数 L, 如果想让他为一个空列表那就传一个空列表同样能解决问题, 因为你每次指定了值, 便会在传入时修改 L 的值 123456789def f(a, L=[]): print(id(L)) L.append(a) print(id(L)) return Lprint(f(1, []))print(f(2, []))print(f(3, [])) 输出 12345678944741681924474168192[1]44741681924474168192[2]44741681924474168192[3]","link":"/2021/09/04/default_param/"},{"title":"Dramatiq遇到的坑","text":"Dramatiq Bogdanp/dramatiq: A fast and reliable background task processing library for Python 3. (github.com) 是一个Python3的任务队列框架, 比较轻量化, 使用RabbitMQ或Redis作为存储介质, 当时看有2.xk的start就使用了, 结果在使用中发现了几个问题, 这里记录一下. 任务\"不发送\" 测试时, 发现总有些任务会遗留在管道中, work好像不接收, 也没有执行, 当重启work后就立刻接受了. 当时使用的存储介质是redis, 查看了源代码后发现问题 因为redis本身没有ack机制, dramatiq就自己实现了ACK, 在接受到任务后, 执行任务, 执行完成后放入到另一个xx.ack管道中同时删除原有管道的这一条数据.(消费者端实现ACK) 那么问题就出现了, 首先, 如果一个任务运行需要1小时, 那么在这1小时中, 查看redis会发现一直在原有管道中, 不知道是否是正在执行. 另外, 如果在这个任务执行中, 因为某些原因导致当前进程崩溃了, 如果没有来得及将中断的任务重新放入管道中(dramatiq虽然有处理措施, 但是毕竟是Python的多进程方式, 并不是很能保证可靠性), 就会造成这个任务\"丢失\" 最后决定更换存储介质为RabbitMQ, Dramatiq在使用RabbitMQ作为broker时使用的是RabbitMQ自带的ACK机制, 更加的成熟 ACK错误 客户端报错 1Consumer encountered a connection error: (406, 'PRECONDITION_FAILED - delivery acknowledgement on channel 1 timed out...... 更换为RabbitMQ之后, 发现消费者会报ACK错误, 在RabbitMQ中体现为生产者获取了任务后没有返回ACK, 在超时后被RabbitMQ重新放回任务队列 在上一次排查问题的过程中, 我发现消费者需要等待代码执行完毕后再ACK, 这本身也是没有问题的, 我搭配Dramatiq自身的超时来设置RabbitMQ的ACK超时, 比如这个任务可能会执行2小时, 我设置Dramatiq的超时为2.5小时, 设置RabbitMQ的超时为3小时, 这样让程序能自己处理, 但是还是出现问题 后来查看源代码时, 发现, Dramatiq有一个功能是预读, 即每次提前获取n个任务, 放在内存中, 当某一个任务完成后直接从内存中获取新任务, 省去网络io. 那这样就会出现问题, 因为在获取到任务后, RabbitMQ就会认为该任务处于等待ACK的状态, 如果每个任务需要1小时, Dramatiq获取了两个任务, 那么第二个任务就会超时, 当第二个任务执行完成后, Dramatiq进行ACK时就会被RabbitMQ拦截 看了代码后发现这个预读的数量参数可调, 从环境变量中获取, 我们设置 1export dramatiq_queue_prefetch=1 让他只获取一个然后立刻执行这一个即可 心跳超时 修复了ACK之后, 又发现了一个问题, 隔一段时间RabbitMQ就会有错误输出 1[erro] &lt;0.2398.0&gt; missed heartbeats from client, timeout: 60s 这代表的是客户端的心跳出现了问题, 当心跳超时后, RabbitMQ会主动断开与这个客户端的连接 查看项目的日志, 没有发现有任何错误或者警告输出 之前两个问题都是消费者的错误, 于是先排查的消费者, 发现消费者有心跳的维持且正常运行了 又回来看生产者的源代码, 发现**Dramatiq根本没有实现生产者的心跳**, 但是因为每次生产者发送任务时, 发送任务的代码写的是死循环, 连接被RabbitMQ断开后,或者因为别的原因没有被发送, 就再次生成新的连接, 再次发送, 而当发送失败时, 只打了一个Debug档的日志, 可能作者也知道这个问题, 然后就粗暴的使用捕捉错误然后重新建立连接的方式去做了😅 如果要解决, 可以设置心跳为0来去除心跳检测, url连接支持这个参数, 比如 1amqp://worker:BEQFRAmC5@127.0.0.1:5672?heartbeat=0 创建broker失效 我们是将FastApi与Dramatiq结合使用, 当接受到请求后做处理, 然后通过Dramatiq发送出去 为了更好的代码结构, 我们将代码整合了一下, 结果会出现连接不到RabbitMQ的问题 Dramatiq的使用一般是 12345import dramatiq@dramatiq.actor(max_retries=0, queue_name=\"test\", actor_name=\"test\")def scan(work): pass 建立如上的scan函数, 主要是加入装饰器dramatiq.actor 调用时是 12from . import workworker.iot.scan.send(send_info) 设置broker是 12345import dramatiqrabbitmq_broker = RabbitmqBroker(url=RABBITMQ_URL)rabbitmq_broker.add_middleware(ConfigMiddleware())dramatiq.set_broker(rabbitmq_broker) 改动主要是将设置broker的部分放置进了fastapi的启动事件, 原先是放置进了work文件夹的__init__.py里 刚开始以为是不是broker的设置比较晚了, 导致broker没有正常生效 后来发现在Dramatiq中broker是一个Golobal变量, 测试也发现即使在后面set_broker也可以 继续深入, 发现问题所在了 因为dramatiq.actor是作为装饰器使用, 而Python的装饰器内的代码, 实际上在导入时会执行, 举个例子 123456789101112131415161718192021222324252627registry = []def register(func): print('running register(%s)' % func) registry.append(func) return func@registerdef f1(): print('running f1()')@registerdef f2(): print('running f2()')def f3(): print('running f3()')def main(): print('running main()') print('registry -&gt;', registry) f1() f2() f3()if __name__ == '__main__': main() 打印结果为 1234567running register(&lt;function f1 at 0x0000027913AA8708&gt;)running register(&lt;function f2 at 0x0000027913AA8E58&gt;)running main()registry -&gt; [&lt;function f1 at 0x0000027913AA8708&gt;, &lt;function f2 at 0x0000027913AA8E58&gt;]running f1()running f2()running f3() 没错, 假如有个装饰器函数 a, 将函数 b 包裹在 a 中, 也就是 123456def a(): pass@adef b(): pass 在Python导入到这个代码时, 会将被 a 包裹的 b 变成 a(b), 会执行函数 a, 生成一个新的函数 a(b), 然后每次调用 b 时, 实际上在调用这个新的函数 而Dramatiq中, 在装饰器 dramatiq.actor 中的代码进行了初始化操作, 此时就将全局的broker生成了客户端供自己使用, 此时的全局broker还没有人为的设置, 变成了默认的127.0.0.1的RabbitMQ, 而后运行send时直接使用此客户端发送, 因为我们在修改代码后, 将创建broker的部分放置在了引用work之后, 导致了先生成了客户端, 而后来的自定义broker没有正确的被actor使用, 使用的是本地的RabbitMQ, 因为本地没有, 理所当然的就发送失败了 解决方法是排查项目的运行顺序, 在导入work之前先进行set_broker操作, 在work的__init__.py中 12from app.task.broker import setup_broker; setup_broker() # noqafrom . import xx 当导入包时运行__init__.py, 优先set_broker","link":"/2021/09/09/dramatiq_pit/"},{"title":"浅尝 ECDHE 协议流程","text":"前言 ECDHE 我之前是听都没听过, 但是新业务需要对前后端通信进行加密, 经过大佬推荐才知道有这个东西, 经过几天的学习和踩坑😇, 才大致明白其流程和使用方式. 过程坎坷, 好在最后还是成功运用到了业务中, 大大提高了业务的安全性. 👍 这里记录一下本人对 ECDHE 的理解和注意要点 ECDHE 椭圆曲线迪菲-赫尔曼金钥交换 - 维基百科，自由的百科全书 (wikipedia.org) 我们先来说说 ECDH, ECDH(Elliptic Curve Diffie–Hellman key exchange) 是一种密钥协商协议, 其精髓是通过椭圆曲线算法(ECC), 让客户端和服务端不传输私钥(需要传输公钥), 就可以计算出一样的结果(共有加密资料), 即使协商过程被第三方(中间人)知晓和监听, 也不会泄露密钥. 而 ECDHE(ECDH Ephemeral) 与 ECDH 无本质差别, 他们协商的流程一模一样, 只是ECDHE代表协商出的共有加密资料是临时的, 就算当前的加密资料泄露, 也不会影响其之前的历史数据被解密, 这是使用方式决定的, 大白话意思就是, 我们通过 ECDH 生成的共有加密数据有实效性, 会通过逻辑在一段时间或特定事件后重新协商, 而不是只协商一次, 如果只协商一次, 如果共有加密资料被泄露, 则之前的所有数据都可以解开. 这种共有加密数据资料泄露也不会对历史数据有影响的特性在密码学中被称为 前向安全性. 椭圆曲线密码学(ECC) ECC 是 ECDH 的核心 椭圆曲线密码学 - 维基百科，自由的百科全书 (wikipedia.org) 椭圆曲线算法(ECC) 是一种基于椭圆曲线数学的公开密钥加密算法, ECC 相比于 RSA 来讲, 有更短的密钥长度和相同等级的安全性(ECC被广泛认为是在给定密钥长度的情况下，最强大的非对称算法，因此在对带宽要求十分紧的连接中会十分有用.) 而且, ECC可以定义群之间的双线性映射, 即通过两个向量空间上的元素, 生成第三个向量空间上的元素的函数. 这使得他可以让两对数据通过交换和计算得出相同结果 ECC 算法衍生出了一些加密协议, 常见的有 ECDHE, MQV, ECDSA 等 ECC 的公钥其实对应了椭圆曲线数学的 XY 坐标, 根据种子随机生成 ECC 的私钥对应了椭圆曲线数学的 a 参数, 与公钥对应 ECC 计算出的 share 也是 XY 坐标 ECC 的种子有公开的几个, 例如secp128r1/secp256r1/secp192k1等, 两端的种子需要保持一致. 在线 ECDH 可参照 JavaScript ECDH Key Exchange Demo (stanford.edu) 椭圆曲线数学 椭圆曲线的数学原理在这里 椭圆曲线 - 维基百科，自由的百科全书 (wikipedia.org) 常言道, 学好数理化, 走遍天下都不怕. 可惜我是宅男, 不爱出门💀 这个原理在我的理解范畴之外了, 如果你对数学有兴趣, 可以尝试了解 三者关系 先诞生出的椭圆曲线数学公式, 而后有的基于椭圆曲线数学公式的密码学算法 ECC, 而ECC 又衍生出一些加密协议和协议, ECDH就是其中一种 破解概率 直接引用 wiki 原文 如果攻击者拥有大型量子计算机，那么他可以使用秀尔算法解决离散对数问题，从而破解私钥和共享秘密。目前的估算认为：破解256位素数域上的椭圆曲线，需要2330个量子比特与1260亿个托佛利门。相比之下，使用秀尔算法破解2048位的RSA则需要4098个量子比特与5.2万亿个托佛利门。因此，椭圆曲线会更先遭到量子计算机的破解。目前还不存在建造如此大型量子计算机的科学技术，因此椭圆曲线密码学至少在未来十年（或更久）依然是安全的。但是密码学家已经积极展开了后量子密码学的研究。其中，超奇异椭圆曲线同源密钥交换（SIDH）有望取代当前的常规椭圆曲线密钥交换(ECDH) ECDH 协商流程 前面说过, ECDHE 和 ECDH 不同是协商出的密钥有效期, 实际上协商流程是一致的, 所以这里严谨一点, 就叫 ECDH 协商流程 ECDH 本身的协商流程如下图所示(按照数字编号走流程): 上面说过, ECDH实际上是协商共享加密数据的过程, 难点在 ECC 的本身实现, 而交换的过程很简单, 互相发送自己生成的公钥即可, 公钥其实就是椭圆算法中的计算所需的 X/Y 坐标. 安全性 中间人只监听数据 两端协商密钥的过程中, 均未传输自己的私钥. 这样, 即使有中间人监听了两端之间的网络数据, 也只能获取到两端的公钥, 无法计算出真正的 shareX/shareY , 如图所示: 中间人监听并伪造客户端和服务端 如果中间人能做到, 同时伪造成客户端和服务端(对于客户端来讲是服务端, 对于服务端来讲是客户端), 那么ECDH生成的共享加密数据, 客户端与服务端无法对应 但是细想, 这时候, 虽然客户端与服务端的共享加密数据不相同, 但是ECDH只是一个协商密钥的过程, 中间人在此种情况下成功在客户端与服务端不知情的情况下正常走完了协商流程, 之后的加密数据, 如果使用了这个协商出的加密数据, 就会导致之后的数据被中间人截获/解析, 并且无感知, 例如: 不过, 这就逃脱了 ECDH 的范畴了, 这是真正需要开发者在业务中考虑的事情. ECDH在 TLS1.2 中的使用流程 TLS1.2 的详细立案可看: RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 (rfc-editor.org) 在 TLS1.2 协议中, 就使用了 ECDHE 来交换密钥, 我们来分析一下 TLS1.2 怎么使用 ECDHE 的: TLS v1.2 handshake overview | by apoorv munshi | Medium 如文章所述, 在步骤 Server Key Exchange &amp; Server Hello Done 时, 服务端不止返回了自己的 ECC 公钥, 还使用了 TLS 证书生成时的私钥对信息进行了签名(RSA), 而后, 客户端在接受到信息后, 尝试使用 TLS 证书中的公钥对信息进行验签, 用来保证数据一定是服务端返回的, 解决中间人篡改问题, 如图: 业务中使用 ECDHE 进行前后端通信数据加密 我们可以仿造 TLS1.2 协议来打造一个前后端通信加密的流程, 但是需要注意以下几点: ECDH 本身的协商过程是\"明文的\", 协商出共享加密数据后使用该数据对 body 进行加密传输才是\"安全的\" ECDH 变成 ECDHE 是加了时效性, 因此共享加密数据的淘汰策略很重要 ECC 生成的公私钥实际上是 XY 坐标, 考虑前端 JS 出问题生成 XY 重复的可能 修改后的密钥协商流程如下: 之后的请求, 均使用 aesKey1 进行 aes256cbc 加解密通信 针对问题1, 我们使用混淆生成 key 进行 aes 加密的方式, 对请求进行加密, 提高解密难度 针对问题2, 我们将单次协商的共享密钥与当前会话绑定, 并对会话进行有效期淘汰管理 针对问题2, 我们将单次协商的共享密钥与当前会话和用户设备绑定, 并对会话进行有效期淘汰管理, 当触发到淘汰标准时会将服务端密钥进行删除, 客户端需重新协商密钥才可重新通信 相关模块 ecdsa package - crypto/ecdsa - Go Packages elliptic package - crypto/elliptic - Go Packages","link":"/2022/10/17/ecdhe/"},{"title":"记一次flask框架返回200前端却拿到了504的问题","text":"问题 今天在调试代码时, 发现了一个诡异的问题, 我之前写了一个接口, 作用是接收上传的文件, 因为这个接口需要一定的权限控制, 所以我写了3个装饰器在上面, 这个项目是用的 flask, 代码类似于 123456@app.route('/upload', methods=['POST'])@login_requireds@verify_requireds@upload_requiredsdef upload_file(): pass 每个装饰器代码类似于 1234567891011def verify_requireds(func): # 阻止未审核的账户进行操作 @functools.wraps(func) def inner(*args, **kwargs): pass if user_dict.get(\"verify\") != 1: response_msg = {\"status\": 300, \"msg\": \"Sorry, Your · account is not audited\", \"msg_zh\": \"该账户未审核\"} return jsonify(response_msg) return func(*args, **kwargs) return inner 而在测试当中, 发现前端的请求一直是 504 错误(浏览器的f12调试显示), 而后端的log显示每次都正常返回了数据 然后就开始了漫长的捉虫 首先通过postman测试发现postman并没有问题, 猜测是不是跨域问题, 我们使用了 flask-cors 来进行跨域设置, 我们是这样设置的 123from flask_cors import CORSCORS(app, support_credentials=True) 为了印证该猜想, 我们开启了 flask-cors 的 debug 模式, 1logging.getLogger('flask_cors').level = logging.DEBUG 看到了options 请求时, debug 打印 1DEBUG Request to '/upload' matches CORS resource '/*'. Using options: {'origins': ['.*'], 'methods': 'DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT', 'allow_headers': ['.*'], 'expose_headers': None, 'supports_credentials': False, 'max_age': None, 'send_wildcard': False, 'automatic_options': True, 'vary_header': True, 'resources': '/*', 'intercept_exceptions': True, 'always_send': True, 'support_credentials': True} 所以初步排除了是跨域导致的问题 后来猜测是不是前端的代码问题, 后来前端 debug 调试发现是浏览器就返回了 504 错误, 就算是BUG也很难去通过前端去解决了 后来无意中发现, 其实并不是每次都返回 504, 当文件足够小时(1k左右), 请求都是正常的, 而文件大时, 则有一定几率会返回正常, 发现了这个现象时, 我们开始考虑是不是后端会 “夯住” 或者前端的连接并没有断开而是一直保持呢? 但是确实postman一切ok, 所以是不是请求有些异常, 而框架并没有很好的处理, postman兼容性很好, 忽略了这个错误呢? 我们使用软件在浏览器的客户端进行了抓包, 发现了问题 我们发现, 其实在前端发出请求后, 后端确实返回了200并且已经被读取, 但是后续又向前端发送了 RST 的数据包 搜了一下 RST 的作用, 其实就是代表服务端告诉客户端, 我要断开链接了, 你的还没发送的数据包直接丢掉吧, 可能就是这样的操作让前端框架以为后端断开链接了, 报了 504/502 错误 其实正常情况下, 触发 RST 的情况也只有去访问一个不存在的端口或服务时才会有, 所以前端框架这样统一判断也情有可原, 而且 RST 的滥用也可能引发安全问题 https://baike.baidu.com/item/RST%E6%94%BB%E5%87%BB 再结合之前发现的, 很小的文件几乎每次都正常, 我们大致找到了原因 因为我们现有的逻辑, 在装饰器执行过程中, 还没有获取 file 文件, 如果装饰器直接拦截, 此时可能 file 还没有完全接收完毕, 此时 flask 会发送 RST 告诉客户端抛弃发送, 而前端就会报错, 而小文件发送特别快, 不存在数据未发送完成的情况, 所以小文件是 ok 的 所以解决办法就非常简单了, 在装饰器前再加一个装饰器, 这个装饰器的作用是获取 file 文件, 顺便做一下如果没有 file 文件返回一个错误, 确保在服务端返回之前已经完全接收到了 file 文件即可. 我们增加一个 file 装饰器 123456789def file_requireds(func): # 对文件进行校验 @functools.wraps(func) def inner(*args, **kwargs): files = request.files.get('file') if not files: return jsonify({\"status\": 300, \"msg\": \"not find file\", \"msg_zh\": \"没有文件\"}) return func(*args, **kwargs) return inner 加入到接口的装饰器大军中 123456@app.route('/upload', methods=['POST'])@file_requireds@login_requireds@verify_requireds@upload_requiredsdef upload_file(): 再测试就完全可以了, 抓包也一切正常了 此例警醒我以后接受文件相关的接口一定要将文件全部获取到再进行操作, 或者是前端考虑解决办法","link":"/2021/09/04/flask_upload_file_504/"},{"title":"gin 框架的路由源代码解析","text":"前言 看源代码对我来讲还是有些困难, 因此本篇是在 https://www.liwenzhou.com/posts/Go/read_gin_sourcecode/ 的启发下编写 我这里只是略微的修改 gin的路由实现 使用 Radix Tree , 简洁版的前缀树 前缀树 别名: 字典树 / 单词查找树 / 键树 为什么使用前缀树 url是有限的,不可能无限长 url是有规律的 url是一级一级的, restful 更是如此 比如博客有的是按年和月分割 /2020/3/aaaa.html /2020/3/bbbb.html 此时使用前缀树更合适 gin的路由树 基数树/PAT位树, 是一种更节省空间的前缀树, 对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。 越常匹配的前缀, 权重越大 因为前缀树的构建模式导致越长的路径定位的时间越长, gin在注册路由时越长的路由排的越前, 如果最长的节点能优先匹配, 那么路由匹配所花的时间不一定比短路由更长 gin首先按照请求类型(POST/GET/…), 分为多个PAT树, 每个PAT树存储这个请求类型下面注册的路由, 路由又根据权重进行排序 路由树节点 路由树由一个个节点组成, gin的路由树节点由结构体 node 表示, 其构造结构如下 12345678910111213141516171819202122232425262728// tree.gotype node struct { // 节点路径，比如上面的s，earch，和upport path string // 和children字段对应, 保存的是分裂的分支的第一个字符 // 例如search和support, 那么s节点的indices对应的\"eu\" // 代表有两个分支, 分支的首字母分别是e和u indices string // 儿子节点 children []*node // 处理函数链条（切片） handlers HandlersChain // 优先级，子节点、子子节点等注册的handler数量 priority uint32 // 节点类型，包括static, root, param, catchAll // static: 静态节点（默认），比如上面的s，earch等节点 // root: 树的根节点 // catchAll: 有*匹配的节点 // param: 参数节点 nType nodeType // 路径上最大参数个数 maxParams uint8 // 节点是否是参数节点，比如上面的:post wildChild bool // 完整路径 fullPath string} 请求的方法树 在gin的路由中, 每一个 HTTP Method (GET/POST/PUT/…) 都对应了一棵PAT树, 在注册路由时会调用 addRoute 函数 1234567891011121314// gin.gofunc (engine *Engine) addRoute(method, path string, handlers HandlersChain) { // 获取请求方法对应的树 root := engine.trees.get(method) if root == nil { // 如果没有就创建一个 root = new(node) root.fullPath = \"/\" engine.trees = append(engine.trees, methodTree{method: method, root: root}) } root.addRoute(path, handlers)} 而在gin中, 每一个 Method 对应的树关系时是存放在一个切片中, engine.trees 的类型是 methodTrees , 其定义如下 123456type methodTree struct { method string root *node}type methodTrees []methodTree // slice 而 engine.trees.get 方法如下,(就是for循环) 12345678func (trees methodTrees) get(method string) *node { for _, tree := range trees { if tree.method == method { return tree.root } } return nil} 使用切片而不是使用map来存储, 可能是考虑到节省内存, 而且HTTP请求一共就9种, 使用切片也比较合适, 效率也高, 初始化在gin的 engine 中 12345678910111213141516171819func New() *Engine { debugPrintWARNINGNew() engine := &amp;Engine{ RouterGroup: RouterGroup{ Handlers: nil, basePath: \"/\", root: true, }, // liwenzhou.com ... // 初始化容量为9的切片（HTTP1.1请求方法共9种） trees: make(methodTrees, 0, 9), // liwenzhou.com... } engine.RouterGroup.engine = engine engine.pool.New = func() interface{} { return engine.allocateContext() } return engine} 路由匹配 当新的请求进入gin时, 会先经过函数 ServeHTTP 12345678910111213// gin.gofunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { // 这里使用了对象池 c := engine.pool.Get().(*Context) // 这里有一个细节就是Get对象后做初始化 c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) // 我们要找的处理HTTP请求的函数 engine.pool.Put(c) // 处理完请求后将对象放回池子} ServeHTTP 调用 handleHTTPRequest 函数(节选) 123456789101112131415161718192021222324// gin.gofunc (engine *Engine) handleHTTPRequest(c *Context) { // 根据请求方法找到对应的路由树 t := engine.trees for i, tl := 0, len(t); i &lt; tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // 在路由树中根据path查找 value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() // 执行函数链条 c.writermem.WriteHeaderNow() return } c.handlers = engine.allNoRoute serveError(c, http.StatusNotFound, default404Body)} 大致为先COPY一份路由的切片, 先找到与该请求对应的请求类型, 然后在这个请求类型的路由树种使用 getValue 方法查找对应的路由, 没有则返回404","link":"/2021/06/16/gin_router/"},{"title":"Golang Channel 实现原理","text":"前言 最近真高产啊, 果然有压力就有动力了, 不知道能保持多久, 真是痛并快乐着 什么是 Channel channel常用来作为多个协程直接通信, 在真正编写代码中使用频率非常高, 他就是一个管道, 先进先出, 那么, 作为程序员, 有必要了解channel的实现原理 数据结构 那么, 和往常一样, 还是从数据结构开始看起 12345678910111213type hchan struct { qcount uint // 当前队列中剩余元素个数 dataqsiz uint // 环形队列长度，即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 标识关闭状态 elemtype *_type // 元素类型 sendx uint // 队列下标，指示元素写入时存放到队列中的位置 recvx uint // 队列下标，指示元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列 sendq waitq // 等待写消息的goroutine队列 lock mutex // 互斥锁，chan不允许并发读写} 环形队列 chan 内部实现了一个环形队列作为缓冲区, 你指定的缓冲区的长度就是这个环形队列的长度 比如make(chan int, 6), 在多次进行操作之后, 他的数据可能是 1234567{ qcount: 2, // 代表队列中还有2个元素 dataqsiz: 6, // 代表队列长度(缓冲区)为6 buf: [0, 1, 1, 0, 0, 0], // 真正的数据, 假设两个数据都是1 sendx: 3, // 后续需要增加数据时, 从 buf 索引3开始 recvx: 1, // 需要读取数据是, 从 buf 索引1开始} 等待队列 我们知道, 如果缓冲区已满或者没有消费者获取数据时, 向 channel 写入数据会阻塞 我们也知道, 如果缓冲区已空或者没有生产者生产数据时, 从 channel 获取数据也会阻塞 对于一个 channel 来讲, 其生产者和消费者的 goroutine 存储在 hchan 的recvq和sendq中 recvq: 等待从 channel 读取数据的 goroutine sendq: 等待向 channel 写入数据的 goroutine 他们是互相唤醒的, 比如 当 goroutine 向 channel 写入数据时, 会唤醒recvq里的 goroutine 当 goroutine 从 channel 读取数据是, 会唤醒sendq里的 goroutine 一般情况下 recvq和sendq至少有一个为空, 也就是说一般情况下不可能存在既有向 channel 写入数据的 goroutine 等待, 又有从 channel 获取数据的 goroutine 等待. 除非在同一个 goroutine 中使用 select向 channel 一边写一边读 类型信息 在 channel 中, make 的时候就必须设定这个 channel 中存储的值的类型, 对应的字段如下 elemtype 每个元素的类型 elemsize 类型的大小, 主要用来在 buf 里定位元素 锁 channel 内部实际上有一个互斥锁来保证同时仅允许被一个 goroutine 进行操作, 关于互斥锁原理可以查看我的博客, 这里不多赘述 锁在hchan的字段是 lock 创建 channel 创建 channel 使用 make, 例如make(chan int, 6), 在 make 时, 就确定了 hchan 的buf/elemsize/elemtype/dadaqsize字段 写数据 向 channel 中写入数据的简单过程如下: 判断recvq是否为空, 不为空则代表有 goroutine 在等待读数据, 也就是说缓冲区中没有数据了或者没有缓冲区, 此时会直接从recvq中取出 goroutine, 直接把 goroutine 唤醒并且将数据写入, 结束写入过程 如果recvq为空, 代表此时没有 goroutine 在读数据, 此时, 如果 channel 中有缓冲区且缓冲区中有空余位置, 则直接将数据写入缓冲区, 结束过程 如果 channel 缓冲区已满或者没有缓冲区时, 将等待发送的数据写入当前 goroutine 中, 同时将当前 goroutine 加入到sendq, 等待被读取的goroutine唤醒 读数据 读数据与写数据类似, 过程如下: 判断sendq是否为空, 不为空则代表有 goroutine 在等待写数据, 此时判断缓冲区是否有值, 如果缓冲区有数据, 则从缓冲区首部(recvx)读取一个数据, 同时唤醒sendq中的等待写入 goroutine, 通知其写入数据, 结束流程 如果没有缓冲区, 则从senq中获取等待发送数据的 goroutine, 获取数据并唤醒这个 goroutine, 结束流程 如果当前sendq为空且缓冲区为空, 代表此时没有数据, 这时将 goroutine 加入到recvq中, 等待被写 goroutine 唤醒 关闭 关闭 channel 会把recvq中的 goroutine 全部唤醒, 然后将里面存储的数据设置为 nil. 然后将senq中的 goroutine 全部唤醒, 但是这些 goroutine 会导致 panic, 所以必须要确保这个 channel 在写入时都是开启的状态","link":"/2022/02/13/go_channel_theory/"},{"title":"go语言的context","text":"前言 听说是面试必问, 之前只有浅显的认知, 用的时候我一般传一个空的进去 😓, 今天难得有休息时间, 来学习一下 本文总结自七米老师的日志搜集项目视频 为什么需要context go的代码通常使用 goroutine 来提高代码速度, 这样的话怎么控制 goroutine 生成的协程就成了问题, 如果不小心出现了代码问题导致 goroutine 陷入死循环, 或者夯死, 就会导致意想不到的问题发生. 所以, context就出生了, 他类似一个信号, 通过传入的方式来让多个逻辑块进行联系, 以便做出操作 最基本的例子如下 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"context\" \"fmt\" \"sync\" \"time\")var wg sync.WaitGroup // wg等待func worker(ctx context.Context) { // context.Context一般都叫ctxLOOP: for { fmt.Println(\"worker\") time.Sleep(time.Second) // 等待1s select { case &lt;-ctx.Done(): // 如果接收到了ctx的Done信号, 就退出循环 break LOOP default: } } wg.Done() // wg完成}func main() { ctx, cancel := context.WithCancel(context.Background()) // 生成ctx和cancel wg.Add(1) go worker(ctx) time.Sleep(time.Second * 3) cancel() // 调用cancel即可通知ctx需要Done掉 wg.Wait() fmt.Println(\"over\")} 当goroutine嵌套时, 如果需要一起监听同一个ctx, 则可以使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"context\" \"fmt\" \"sync\" \"time\")var wg sync.WaitGroup // wg等待func worker(ctx context.Context) { // context.Context一般都叫ctx go worker1(ctx)LOOP: for { fmt.Println(\"worker\") time.Sleep(time.Second) // 等待1s select { case &lt;-ctx.Done(): // 如果接收到了ctx的Done信号, 就退出循环 break LOOP default: } }}func worker1(ctx context.Context) { // context.Context一般都叫ctxLOOP: for { fmt.Println(\"worker1\") time.Sleep(time.Second) // 等待1s select { case &lt;-ctx.Done(): // 如果接收到了ctx的Done信号, 就退出循环 break LOOP default: } } wg.Done() // wg完成}func main() { ctx, cancel := context.WithCancel(context.Background()) // 生成ctx和cancel wg.Add(1) go worker(ctx) time.Sleep(time.Second * 3) cancel() // 调用cancel即可通知ctx需要Done掉 wg.Wait() fmt.Println(\"over\")} context派生 我们看之前的代码 1context.WithCancel(context.Background()) 仔细看, 这里分成了两步, 一个是通过 context.Background() 生成了一个 emptyCtx 最上层的ctx 然后通过context.WithCancel来从这个最上层的ctx派生一个新的子ctx, ctx就像树一样, 从一个根一直发散 四种context context分为四种上下文可以派生, 分别为 WithCancel, WithDeadline, WithTimeout, WithValue, 这四种有不同的作用. 需要注意的是, 派生这件事, ctx 可以不停的派生子的context, 当一个被取消时, 他派生的上下文也会被取消 WithCancel 需要手动的出发Done才会取消 WithDeadline 指定一个终止时间(明确的时间), 当时间到就自动取消 WithTimeout 指定一个终止时间间隔, 当时间间隔到时自动取消 WithValue 这个目的不是取消, 而是上下文之间的数据传输 context结构 context其实是接口, 我们查看其结构 1234567891011type Context interface { Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct{} Err() error Value(key interface{}) interface{}} 其中: Deadline 方法返回当前的这个 ctx 被取消的时间 Done 返回的是一个 channel Err 返回ctx结束的原因, 只有确实结束了才会返回非空的值 ctx 被取消就返回 canceled 错误 ctx 超时结束则会返回 DeadlineExceeded 错误 value 方法则根据 key 返回 value , 这个是用来传递数据使用的 background()和TODO() 之前提到过, ctx实际上是可以派生的, 那么, 作为最顶层的ctx, 我们只能选择两种, background 和 TODO, 由这两个生成的ctx来派生更多的ctx background用于 初始化/main/测试 中, 也就是第一个, 最顶层的ctx TODO目前还没有具体的使用场景, 我们知道, go语言的传参是必须的, 如果你并不想使用ctx, 但是第三方的又需要你传, 或者你还没想好它的作用, 你可以使用TODO 这两个生成的ctx都是不可取消, 没有截止时间, 没有携带任何值的emptyCtx 四种with函数派生 之前简单的介绍了 WithCancel, WithDeadline, WithTimeout, WithValue, 这里分别举出例子 WithCancel WithCancel 的函数定义 1func WithCancel(parent Context) (ctx Context, cancel CancelFunc) 该函数返回一个派生的新ctx和一个done的函数, 当调用这个函数, 就会关闭上下文的Done通道 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"context\" \"fmt\")func gen(ctx context.Context) &lt;-chan int { dst := make(chan int) n := 1 go func() { for { select { case &lt;-ctx.Done(): return // 监听到结束后, 退出函数, 进行垃圾回收 case dst &lt;- n: n++ } } }() return dst}func main() { ctx, cancel := context.WithCancel(context.Background()) defer cancel() // 关闭管道 for n := range gen(ctx) { fmt.Println(n) if n == 5 { break } }} WithDeadline WithDeadline的函数定义 1func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) 传参不止一个ctx, 还有一个time.Time, 标识这个ctx的超时时间, 依旧返回了done函数, 派生的ctx在任务到期后会自动关闭, 而在到期之前可以通过手动调用cancel函数来关闭 123456789101112131415161718192021222324package mainimport ( \"context\" \"fmt\" \"time\")func main() { d := time.Now().Add(50 * time.Millisecond) // 获取当前时间50ms后的时间 ctx, cancel := context.WithDeadline(context.Background(), d) // 把过期时间传入 // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。 // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。 defer cancel() select { case &lt;-time.After(1 * time.Second): fmt.Println(\"overslept\") case &lt;-ctx.Done(): fmt.Println(ctx.Err()) }} 需要注意的是, 推荐依旧注册一个cancel的执行, 这是为了保险起见 WithTimeout WithTimeout的函数定义 1func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) 与Deadline不同的是, 这里传的是一个时间间隔, 等待时间间隔完成后发起关闭 这种方式同常用于超时控制 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"context\" \"fmt\" \"sync\" \"time\")var wg sync.WaitGroupfunc worker(ctx context.Context) {LOOP: for { fmt.Println(\"db connecting ...\") time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒 select { case &lt;-ctx.Done(): // 50毫秒后自动调用 break LOOP default: } } fmt.Println(\"worker done!\") wg.Done()}func main() { // 设置一个50毫秒的超时 ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50) wg.Add(1) go worker(ctx) time.Sleep(time.Second * 5) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\"over\")} WithValue WithValue可以在ctx中写入数据库, 也可以读取数据 1func WithValue(parent Context, key, val interface{}) Context WithValue返回派生的ctx, 使用方法如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"context\" \"fmt\" \"sync\" \"time\")type TraceCode stringvar wg sync.WaitGroupfunc worker(ctx context.Context) { key := TraceCode(\"TRACE_CODE\") traceCode, ok := ctx.Value(key).(string) // 获取ctx中存储的\"TRACE_CODE\"的值 if !ok { fmt.Println(\"invalid trace code\") }LOOP: for { fmt.Printf(\"worker, trace code:%s\\n\", traceCode) time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒 select { case &lt;-ctx.Done(): // 50毫秒后自动调用 break LOOP default: } } fmt.Println(\"worker done!\") wg.Done()}func main() { // 设置一个50毫秒的超时 ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50) // 向ctx添加值 \"TRACE_CODE\": \"12512312234\" ctx = context.WithValue(ctx, TraceCode(\"TRACE_CODE\"), \"12512312234\") wg.Add(1) go worker(ctx) // 传入 time.Sleep(time.Second * 5) cancel() // 通知子goroutine结束 wg.Wait() fmt.Println(\"over\")} 注意事项 context 以参数的方式传递 如果需要context, 应该吧context当做第一个参数, 且别名为 ctx 如果一个函数需要context, 而你又没有, 又不想使用, 可以传入context.TODO() context的WithValue应当传递必要的数据, 不要什么数据都放里面. 切记不要用他来替代传参的方式 context是线程安全的, 可以放心的在多个goroutine中传递 派生函数返回值第二个都是done, 执行可以关闭这个context","link":"/2021/10/16/go_context/"},{"title":"go 基础笔记存档","text":"前言 考虑到印象笔记以后不续费了,这里转存到博客园一份 因内容是自己写的笔记, 未作任何润色, 所以看着很精简, 请见谅 查看官方文档 在新的go安装包中,为了减小体积默认去除了go doc 安装go语言后在DOS中输入 1godoc -http=:9000 然后在浏览器中打开 127.0.0.1:9000 即可(不能关闭DOS) 该系列参照了大佬的学习路线,加上本人的代码实践,大佬链接 https://www.liwenzhou.com/posts/Go/go_menu 目录结构 GOPATH &gt; src 代码(pkg包/bin编译后文件) &gt; 域名 &gt; 用户名 &gt; 项目 &gt; 模块 双引号单引号 单引号代表字符 &gt; ‘a’ 双引号代表字符串 &gt; “abcd” 中文最少3位所以只能用双引号 编译代码 进入目录(项目) go build -o 文件名 main.go main.go是项目主入口 调试代码 1go run 文件 设置生成文件的格式(跨平台) 命令行 12345678// 生成linux可执行文件SET CGO_ENABLED=0 //禁用CGOSET GOOS=linux //设置目标平台为linuxSET GOARCH=amd64 //目标架构为amd64// 生成winSET GOOS=windows// 生成macSET GOOS=darwin git控制 只需控制 src 下即可 变量 变量声明后必须使用不然编译失败 变量可以重复赋值但是无法赋值其他变量类型 变量声明在函数外代表该文件的全局变量 在同一个作用域内不能重复声明同名变量 变量声明后的操作只能在函数中写 引用类型和值类型 引用类型空值为 niu 值类型空就为空 声明单个变量 1var 变量名 变量类型 变量声明后必须要使用不然编译失败 声明多个变量 声明多个变量 12345var ( 变量名 变量类型 变量名 变量类型 ...) 变量默认值 命令变量后有默认值 string - “” int - 0 bool - false 变量声明时指定值 创建变量时指定值 1var 变量名 变量类型 = 值 声明变量时直接指定变量类型 自动识别值的类型并指定变量类型 1var 变量名 = 值 fmt模块 打印输出 导入 1import \"fmt\" 带换行输出 可换行 1fmt.Println() 格式化(带换行)输出 可加 %s 等占位 1fmt.Printf() 短变量声明 在[函数内部]声明只能在该函数内使用的变量 声明短变量 1变量名 := 值 等同于 1var 变量名 变量类型 = 值 函数返回值 return返回 123func foo()(返回值1类型, 返回值2类型, ...){ return 返回值1, 返回值2, ...} 匿名变量 接收不需要的值 例如函数a返回两个值,我们只需要值1,但是我们调用该函数必须要接受2个值 如果我们接收值2而不使用则会 编译失败(定义变量而不使用) 此时可以将值2设为匿名变量 匿名变量可以重复声明 常量中也可以声明匿名变量 1234func foo()(string, int){ return \"aa\", 500}name, _ := foo() 此时我们使用匿名变量占位 常量 一旦赋值不可更改 常量在定义时必须赋值 如没有赋值就和上一行一样(必须结构与上一行一样不然报错) 1const 常量名 = 值 123456const ( 常量名1 = 值1 常量名2 = 值2 常量名3 // 如不赋值默认拿上一行的值 常量名4) 1234const( a, b = 1, 2 c, d // 1, 2) 枚举 iota 常量计数器,只能在常量表达式中使用 在一个 const 中,初始值是0, 声明一个常量则const+1 每一个 const 中, 都会重新初始化为0 就算某一行定义多个常量 iota也只+1 12345const ( a = iota // 0 b = iota // 1 c = iota // 2) 经典题目 12345const ( a = iota // 初始化0 _ = iota // 声明匿名常量,所以+1 b = iota // 2) 1234567const ( a = iota // 初始化0 b = 100 // 赋值100 c = iota // 定义两个常量所以为2 d // 不定义默认跟上一行也是iota所以为3)const e = iota // 初始化0 12345678const ( _ = iota // 0 KB = 1 &lt;&lt; (10 * iota) // 1&lt;&lt;10(位运算,2进制向左移10位) == 2的10次方 == 1024 MB = 1 &lt;&lt; (10 * iota) // 2的20次方 GB = 1 &lt;&lt; (10 * iota) // 2的30次方 TB = 1 &lt;&lt; (10 * iota) PB = 1 &lt;&lt; (10 * iota)) 12345const ( a, b = iota + 1, iota + 2 // iota=0, a=1, b=2 c, d // iota=1, c=2, d=3 iota声明常量一行变一次,不判断一行定义几个 e, f // iota=2, e=3, f=4) 数据类型1 整型 int8, int16, int32, int64 int8: 最大8位的二进制数, 最大2的9次方-1 其余类似 在32位系统, int == int32 64位, int == int64 unit8, uint16, uint32, uint64 在32位系统, uint == uint32 64位, uint == uint64 len 返回对象的长度 进制 Go中,新建变量时,二进制/八进制等等 都可以写成 int Go会根据特征判断进制 比如 八进制都是以 0 开头 十六进制以 0x 开头 我们想打印出来可以使用 Printf 1234567891011121314package mainimport \"fmt\"func main() { var a int = 10 // 二进制 var b int = 077 // 八进制 var c = 0xff // 十六进制int可省略,可自己判断 fmt.Println(a, b) // 转换成十进制 fmt.Printf(\"%b \\n\", a) // b代表二进制 \\n换行 fmt.Printf(\"%o \\n\", b) // n代表八进制 fmt.Printf(\"%x \\n\", c) // x代表十六进制 fmt.Printf(\"%p\", &amp;a) // 打印数据a的内存地址(十六进制)} 浮点 浮点数是不准确的(Python: 0.1+0.2 = 0.30000000000000004) 如果涉及到金钱等对小数敏感的业务 不要用浮点数 业内使用较多的两种方法 方法1 将数字转换成字符串进行逻辑编写 方法2 将小数变成整数计算后再变成小数 数据类型1(补充) 布尔 go语言不允许将整形强制转换为布尔型 布尔默认 False 布尔无法参与数值运算,也不能与其他类型转换 字符串 utf-8编码 字符串转义 \\r 回车(光标移动至下一行行首) \\n 换行(移动至下一行同样位置) \\t 制表符 \\’ 单引号 \\‘’ 双引号 \\ 反斜杠 多行字符串 多行字符串里不存在转义 `aa bb cc ` 字符串常用方法 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"strings\")// 字符串操作func main() { // 字符串位数 s1 := \"我是字符串1\" fmt.Println(len(s1)) // 字符串位数(s1包含中文返回16) // 字符串拼接 s2 := \"我是字符串2\" fmt.Println(s1+\"affag\"+s2) // 推荐使用+号 s3 := fmt.Sprintf(\"%safaf%s\", s1, s2) // Sprintf返回拼接后的字符串 fmt.Println(s3) // 字符串分割 ret := strings.Split(s1, \"是\") //中文不能单引号 fmt.Println(ret) // 判断是否包含 ret2 := strings.Contains(s1, \"是\") fmt.Println(ret2) // 判断前缀(第一个字符) ret3 := strings.HasPrefix(s1, \"我\") fmt.Println(ret3) // 判断后缀(最后一个字符) ret4 := strings.HasSuffix(s1, \"1\") fmt.Println(ret4) // 求子串位置 s4 := \"123321\" fmt.Println(strings.Index(s4, \"1\")) // 1在s4中的第一个位置 fmt.Println(strings.LastIndex(s4, \"1\")) // 1的最后一个位置 // join(合并切片为str) a1 := []string{\"a\", \"b\"} fmt.Println(strings.Join(a1, \"-\"))} byte和rune类型 当我们使用 Println 输出中文时,发现打出来的是一串数字,例如 “中文” 打印出来是 20013 ,实际上是字符串对应的 ASCII 码 当我们使用 len 函数求字符串的长度时,要格外注意,在 UTF8 中中文最少占用3个字节 一个字节等于8位(bit) byte类型, (unit8类型), 代表 ASCII码, 英文这种占一个字节的字符 rune类型, (int32), 代表UTF8, 中文/日文等复合字符 1234567891011121314151617181920212223242526package main// 字符import \"fmt\"func main() { s1 := \"ChnMig\" c1 := 'A' fmt.Println(s1, c1) s2 := \"中文\" c2 := '中' fmt.Println(s2, c2) fmt.Println(c2) s3 := \"Hello,中国\" // 遍历字符串 for i:=0;i&lt;len(s3);i++{ fmt.Printf(\"%c\\n\", s3[i]) // 中文乱码 } // for range 不乱码 for k, v := range s3{ fmt.Printf(\"%d%c\\n\", k, v) }} 类型强制转换 123456789101112package mainimport \"fmt\"// 强制类型转换func main() { s1 := \"big\" // 建立s1 ByteArray := []byte(s1) // 建立一个存放类型为byte的列表将s1赋值进去(赋值时会强制转换为byte) ByteArray[0] = 'p' // 按索引修改 s1 = string(ByteArray) // 转换为str重新赋值给s1 fmt.Println(s1)} 流程控制 if 在if中也可以写赋值语句 if age := 18{ ​ … } 注意此处 age 变量作用域只在该if语句中 12345678910111213141516package mainimport \"fmt\"// if/ else iffunc main() { age := 19 if age &gt; 18{ fmt.Println(\"18+\") }else if age &lt; 18{ // else, else if 不能再换行写 fmt.Println(\"FBI WARING\") }else { fmt.Println(18) }} for for 初始语句;条件表达式;结束语句{ ​ 循环体语句 } 初始语句和结束语句可以省略 123456789101112package mainimport \"fmt\"// 初始语句结束语句省略func main() { age := 18 for age &gt; 0{ fmt.Println(age) age-- }} 12345678910package mainimport \"fmt\"// 完整版func main() { for age:=18;age &gt; 0;age--{ fmt.Println(age) }} 123456789package main// 死循环func main() { for { //死循环(慎用) }} switch 简略判断 12345678910111213141516package mainimport \"fmt\"// switchfunc main() { age := 18 switch age { // switch 要判断的值 case 1: // 判断 fmt.Println(\"1\") case 18: // 判断 fmt.Println(\"18\") default: // 以上判断都不符合 fmt.Println(\"以上判断全都不符合\") }} switch 也可以一次判断多个 12345678910111213141516package mainimport \"fmt\"// switchfunc main() { age := 18 switch age { case 1, 2, 3, 4, 5: // 判断 fmt.Println(\"1\") case 18, 19, 20: // 判断 fmt.Println(\"18\") default: // 以上判断都不符合 fmt.Println(\"以上判断全都不符合\") }} 也可以在case里比较 1234567891011121314package mainimport \"fmt\"// switchfunc main() { age := 18 switch { case age &lt; 25: fmt.Println(\"&gt;25\") case age &gt; 25: fmt.Println(\"&lt;25\") }} break 和 continue break 终止循环/遍历 continue 跳出一次循环/遍历 fmt模块 https://www.liwenzhou.com/posts/Go/go_fmt/ println 行内输出 printf 带格式化参数输出 %d 整数 %.2f 小数(精确小数点两位) %v 万能 %T 变量类型 %% 一个% 数组 数据类型元素的集合, 在定义时指定数据类型,不可插入其他的数据类型 数组可修改,但是数组长度无法改变 数组的数据库类型是长度+类型,所以两个数组长度不一致则数据类型不一致 数组是 值类型 的,如果将数组a赋值给数组b, 再更改数组a中的值数组b不会更改, 等同于Python的深Copy 12345678910111213141516171819package mainimport ( \"fmt\")func main() { a := [5]int{1, 2, 3, 4, 5} b := [10]int{1, 2} //定义10位但是只填了两位那之后的默认0 fmt.Println(a) fmt.Println(b) var c [3]int //用var定义 var d [3]int = [3]int{1, 2, 3} //用var定义并赋值 fmt.Println(c) fmt.Println(d)} 自动判断几位 1234567891011package mainimport ( \"fmt\")func main() { a := [...]int{1, 2, 3, 4, 5} // [...]会自己查询赋值几位然后填充位数 fmt.Println(a)} 根据索引赋值 如果我们定义长度100的数组第50位为3 a := [100]int{50: 3} 数组的遍历 1234567891011121314151617181920package mainimport ( \"fmt\")func main() { a := [100]int{50: 3} //通过索引遍历 for i := 0; i &lt; len(a); i++ { fmt.Println(a[i]) } //通过range遍历 for index, value := range a { fmt.Println(index, value) }} 多维数组 数组套数组… 一个数组是一维 多维数组只有第一层能使用 … 确定长度 多维数组也是 值类型 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"fmt\")func main() { //声明后赋值 var a [3][2]int //[[0, 0] [0, 0] [0, 0]] a = [3][2]int{ [2]int{1, 2}, //这里给a的第一位[0, 0]赋值 [2]int{4, 5}, //第二位 } fmt.Println(a) //[[1 2] [4 5] [0 0]] //声明时赋值 var b = [3][2]int{ [2]int{1, 2}, [2]int{4, 5}, } fmt.Println(b) //多维数组索引 fmt.Println(a[0][0]) //1 //多维数组遍历 for i := 0; i &lt; (len(a)); i++ { for k := 0; k &lt; (len(a[i])); k++ { fmt.Println(a[i][k]) } } //range for _, v1 := range a { for _, v2 := range v1 { fmt.Println(v2) } }} 切片 数组建立时就需要指定长度,长度不可更改 切片和数组一样都只能存储相同数据类型,但是他的长度是可变的 切片是引用类型 引用类型指公用一个内存地址 更改一个值会造成所有共用该地址的值变更 切片有容量的概念,容量代表切片的最大长度,但是是可扩充的 切片初始容量为他生成时的长度 切片如果是由数组产生,那么他的容量为 切片开始处 到 数组结束处 长度 切片大小: 当前切片长度 切片地址: 切片中第一个元素地址 len() 切片容量: 底层数组最大能存放的元素个数 cap() 切片扩容 切片扩容策略是发现不够的情况下每次扩容到前容量的两倍(x2)(不一定,小于1024时是这样,大于1024是1/4) 发现长度超出容量 &gt; 丢弃老内存 &gt; 生成新数组(容量x2) &gt; 切片 append 向切片中追加元素 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"func main() { //主动声明 var a = []int{1, 2, 3} //不规定长度即为切片(内部其实是先生成一个数组然后切片) fmt.Printf(\"a:%T\", a) //从数组得到切片 var b = [3]int{1, 2, 3} var c []int c = b[0:2] //从索引0切到1,c=b[:]从开始切到结束,c=b[:2]从开始切到索引1,c=b[1:]从索引1切到最后 fmt.Println(c) //切片大小(当前) fmt.Println(len(c)) //容量(底层数组最大放多少) //切片初始容量为他生成时的长度 fmt.Println(cap(c)) //cap查看当前切片的容量 //切片追加 var d = []int{} //没有填充数据时没有内存地址 fmt.Println(d, len(d), cap(d)) //[] 0 0 d = append(d, 1) //append(d, 1, 2)代表添加两个 fmt.Println(d, len(d), cap(d)) //[1] 1 1} 切片COPY 切片是指向型数据,所以将a切片赋值给b后b变动会影响到a 如果规避此问题可以使用 COPY 函数 123456789101112131415161718package mainimport \"fmt\"func main() { a := []int{1, 2, 3} b := a b[0] = 100 fmt.Println(a) //[100 2 3] fmt.Println(b) //[100 2 3] var c []int //为空没有申请内存 c = make([]int, 3, 3) //使用make函数申请长度为3容量为3的内存 copy(c, a) //copy a的值到c,如果c的容量小于a则会数据丢失 a[0] = 10 fmt.Println(a) //[10 2 3] fmt.Println(c) //[100 2 3]} 切片内容的删除 很遗憾,切片暂时没有某个方法可以删除某个元素 我们只能通过手动赋值的方式来达到目的 123456789package mainimport \"fmt\"func main() { a := []int{1, 2, 3, 4} a = append(a[:2], a[3:]...) //先切索引1之前的元素再切1之后的元素然后重新赋值给a, ...是将切片的多个内容切分, ...写在追加的参数后,多个参数多个... fmt.Println(a) //[1 3 4]} 难题 12345678910111213141516171819202122package mainimport \"fmt\"func main() { //切片地址永远指切片起始的地址内存,不包含结尾 a := [4]int{1, 2, 3, 4} //数组 b := a[:] //切片 b[0] = 100 fmt.Println(a[0]) //100,因切片是指向性数据,b与a共用内存 c := a[2:3] fmt.Println(c) fmt.Println(cap(c)) //切片如果是由数组产生,那么他的容量为 切片开始处 到 数组结束处 长度 d := b[:] fmt.Println(d) //[100 2 3 4],因指向性数据,dcb都是指向数组a e := d[2:] fmt.Println(e) //切片不是从头开始所以地址发生了变化} 数组排序 方便快捷的将数组排序 12345678910111213package mainimport ( \"fmt\" \"sort\")func main() { a := [5]int{5, 6, 1, 3, 2} sort.Ints(a[:]) //sort.Ints方法将切片排序 fmt.Println(a) //因切片数据指向数组所以实际上排序了数组} map 引用类型 maps是无序的 有k有v 的数据类型 map必须经过初始化才可以正常使用 12345678910111213141516171819202122232425package mainimport ( \"fmt\")func main() { var a map[string]int //声明map,k为string类型,v为int,不赋值为nil fmt.Println(a) //map[] //初始化(初始化后部位nil但是还是空) a = make(map[string]int, 8) //map可不指定容量但是推荐指定 fmt.Println(a) //map[] //添加键值对 a[\"one\"] = 1 a[\"two\"] = 2 fmt.Println(a) //map[one:1 two:2] //声明+初始化 b := map[string]int{ \"one\": 1, \"two\": 2, } fmt.Println(b) //map[one:1 two:2]} map常用方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"fmt\" \"sort\")func main() { // 判断某个键存不存在 a := map[int]int{ 1: 1, 3: 3, 2: 2, } v, ok := a[1] //返回两个值, 值1为这个键的值, 2为这个键存不存在 fmt.Println(v, ok) //1 true v1, ok1 := a[5] fmt.Println(v1, ok1) //0 false 不存在值1为值类型的默认值,2为false //遍历map for k, v := range a { fmt.Println(k, v) } //只遍历map的key for k := range a { fmt.Println(k) } //遍历map的v for _, v := range a { fmt.Println(v) } //按照某个顺序遍历 // 取key存放至切片 // 切片排序 // 按key对map排序 keys := make([]int, 3) for k := range a { keys = append(keys, k) } sort.Ints(keys) for _, key := range keys { fmt.Println(key, a[key]) } // 删除键值对 delete(a, 1) //(map, 键)} 切片与map混合 1234567891011121314151617181920package mainimport ( \"fmt\")func main() { //元素类型为map的切片 var a = make([]map[string]int, 8) //只完成了切片的初始化 a[0] = make(map[string]int, 2) //初始化切片[0]的map a[0][\"one\"] = 1 fmt.Println(a) //[map[one:1] map[] map[] map[] map[] map[] map[] map[]] //值为切片的map var b = make(map[int][]int, 8) // map初始化 b[0] = make([]int, 5) //切片初始化 b[0][0] = 1 b[0][1] = 2 fmt.Println(b) //map[0:[1 2 0 0 0]]} 函数 函数是GO语言的重要组成部分 函数有 函数/匿名函数/闭包 函数名由 字母/数字/下划线 组成,函数名的第一个字母不能是数字, 在同一个包内函数名不能重复 参数由参数变量和类型组成,多个参数逗号分隔 返回值也由返回变量和类型组成, 也可以只写返回值类型,多个返回值由 () 包裹,逗号分隔 调用函数时,可以不接收函数的返回值 返回值如果指定了返回的变量名, 函数体内不用再 var 该变量, return也不用指定变量名 函数没有默认参数 函数可以赋值给另一个变量,此时该变量就是一个函数 函数组成 123func 函数名(参数)(返回值){ 函数体} 例如 1234567891011121314package mainimport \"fmt\"func sum(x int, y int) int { // 求和 return x + y}func main() { s := sum(1, 2) fmt.Println(s)} 函数接收n个参数 1234567891011121314151617package mainimport \"fmt\"func sum(a ...int) int { //参数名后加...代表接收多个,但是参数类型是定死的,这样接受的参数为一个切片,此时a可不传 ret := 0 for _, v := range a { ret = ret + v } return ret}func main() { s := sum(1, 2, 3) fmt.Println(s)} 1234567891011121314151617package mainimport \"fmt\"func sum(a int, b ...int) int { //传a为int,b为多个,a必传 ret := a for _, v := range b { ret = ret + v } return ret}func main() { s := sum(1, 2, 3) fmt.Println(s)} 123456789101112package mainimport \"fmt\"func sum(a, b int) int { //如果a,b都为int那么可以简写 a, b int return a + b}func main() { s := sum(1, 2) fmt.Println(s)} 函数返回多个值 123456789101112131415package mainimport \"fmt\"func calc(a, b int) (sum, sub int) { //多返回值 sum = a + b //sum与sub已经定义 sub = a - b return //直接return会自己寻找返回值}func main() { a, b := calc(1, 2) fmt.Println(a, b)} defer 通常用于时间的记录/资源释放等等 123456789101112package mainimport \"fmt\"func main() { // defer延迟执行,代码将要结束时再执行,执行顺序为先读到的后执行 fmt.Println(\"go\") defer fmt.Println(1) defer fmt.Println(2) fmt.Println(\"on\") // go on 2 1} 变量作用域 可以在函数中访问全局变量 优先在函数中找变量,找不到再找全局变量 在函数外无法访问函数内定义的变量 1234567891011121314151617package mainimport \"fmt\"//全局变量numvar num = 10//定义函数func a() { num := 100 //如定义了num则先用函数内的num fmt.Println(num)}func main() { a()} 将函数作为参数 123456789101112131415161718192021222324package mainimport \"fmt\"var num = 10func a(x, y int) int { return x + y}func b(x, y int) int { return x - y}func c(x, y int, op func(int, int) int) int { //第三个参数为函数func类型,接收两个参数int return op(x, y)}func main() { a1 := c(50, 60, a) b1 := c(50, 60, b) fmt.Println(a1) fmt.Println(b1)} 匿名函数 匿名函数就是没有函数名的函数,多用于回调 12345678910111213141516package mainimport \"fmt\"func main() { //定义然后执行 a := func() { fmt.Println(\"匿名函数\") } a() //定义直接执行(函数后加()) func() { fmt.Println(\"定义并执行\") }()} 闭包 闭包是一个函数与其相关的引用环境组合而成的实体 12345678910111213141516package mainimport \"fmt\"func a(name string) func(string) string { //返回值为函数 return func(end string) string { return name + end }}func main() { r := a(\"name\") //r为函数(闭包)函数内部引用外部变量 ret := r(\"end\") //执行匿名函数 fmt.Println(ret)} 内置函数 close 关闭channel len 求长度 new 分配内存(值类型) make 分配内存(引用类型) append 追加 panic和recover 错误处理 panic/recover 错误抛出 recover需要搭配defer panic直接终止,所以要在panic前定义recover和defer 12345678910111213141516171819202122232425262728package mainimport \"fmt\"func a() { fmt.Println(\"a\")}func b() { defer func() { //defer放到b函数最后执行 err := recover() //recover捕捉错误信息 if err != nil { //如果err不为空 fmt.Println(\"error\") } }() panic(\"b\") //panic报异常,准备结束,执行defer}func c() { fmt.Println(\"c\")}func main() { a() b() c()} 指针 &amp; 代表取地址 * 根据地址取值 不能操作指针 123456789101112package mainimport \"fmt\"func main() { a := 1 fmt.Println(a) b := &amp;a fmt.Println(b) //0xc000010090 fmt.Printf(\"%T\\n\", b) //*int int类型的内存地址(不同类型不能相互转换) fmt.Println(*b) //1 知道内存地址来取存储的值} 指针与地址 地址: 内存地址 指针: 带类型的 通常的使用方法 1234567891011121314package mainimport \"fmt\"func funA(a *[3]int) { //*代表接收数组的指针 a[0] = 100 //按指针修改数据 (*a)[0] = 100}func main() { l1 := [3]int{1, 2, 3} funA(&amp;l1) fmt.Println(l1) // [100 2 3]成功在内部修改了外部变量} 建立指针 12345678910111213141516package mainimport \"fmt\"func main() { var a = new(int) //new一个int类型指针 fmt.Println(a) //0xc000064058 *a = 10 fmt.Println(a) //0xc000064058 fmt.Println(*a) // 10 var c = new([3]int) //new一个切片 fmt.Println(c) //&amp;[0 0 0] (*c)[0] = 1 //等同于 c[0] = 1 fmt.Println(*c) //[1 0 0]} 结构体(struct)和方法 创建自定义类型和给类型起别名 有可能增加代码可读性 1234567891011121314151617181920package mainimport \"fmt\"//NewInt 创建一个新的类型 NewInt 实际上是int类型type NewInt int // 定义变量时首字母大写代表该变量是公共的,别人导入这个包时也可使用变量,注释要按照格式 变量名 注释type int1 = int //创建类型别名func main() { var a NewInt fmt.Println(a) //0 基于int所以默认值0 fmt.Printf(\"%T\\n\", a) //main.NewInt 自定义类型 var b int1 fmt.Println(b) //0 fmt.Printf(\"%T\\n\", b) //int 起别名所以还是int var c int fmt.Printf(\"%T\\n\", c) //起别名的情况下原名字也是可用的} 结构体 Go语言没有面向对象的说法 尽管可以通过某种方式达到类似对象的效果 但是官方不推荐面向对象编程, Go推荐面向接口编程 结构体是值类型,将实例化1赋值实例化2,两者内存地址是不一样的 基本实例化 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"// 定义结构体// 使用type建立一个学生类型type student struct { name string age int sex string hobby []string}func main() { //实例化方法1 var s1 = student{} //如果只实例化不赋值则默认为该数据类型初始值 fmt.Printf(\"s1_name:%v\\n\", s1.name) //string默认为空 //实例化方法2 var s2 = new(student) fmt.Println(s2) // &amp;{ 0 []} ,new出来的是指针 s2.name = \"s2\" // 等同于 (*s2).name 取地址 fmt.Println(s2.name) //s3 //实例化方法3 var s3 = &amp;student{} // 等同于2 fmt.Println(s3)} 基本初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport \"fmt\"// 定义结构体// 使用type建立一个学生类型type student struct { name string age int sex string hobby []string}func main() { // 初始化方法1 var s1 = student{ //少传则默认值替代 name: \"s1\", age: 18, sex: \"男\", hobby: []string{\"A\", \"b\", \"c\"}, } fmt.Println(s1) fmt.Println(s1.name) //结构体可以通过 . 的形式拿出来属性 //初始化方法2 var s2 = student{ //顺序与定义结构体时相同,必须全部传齐 \"s2\", 18, \"男\", []string{\"A\"}, } fmt.Println(s2.name) //初始化方法3 var s3 = &amp;student{ //顺序与定义结构体时相同,必须全部传齐 \"s3\", 18, \"男\", []string{\"A\"}, } fmt.Println(s3.name)} 结构体内存 结构体的每个值是排在一起的 1234567891011121314151617181920212223package mainimport \"fmt\"// 结构体内存布局func main() { type test struct { a int8 b int8 c int8 } var t = test{ a: 1, b: 2, c: 3, } fmt.Println(&amp;(t.a)) //0xc000064058 fmt.Println(&amp;(t.b)) //0xc000064059 fmt.Println(&amp;(t.c)) //0xc00006405a} 结构体嵌套 结构体可以相互嵌套 123456789101112131415161718192021222324252627package mainimport \"fmt\"// 结构体的嵌套type address struct {&nbsp;&nbsp;&nbsp;&nbsp;province string&nbsp;&nbsp;&nbsp;&nbsp;city string}type student struct {&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;age int&nbsp;&nbsp;&nbsp;&nbsp;addr address // 嵌套结构体 address}func main() {&nbsp;&nbsp;&nbsp;&nbsp;s1 := student{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: \"s1\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;age: 22,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr: address{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;province: \"p\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city: \"c\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s1) // {s1 22 {p c}}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s1.addr.city) // c} 赋值给指针 将实例化1的指针赋值给实例化2,此时实例化2是指向类型 12345678910111213141516171819202122232425package mainimport \"fmt\"// 结构体内存布局func main() {&nbsp;&nbsp;&nbsp;&nbsp;type test struct {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a int8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b int8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c int8&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;var t = test{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a: 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c: 3,&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&amp;(t.a)) //0xc000064058&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&amp;(t.b)) //0xc000064059&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(&amp;(t.c)) //0xc00006405a&nbsp;&nbsp;&nbsp;&nbsp;t2 := &amp;t //将t的地址给t2&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(\"%T\\n\", t2) //*main.test&nbsp;&nbsp;&nbsp;&nbsp;t2.a = 5 //(*stu3).a,找到内存地址&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(t.a, t2.a) //5 5 两个都修改了} 构造函数 go语言的结构体没有构造函数,必须我们自己实现 123456789101112131415161718192021222324252627282930313233343536package mainimport \"fmt\"// 构造函数type student struct {&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;age int&nbsp;&nbsp;&nbsp;&nbsp;gender string&nbsp;&nbsp;&nbsp;&nbsp;hobby []string}// 构造函数(名字带new方便理解)// 1版本,初始化后返回接收,如初始化内容较多返回再接受较占内存func newStudent(name string, age int, gender string, hobby []string) student {&nbsp;&nbsp;&nbsp;&nbsp;return student{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: name,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;age: age,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gender: gender,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hobby: hobby,&nbsp;&nbsp;&nbsp;&nbsp;}}// 2版本,初始化后返回初始化的指针,外面调用直接操作指针,避免1的问题func newStudent2(name string, age int, gender string, hobby []string) *student {&nbsp;&nbsp;&nbsp;&nbsp;return &amp;student{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: name,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;age: age,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gender: gender,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hobby: hobby,&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;s1Hobby := []string{\"a\", \"b\"}&nbsp;&nbsp;&nbsp;&nbsp;s1 := newStudent(\"s1\", 18, \"男\", s1Hobby)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s1)} 方法和接收者 方法是作用于特定类型变量的函数, 其中特定类型的变量叫 接受者, 接受者类似对象的 self 函数谁都可以调用,方法指定必须特定类型变量调用 123func (接受者变量 接受者类型) 方法名(参数列表) (返回参数) { 函数体} 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"// 方法type people struct {&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;gender int}// 函数// func deram() {// &nbsp;fmt.Println(\"梦想\")// }// 指定接受类型是people// 通常这个型参命名为类型的首字母小写, 比如 people叫 pfunc (p people) deram() {&nbsp;&nbsp;&nbsp;&nbsp;p.gender = 11 // 这里改并不会变,因为p是值类型,在函数内赋值无用&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"梦想\")}func (p *people) deram2() {&nbsp;&nbsp;&nbsp;&nbsp;p.gender = 11 // 传入指针时就有用&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"梦想\")}func main() {&nbsp;&nbsp;&nbsp;&nbsp;var p1 = people{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: \"p1\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gender: 20,&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;p1.deram() // .deram会自己找方法执行&nbsp;&nbsp;&nbsp;&nbsp;p1.deram2() // 原版为(&amp;p1.deram2), Go语言可以简写} 什么时候使用指针接受者 通常使用指针接受者 方法的追加 可以给任意类型追加方法 不能给别的包定义的类型添加方法 12345678910111213package mainimport \"fmt\"// MyInt 无法给外包加方法但是我们可以先自定义一个类型再给自定义类型加方法type MyInt intfunc (m *MyInt) sayHi() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"Hello\")}func main() {&nbsp;&nbsp;&nbsp;&nbsp;var a MyInt&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(a)&nbsp;&nbsp;&nbsp;&nbsp;a.sayHi()} 结构体镶嵌达到继承的效果 12345678910111213141516171819202122232425262728package mainimport \"fmt\"type animal struct { // 建立一个结构体&nbsp;&nbsp;&nbsp;&nbsp;name string}type dog struct {&nbsp;&nbsp;&nbsp;&nbsp;feet int&nbsp;&nbsp;&nbsp;&nbsp;*animal //镶嵌结构体的指针}func (a *animal) move() { //建立一个方法传入 animal 的指针&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(a.name)}func (d *dog) wang() { // 建立一个方法传入 dog 指针&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(d.name)}func main() {&nbsp;&nbsp;&nbsp;&nbsp;var a = dog{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feet: 4,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animal: &amp;animal{ // 指针&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: \"dog1\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;a.wang()&nbsp;&nbsp;&nbsp;&nbsp;a.move()} 获取用户输入信息 类似Python的input 123456789101112131415161718package mainimport \"fmt\"// DOS交互func main() {&nbsp;&nbsp;&nbsp;&nbsp;// 从DOS获取值&nbsp;&nbsp;&nbsp;&nbsp;// var变量&nbsp;&nbsp;&nbsp;&nbsp;var (&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;age int&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Scan(&amp;name, &amp;age) //传入变量指针,用户输入直接赋值, 空格或换行分割&nbsp;&nbsp;&nbsp;&nbsp;fmt.Scanf(\"name:%S age:%d \\n\", &amp;name, &amp;age) //不常用,规定必须按照Scanf内容格式输入&nbsp;&nbsp;&nbsp;&nbsp;fmt.Scanln(&amp;name, &amp;age) // 与1差不多但是换行就结束(只能空格分隔)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(name, age)} 程序的退出 os.Exit(0) 匿名字段 不推荐使用 在定义结构体时可以使用匿名字段 匿名字段实际上就是简写, 比如字段叫 string 实际上是一个叫 string 类型为 string 的字段 因此同一类型的匿名字段只能有一个 1234567891011121314151617package mainimport \"fmt\"// 匿名字段type student struct { // 结构体&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;string // 匿名字段&nbsp;&nbsp;&nbsp;&nbsp;int}func main() {&nbsp;&nbsp;&nbsp;&nbsp;s1 := student{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: \"s1\",&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s1.string) // 为空(string的默认值)} JSON序列化 Go语言自带Json包,但是上面说过Go语言跨包使用变量必须首字母大写 123456789101112131415161718192021222324252627282930313233package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"encoding/json\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\")// 序列化// Student 学生type Student struct {&nbsp;&nbsp;&nbsp;&nbsp;ID int `json:\"id\"` // 如想改变json的k,语法同本行,不带空格&nbsp;&nbsp;&nbsp;&nbsp;Gender string `json:\"gender\"`&nbsp;&nbsp;&nbsp;&nbsp;Name string `json:\"name\"`}func main() {&nbsp;&nbsp;&nbsp;&nbsp;s1 := Student{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ID: 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gender: \"男\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name: \"s1\",&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 序列化&nbsp;&nbsp;&nbsp;&nbsp;v, err := json.Marshal(s1) // json.Marshal方法,json序列化,返回值和报错信息&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { // 不为nil代表报错&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(v) // [123 34 73 68 34 58 49 44 34 71 101 110 ...] 每个字节&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(string(v)) // []byte转string, json&nbsp;&nbsp;&nbsp;&nbsp;// 反序列化&nbsp;&nbsp;&nbsp;&nbsp;j1 := string(v)&nbsp;&nbsp;&nbsp;&nbsp;s2 := &amp;Student{} //指针赋给s2&nbsp;&nbsp;&nbsp;&nbsp;json.Unmarshal([]byte(j1), s2) // 接收两个参数,一是切片,二是要转换的类型指针&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(s2) // &amp;{1 男 s1}, 指针&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(*s2) // {1 男 s1}, 内容} defore深入理解 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"// defore 难题// return在汇编上本质分为 获取返回值 &gt; RET指令, 加上defore是 获取返回值 &gt; defore &gt; RET指令func f1() int {&nbsp;&nbsp;&nbsp;&nbsp;x := 5&nbsp;&nbsp;&nbsp;&nbsp;defer func() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x++&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;return x // 返回值为int, 走到return时先看到返回值不是x而是int所以先拿到返回值5, 执行defore x++, 对返回值无影响, 返回5}func f2() (x int) {&nbsp;&nbsp;&nbsp;&nbsp;defer func() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x++&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;return 5 // 返回值为 x, func时x=0, return时5赋值给x,然后执行defore, x++=6, 返回6}func f3() (y int) {&nbsp;&nbsp;&nbsp;&nbsp;x := 5&nbsp;&nbsp;&nbsp;&nbsp;defer func() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x++&nbsp;&nbsp;&nbsp;&nbsp;}()&nbsp;&nbsp;&nbsp;&nbsp;return x // 返回值为y, func时y=0, y为值类型所以return时将x的值5copy给y, defore x++对y无影响, 返回5}func f4() (x int) {&nbsp;&nbsp;&nbsp;&nbsp;defer func(x int) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x++&nbsp;&nbsp;&nbsp;&nbsp;}(x)&nbsp;&nbsp;&nbsp;&nbsp;return 5 // 返回值为x, func时x=0, return时5赋值给x, 执行defore 将x传入, 但是Go函数是形参,所以defore函数内部新建一个x, x++对外部x无影响, 返回5}func main() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(f1())&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(f2())&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(f3())&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(f4())} Go语言的包 通常情况下, 代码不可能放到一个文件里,这时我们就需要封包 一个包(文件夹)中永远只有一个main文件,这是这个包中的总入口 定义包 文件的第一行 如果包中有一个叫 mian 的package,那这个包是可执行的文件 如果没有 main 代表这个包是导入的包, 不能自己执行 一个文件夹下只有一个包, 一个包不能拆分成两个文件夹 包名可以不与文件夹名字重叠, 包名不能有 - 符号 包名为 main 是这个程序的入口包, 编译时去除main包就得不到可执行文件 1package 包名 可见性 一个包如果想让外部调用他的标识符(变量/常量/类型/函数…),该标识符必须是对外可见的(首字母大写) 导入包 自己写的本地包导入路径是 GOPATH/src/路径 使用时是按照包名而不是文件夹名 导入包可以给这个包起别名,然后使用别名即可 1import 别名 包 匿名导入包 只导入包而不适用包内数据 匿名导入的包编译时也会加入 1import _ 包 初始化函数 包在被导入时会触发包内部的 init() 函数,该函数没有参数也没有返回值 init() 不能在代码中主动调用, 只能在程序运行时自动调用 多用来做初始化操作 顺序: 全局声明 &gt; init &gt; main time包 Go语言中预设的处理时间的包 时间戳 1234567891011121314151617181920212223242526package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"time\")func myTimeStamp(timestamp int64) {&nbsp;&nbsp;&nbsp;&nbsp;timeObj := time.Unix(timestamp, 0) // 时间戳转时间格式, 0是纳秒的偏移量,通常为0(不偏移)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(timeObj)}func main() {&nbsp;&nbsp;&nbsp;&nbsp;now := time.Now() // 当前时间,实例化一个time.Now结构体&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(\"%#v\", now) // time.Time{wall:0xbf3f74ec230757d8, ext:5984001, loc:(*time.Location)(0x57bfc0)}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Year()) // 年 2019&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Month()) // 月 July&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Day()) // 日 4&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Hour()) // 时 9&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Minute()) // 分 56&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Second()) // 秒 39&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Nanosecond()) // 纳秒 531441700&nbsp;&nbsp;&nbsp;&nbsp;// 时间戳&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Unix()) // 时间戳 1562205575&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.UnixNano()) // 纳秒级别时间戳 1562205575360303400} 定时器 按照时间重复执行 不在乎上一个有没有执行完毕 123456789101112131415161718package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"time\")// 定时器func tickDemo() {&nbsp;&nbsp;&nbsp;&nbsp;ticker := time.Tick(time.Second) // 定义一个间隔1s的定时器&nbsp;&nbsp;&nbsp;&nbsp;for i := range ticker {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(i)&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;tickDemo()} 时间格式化 其他语言通常使用 YYYY-MM-DD… 来格式化 Go语言使用Go的出生时间 2006年1月2日15点04分 来格式化 123456789101112131415161718package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"time\")func format() {&nbsp;&nbsp;&nbsp;&nbsp;now := time.Now()&nbsp;&nbsp;&nbsp;&nbsp;// 格式化时间模板为Go的出生日期 2006年1月2日15点04分&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Format(\"2006-01-02 15:04:05\")) // 2019-07-04 15:54:22&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Format(\"2006/01/02 15:04:05\")) // 2019/07/04 15:54:22&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Format(\"2006-01-02\")) // 2019-07-04&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(now.Format(\"15:04\")) // 15:54}func main() {&nbsp;&nbsp;&nbsp;&nbsp;format()} 接口 此接口不是web接口 此接口指一种类型(interface) 是抽象的类型 接口是一组 method 的组合, 是一个协议, 一种规范 Go语言提倡面向接口编程 接口名一般是单词+er 方法名首字母大写且接口名大写的情况下该接口可以被外部导入 如果接口接受的是指针, 那么传入值类型会出错 如果接口接受值类型, 那么如果传入指针类型Go语言会自己找到对应的值传入 1234type 接口类型名 interface{ 方法名1(参数列表1) 返回值列表1 方法名2(参数列表2) 返回值列表2} 为什么使用接口 将所有拥有共同点的类型统一处理,避免代码雍余 比如微信支付/支付宝支付/银联支付… 都是支付, 我们可以统称为 支付方式 接口实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport \"fmt\"// 接口实现// 就这里来说, 只要一个类型实现了wash 和 dry 方法,我们就叫这个类型实现了 xiyiji 这个接口type xiyiji interface {&nbsp;&nbsp;&nbsp;&nbsp;wash() // 洗衣&nbsp;&nbsp;&nbsp;&nbsp;dry() // 甩干}type haier struct {&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;price float64}func (h haier) wash() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"haier wash\")}func (h haier) dry() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"haier price\")}type people struct {&nbsp;&nbsp;&nbsp;&nbsp;name string}func (p people) wash() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"people wash\")}func (p people) dry() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"people price\")}func (p people) dry1() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"people price1\")}// haier 和 people 都有dry和wash方法, 接口赋值后可以像调用方法一样使用, 所以接口是抽象的,不关心赋值的结构体类型, 只要你有我规定的方法即可(可以比我规定的方法多)func main() {&nbsp;&nbsp;&nbsp;&nbsp;var a xiyiji&nbsp;&nbsp;&nbsp;&nbsp;h1 := haier{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: \"小神童\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price: 188.8,&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;a = h1 // 接口是抽象类型,所以可以被赋值结构体, 前提是结构体必须有接口规定的方法&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(a)&nbsp;&nbsp;&nbsp;&nbsp;a.dry() // haier price 调用haier的dry&nbsp;&nbsp;&nbsp;&nbsp;p1 := people{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: \"p1\",&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;a = p1&nbsp;&nbsp;&nbsp;&nbsp;p1.dry() // people price 调用people的dry} 123456789101112131415161718192021222324252627282930313233343536package mainimport \"fmt\"// 为什么使用接口,狗和猫都能叫, 我们为什么不能将其合在一起// Cat 猫结构体type Cat struct{}// Dog 狗结构体type Dog struct{}// Sayer 结构体type Sayer interface {&nbsp;&nbsp;&nbsp;&nbsp;Say() string}// Say 猫叫func (c Cat) Say() string {&nbsp;&nbsp;&nbsp;&nbsp;return \"喵喵喵\"}// Say 狗叫func (d Dog) Say() string {&nbsp;&nbsp;&nbsp;&nbsp;return \"汪汪汪\"}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// c := Cat{}&nbsp;&nbsp;&nbsp;&nbsp;// d := Dog{}&nbsp;&nbsp;&nbsp;&nbsp;// fmt.Println(c.Say())&nbsp;&nbsp;&nbsp;&nbsp;// fmt.Println(d.Say())&nbsp;&nbsp;&nbsp;&nbsp;// 接口形式&nbsp;&nbsp;&nbsp;&nbsp;var animalList []Sayer&nbsp;&nbsp;&nbsp;&nbsp;c := Cat{}&nbsp;&nbsp;&nbsp;&nbsp;d := Dog{}&nbsp;&nbsp;&nbsp;&nbsp;animalList = append(animalList, c, d)&nbsp;&nbsp;&nbsp;&nbsp;for _, i := range animalList {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(i.Say())&nbsp;&nbsp;&nbsp;&nbsp;}} 类型与接口的关系 一个类型可以实现多个接口 一个接口可对接多种类型 接口的嵌套 接口可以嵌套 12345678910111213141516171819202122232425262728293031323334package mainimport \"fmt\"// 接口1type speaker interface {&nbsp;&nbsp;&nbsp;&nbsp;speak()}// 接口2type mover interface {&nbsp;&nbsp;&nbsp;&nbsp;move()}// 接口嵌套type animal interface {&nbsp;&nbsp;&nbsp;&nbsp;speaker // 嵌套接口1&nbsp;&nbsp;&nbsp;&nbsp;mover // 接口2}// 结构体type cat struct {&nbsp;&nbsp;&nbsp;&nbsp;name string}func (c cat) speak() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"speak\")}func (c cat) move() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"move\")}func main() {&nbsp;&nbsp;&nbsp;&nbsp;var x animal&nbsp;&nbsp;&nbsp;&nbsp;x = cat{name: \"cat1\"}&nbsp;&nbsp;&nbsp;&nbsp;x.move() // 直接.方法 即可&nbsp;&nbsp;&nbsp;&nbsp;x.speak()} 空接口 没有定义任何方法的接口 任何类型都满足规则,可以存储任何类型的变量 如果我们想定义一个函数, 参数为任意值则需要定义传参为空接口 定义一个map值为空接口则map值为任意类型 12345678910111213141516171819package mainimport \"fmt\"// 空接口func showType(a interface{}) {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(\"%T\\n\", a)}func main() {&nbsp;&nbsp;&nbsp;&nbsp;showType(1)&nbsp;&nbsp;&nbsp;&nbsp;showType(\"wwwaw\")&nbsp;&nbsp;&nbsp;&nbsp;showType(1.256)&nbsp;&nbsp;&nbsp;&nbsp;// 值为空接口的map&nbsp;&nbsp;&nbsp;&nbsp;var stuInfo = make(map[string]interface{}, 100)&nbsp;&nbsp;&nbsp;&nbsp;stuInfo[\"A\"] = 100&nbsp;&nbsp;&nbsp;&nbsp;stuInfo[\"B\"] = true&nbsp;&nbsp;&nbsp;&nbsp;stuInfo[\"C\"] = \"ahdha\"&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(stuInfo)} 类型断言 判断某个变量是否是某个类型 1值, 判断是否类型对应 := 变量.(类型) 123456789package mainimport \"fmt\"// 类型断言func main() {&nbsp;&nbsp;&nbsp;&nbsp;var x interface{}&nbsp;&nbsp;&nbsp;&nbsp;x = 100&nbsp;&nbsp;&nbsp;&nbsp;v, ok := x.(int)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(v, ok) // 100 true} 类型断言简单版(常用) v不需要可以使用占位符 12345678910111213141516package mainimport \"fmt\"// 类型断言func main() {&nbsp;&nbsp;&nbsp;&nbsp;var x interface{}&nbsp;&nbsp;&nbsp;&nbsp;x = 100&nbsp;&nbsp;&nbsp;&nbsp;switch v := x.(type) {&nbsp;&nbsp;&nbsp;&nbsp;case string:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"string\", v)&nbsp;&nbsp;&nbsp;&nbsp;case int:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"int\", v)&nbsp;&nbsp;&nbsp;&nbsp;}} 接口值 一个接口的值由一个 具体类型 和 具体值 组成 1234567891011121314func main() {&nbsp;&nbsp;&nbsp;&nbsp;var x interface{}&nbsp;&nbsp;&nbsp;&nbsp;var a int64 = 100&nbsp;&nbsp;&nbsp;&nbsp;var b int32 = 10&nbsp;&nbsp;&nbsp;&nbsp;var c int8 = 1&nbsp;&nbsp;&nbsp;&nbsp;x = a // 此时x为 &lt;int64, 100&gt;&nbsp;&nbsp;&nbsp;&nbsp;x = b // &lt;int32, 10&gt;&nbsp;&nbsp;&nbsp;&nbsp;x = c // &lt;int8, 10&gt;&nbsp;&nbsp;&nbsp;&nbsp;x = false // &lt;bool, false&gt;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(x)} Go对文件进行操作 文本分为文本文件和二进制文件 打开文件 os.Open(文件路径) 返回两个参数, 参数1(file)为获取的文件, 参数2为错误信息 关闭文件 先打开文件获得参数1(file), 然后参数1.Close()即可 通常将关闭文件写在 defore 里 读取文件 file.Read() 初始版 循环读取128字节 会出现问题, 例如中文128字节可能截断分隔汉字, 导致乱码 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"io\"&nbsp;&nbsp;&nbsp;&nbsp;\"os\")// 文件操作// 打开关闭文件func open() {&nbsp;&nbsp;&nbsp;&nbsp;file, err := os.Open(\"./a.txt\") // 打开文件, 参数1为文件, 2为报错信息&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { // 不为nil代表出现错误&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(\"文件打开失败,错误:%v\", err)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 文件可以打开&nbsp;&nbsp;&nbsp;&nbsp;defer file.Close() // defer延迟关闭文件&nbsp;&nbsp;&nbsp;&nbsp;// 读文件&nbsp;&nbsp;&nbsp;&nbsp;var tmp [128]byte // 定义一个128长度的字节数组&nbsp;&nbsp;&nbsp;&nbsp;for { // 每次读取128字节&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n, err := file.Read(tmp[:]) // 将文件内容赋值给tmp, 返回两个返回值, n为本次读取长度, err代表读取错误&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err == io.EOF {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 文件读取完毕会报出一个 EOF 错误, 并且n为0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"文件读取完毕\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 文件读取失败&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"err:\", err)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(n) // 本次长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Print(string(tmp[:])) // 文本内容就在切片里&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;open()} bufio读取文件 上方的代码是直接从硬盘中读取数据 bufio封装一层, 等同于在代码和系统之间加一个缓冲区 12345678910111213141516171819202122232425262728293031package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"bufio\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"io\"&nbsp;&nbsp;&nbsp;&nbsp;\"os\")// bufiofunc main() {&nbsp;&nbsp;&nbsp;&nbsp;file, err := os.Open(\"./a.txt\")&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;defer file.Close()&nbsp;&nbsp;&nbsp;&nbsp;// 读取文件&nbsp;&nbsp;&nbsp;&nbsp;reader := bufio.NewReader(file)&nbsp;&nbsp;&nbsp;&nbsp;for { // 会自己循环&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str, err := reader.ReadString('\\n') // 读取到指定字符结束&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err == io.EOF {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Print(str)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Print(str)&nbsp;&nbsp;&nbsp;&nbsp;}} ioutil读取文件 更高级, 会自己捕捉EOF及err异常 也会自己控制打开和关闭文件 12345678910111213141516171819package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"io/ioutil\")func readFile(f string) { // 传入filename&nbsp;&nbsp;&nbsp;&nbsp;content, err := ioutil.ReadFile(f)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(string(content))}// ioutilfunc main() {&nbsp;&nbsp;&nbsp;&nbsp;readFile(\"./a.txt\")} OpenFile操作文件 Open函数功能较浅显, 当我们需要实现文件的写入时, 就需要使用 OpenFile 函数 OpenFile函数能以指定模式打开文件, 模式有多种 OpenFile源代码如下 123func OpenFile(name string, flag int, perm FileMode) (*File, error){ ...} 其中, name是打开的文件, flag为打开文件的模式 prm为文件权限, 八进制数, r(读)04, w(写)02, x(执行)01 123456789101112131415package mainimport \"os\"// 文件写func main() {&nbsp;&nbsp;&nbsp;&nbsp;file, err := os.OpenFile(\"x.txt\", os.O_CREATE|os.O_WRONLY, 0755) // 打开文件,没有则新建&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;defer file.Close()&nbsp;&nbsp;&nbsp;&nbsp;str := \"架飞机啊\" // 写入&nbsp;&nbsp;&nbsp;&nbsp;file.WriteString(str)} bufio.NewWriter写入文件 12345678910111213func main() { file, err := os.OpenFile(\"xx.txt\", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { fmt.Println(\"open file failed, err:\", err) return } defer file.Close() writer := bufio.NewWriter(file) for i := 0; i &lt; 10; i++ { writer.WriteString(\"hello沙河\\n\") //将数据先写入缓存 } writer.Flush() //将缓存中的内容写入文件} ioutil.WriteFile写入文件 1234567891011121314151617package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"io/ioutil\")// 文件写func main() {&nbsp;&nbsp;&nbsp;&nbsp;str := \"hello 沙河\"&nbsp;&nbsp;&nbsp;&nbsp;err := ioutil.WriteFile(\"./xx.txt\", []byte(str), 0666) // 只支持切片&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"write file failed, err:\", err)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}} 反射 通用工具类型太多, 类型断言猜不全, 使用反射拿到接口值的动态类型和动态值 反射平常不常用 各种框架源码比较常用 反射使代码更灵活,但是执行效率较低 反射代码难懂, 容易panic, 性能很低 reflect包 TypeOf reflect.TypeOf() 函数可以获得任意值的类型对象 12345678910111213141516171819202122232425package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"reflect\")// reflecttype cat struct {&nbsp;&nbsp;&nbsp;&nbsp;name string}func myTypeOf(i interface{}) {&nbsp;&nbsp;&nbsp;&nbsp;v := reflect.TypeOf(i) // 获取变量i的类型&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(v, v.Name(), v.Kind()) // v.Name()输出这个i的类型名, v.Kind()输出这个i的大的种类,比如所有结构体都是结构体,引用类型的Name为空}func main() {&nbsp;&nbsp;&nbsp;&nbsp;myTypeOf(\"jagjgag\") // string string string&nbsp;&nbsp;&nbsp;&nbsp;a := false&nbsp;&nbsp;&nbsp;&nbsp;myTypeOf(a) // bool bool bool&nbsp;&nbsp;&nbsp;&nbsp;var c1 = cat{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: \"花花\",&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;myTypeOf(c1) // main.cat cat struct (可以查找出出自定义的结构体等)} ValueOf 获取动态值 12345678910111213141516171819202122232425package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"reflect\")// 值进入该函数变成空接口,ValueOf获取这个参数原有的值func reflectValue(x interface{}) {&nbsp;&nbsp;&nbsp;&nbsp;v := reflect.ValueOf(x) // 获取接口值信息&nbsp;&nbsp;&nbsp;&nbsp;k := v.Kind() // kind获取值对应类型&nbsp;&nbsp;&nbsp;&nbsp;switch k { // 对比判断&nbsp;&nbsp;&nbsp;&nbsp;case reflect.Int64:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(\"Int64 %d\\n\", int64(v.Int()))&nbsp;&nbsp;&nbsp;&nbsp;case reflect.Float32:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Printf(\"float32 %f\\n\", float32(v.Float()))&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;var a float32 = 3.14&nbsp;&nbsp;&nbsp;&nbsp;var b int64 = 200&nbsp;&nbsp;&nbsp;&nbsp;reflectValue(a)&nbsp;&nbsp;&nbsp;&nbsp;reflectValue(b)} 通过反射修改外部变量值 1234567891011121314151617181920212223package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"reflect\")// 通过反射修改值func editValue(x interface{}) {&nbsp;&nbsp;&nbsp;&nbsp;// 想要在函数内修改函数外的值必须通过修改指针对应值的形式&nbsp;&nbsp;&nbsp;&nbsp;v := reflect.ValueOf(x) // 获取传入的值&nbsp;&nbsp;&nbsp;&nbsp;kind := v.Kind() // 获取值的类型&nbsp;&nbsp;&nbsp;&nbsp;switch kind {&nbsp;&nbsp;&nbsp;&nbsp;case reflect.Ptr: // 判断为指针,修改&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.Elem().SetInt(500) // v.Elem()才是传入值的指针, SetInt()为修改值为Int&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;var a int64 = 100&nbsp;&nbsp;&nbsp;&nbsp;editValue(&amp;a)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(a)} Tag Tag是结构体中某个字段别名, 可以定义多个, 空格分隔, 其中名为json的tag是序列化反序列化的名字 123456type student struct {&nbsp;&nbsp;&nbsp;&nbsp;Name string `json:\"name\" a:\"b\"`} 结构体反射查看字段 用的较多 任意值通过 reflect.TypeOf() 获得反射对象的信息后,如果它的类型为结构体, 可以通过反射值对象 的 NumField() 和 Field() 方法获得结构体成员的详细信息 1234567891011121314151617181920212223242526272829package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"reflect\")// 结构体反射type student struct {&nbsp;&nbsp;&nbsp;&nbsp;Name string `json:\"name\"`}func main() {&nbsp;&nbsp;&nbsp;&nbsp;s1 := student{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name: \"s1\",&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;t := reflect.TypeOf(s1)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(t.Name(), t.Kind()) // student struct&nbsp;&nbsp;&nbsp;&nbsp;// 循环遍历结构体s1, NumField() 为结构体长度&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; t.NumField(); i++ {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field := t.Field(i) // 拿出某个字段i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(field.Name, field.Index, field.Type, field.Tag.Get(\"json\")) // 字段名, 索引, 类型, jsonTag&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 通过字段名&nbsp;&nbsp;&nbsp;&nbsp;scoreField, ok := t.FieldByName(\"Name\") // 查找名为Name的字段, ok为True代表有字段, 此时scoreField为该字段&nbsp;&nbsp;&nbsp;&nbsp;if ok {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(\"json\")) // Name [0] string name&nbsp;&nbsp;&nbsp;&nbsp;}} 结构体反射查看方法 123456789101112131415161718192021package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"reflect\")// 查看结构体的方法func printMethod(x interface{}) {&nbsp;&nbsp;&nbsp;&nbsp;t := reflect.TypeOf(x)&nbsp;&nbsp;&nbsp;&nbsp;v := reflect.ValueOf(x)&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; v.NumMethod(); i++ { // 遍历方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;methodType := v.Method(i).Type() // 拿到方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(t.Method(i).Name) // 方法名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(methodType) // 方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 通过反射调用方法, 需要传值必须是 []reflect.Value{} 类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var args = []reflect.Value{}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.Method(i).Call(args)&nbsp;&nbsp;&nbsp;&nbsp;}} 并发 并发是Go语言的优势 并发与并行 并发: 同一时段做多个事情 并行: 同一时刻做多个事情 进程,线程,协程 go只需要 goroutine 进程: 一个程序启动后创建一个进程 线程: 操作系统调度的最小单位 协程: 用户态的线程 goroutine Go语言的 runtime 自动决定程序在哪里运行 使用 go 关键字创建 goroutine 一个函数可以创建多个 goroutine, 一个goroutine必对应一个函数 Go的 goroutine 启动一个占用2KB内存(线程占用2MB), 而且 goroutine可动态扩充大小(最大1GB), goroutine启1w个也没问题 goroutine直接通讯只能用 channel 12345678910111213141516171819202122232425package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"sync\")// 启动 goroutine// goroutine 通常和 sync 的 WaitGroup 结合使用// WaitGroup是一个计时器var wg sync.WaitGroupfunc hello() {&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"hello\")&nbsp;&nbsp;&nbsp;&nbsp;defer wg.Done() // 执行结束后告诉wg执行完毕,推荐用defer}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// 函数前加 go 就是调用 goroutine 执行&nbsp;&nbsp;&nbsp;&nbsp;// 1. 创建goroutine&nbsp;&nbsp;&nbsp;&nbsp;// 2. 在goroutine执行hello&nbsp;&nbsp;&nbsp;&nbsp;wg.Add(1) // 计时器加1, 启动一个 goroutine&nbsp;&nbsp;&nbsp;&nbsp;go hello()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"func hello on\")&nbsp;&nbsp;&nbsp;&nbsp;wg.Wait() // 等待wg全部执行结束(Done)才结束} goroutine和线程的区别 https://www.liwenzhou.com/posts/Go/14_concurrence/ Go的 goroutine 启动一个占用2KB内存(线程占用2MB), 而且 goroutine可动态扩充大小(最大1GB), goroutine启10w个也没问题 开启线程调度是代码请求系统创建然后提供给代码操作, goroutine是由Go的运行时(runtime)自己调度, 这个调度器使用一个 m:n 调度技术(复用/调度m个goroutine到n个os线程),所以不需要切换内核语境,成本低,速度快 GOMAXPROCS(m:n的n) 决定Go运行时使用几个线程来执行Go程序, 默认值是机器上的CPU核心数 Go语言1.5版本后默认跑满核心, 可以通过 runtime.GOMAXPROCS(核心数) 来设置核心 一个操作系统可开启多个 goroutine Go程序可以同时使用多个系统线程 goroutine和os线程是多对多的关系, m:n(goroutine : CPU核心) channel 管道 一般来说其他语言常使用多个线程使用同一个共享内存,但是要考虑到数据的安全一致性必须要加锁, 这就导致了速度和效率会下降 Go语言不提倡使用共享内存的方式 channel则是在多个 goroutine 中搭建管道互传消息 channel是引用类型 channel可以不关闭,Go的垃圾回收会自己关闭 123456789101112131415package mainimport \"fmt\"// channelfunc main() {&nbsp;&nbsp;&nbsp;&nbsp;// c1为chan类型的管道, 传输1个int&nbsp;&nbsp;&nbsp;&nbsp;c1 := make(chan int, 1) // chan是引用类型所以需要make&nbsp;&nbsp;&nbsp;&nbsp;// channel 发送和接收 &lt;-&nbsp;&nbsp;&nbsp;&nbsp;c1 &lt;- 10 // 把10发送到c1&nbsp;&nbsp;&nbsp;&nbsp;ret := &lt;-c1 // 接收c1(不写ret则是丢弃值)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ret)&nbsp;&nbsp;&nbsp;&nbsp;close(c1) // 关闭管道, 关闭的通道再接受值不报错,如果管道有值,则依次取出,无值 取到对应值的零值, 不可发送值, 不可重复关闭一个通道} 无缓冲通道和缓冲通道 在创建 channel 时, make需要带上长度, 这个长度实际上是一个缓冲区, 可以理解为管道长度, 如果为10代表当数据没有接收时, 数据存储在管道里可以存储10个 不写长度代表无缓冲, 此时通过管道传输数据时必须同时有人在接收否则会报 死锁 错误 1234567891011121314package mainimport \"fmt\"// channelfunc recv(ch chan bool) {&nbsp;&nbsp;&nbsp;&nbsp;&lt;-ch}func main() {&nbsp;&nbsp;&nbsp;&nbsp;c1 := make(chan bool) // 创建无缓冲通道(不规定长度)&nbsp;&nbsp;&nbsp;&nbsp;go recv(c1)&nbsp;&nbsp;&nbsp;&nbsp;c1 &lt;- false // 不会报错因为recv函数中已经在等待接收c1的值&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(len(c1), cap(c1)) // len()获取当前管道的值长度, cap()获取管道容量} 判断通道是否关闭 由于通道关闭后也能取出0值,所以我们要先判断通道是否已关闭 12345678910111213141516171819202122232425262728package mainimport \"fmt\"// 判断通道是否关闭func send(ch chan int) {&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; 10; i++ {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch &lt;- i&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;defer close(ch)}func main() {&nbsp;&nbsp;&nbsp;&nbsp;var ch1 = make(chan int, 100)&nbsp;&nbsp;&nbsp;&nbsp;go send(ch1)&nbsp;&nbsp;&nbsp;&nbsp;// 方法1&nbsp;&nbsp;&nbsp;&nbsp;for {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret, ok := &lt;-ch1 // 如通道关闭ok为false&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !ok {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ret)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 方法2&nbsp;&nbsp;&nbsp;&nbsp;for ret := range ch1 { // range自己判断&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ret)&nbsp;&nbsp;&nbsp;&nbsp;}} select多路复用 某些情况下我们需要指定多个通道,其中一个通道有值就继续走下去 Go内置了 select 方法来帮助我们实现 1234567891011121314151617181920212223242526272829303132333435package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"time\")// select多路复用var ch1 = make(chan string, 100)var ch2 = make(chan string, 100)func f1(ch chan string) {&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; 10; i++ {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch1 &lt;- fmt.Sprintf(\"f1:%d\", i)&nbsp;&nbsp;&nbsp;&nbsp;}}func f2(ch chan string) {&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; 10; i++ {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch2 &lt;- fmt.Sprintf(\"f2:%d\", i)&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;go f1(ch1)&nbsp;&nbsp;&nbsp;&nbsp;go f2(ch2)&nbsp;&nbsp;&nbsp;&nbsp;for {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select { // select多个ret通道&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ret := &lt;-ch1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ret)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case ret := &lt;-ch2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ret)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"取不到值\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time.Sleep(time.Millisecond * 500)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 单向通道 设置通道的 可读/可写 12345678910111213package main// 传入的chan只能写func p(ch chan&lt;- int) {}// 传入的chan只能读func p1(ch &lt;-chan int) {}// 传入的chan可读写func p2(ch chan int) {} 并发控制与锁 并发时,有可能遇到多个 goroutine 同时操作一个内存数据的情况, 这时候就会发生无法预料的数据紊乱, 此时我们需要给这个数据加锁, 在某个 goroutine 操作数据时其他 goroutine 等待, 这样就保证了数据的安全 https://www.liwenzhou.com/posts/Go/14_concurrence/ 互斥锁 同时只能一个 goroutine 操作一个数据 123456789101112131415161718192021222324252627282930package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"sync\")var num intvar wg sync.WaitGroup// 互斥锁var lock sync.Mutexfunc add() {&nbsp;&nbsp;&nbsp;&nbsp;defer wg.Done()&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; 5000; i++ {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.Lock() // 加互斥锁&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = num + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.Unlock() // 解锁&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;wg.Add(5)&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;wg.Wait()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(num)} 读写互斥锁 同一时间只能一个 goroutine 写, 但是不限制读的 goroutine 此锁适用于 读次数多, 写次数少 的情况下 如读写频率一致或写多于读则推荐使用互斥锁 123456789101112131415161718192021222324252627282930313233343536package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"sync\")var num intvar wg sync.WaitGroup// 读写锁var rwLock sync.RWMutexfunc add() {&nbsp;&nbsp;&nbsp;&nbsp;defer wg.Done()&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; 5000; i++ {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if i%2 == 0 {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rwLock.RLock() // 加读锁&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(num)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rwLock.RUnlock() // 释放读锁&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rwLock.Lock() // 加写锁&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = num + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rwLock.Unlock() // 释放写锁&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;wg.Add(5)&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;go add()&nbsp;&nbsp;&nbsp;&nbsp;wg.Wait()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(num)} map的并发 并发时map会自主报错,这是一个自己的保护机制, 防止多个 foroutine 导致kv不一致 Go内置了 sync.map ,并发安全/开箱即用 https://www.liwenzhou.com/posts/Go/14_concurrence/#autoid-4-3-0 12345678910111213141516171819202122232425package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"strconv\"&nbsp;&nbsp;&nbsp;&nbsp;\"sync\")// sync.mapvar m = sync.Map{} // 自己加了互斥锁func main() {&nbsp;&nbsp;&nbsp;&nbsp;wg := sync.WaitGroup{}&nbsp;&nbsp;&nbsp;&nbsp;for i := 0; i &lt; 10; i++ {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wg.Add(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go func(n int) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key := strconv.Itoa(n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.Store(key, n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v, _ := m.Load(key)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(key, v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wg.Done()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}(i)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;wg.Wait()} 单元测试 开发人员自测 大的程序分为多个功能单元, 开发完一个单元后自己进行测试 https://www.liwenzhou.com/posts/Go/16_test/ Go语言单元测试 Go 内置单元测试包 testing 一般我们会编写相关的函数作为测试使用 测试函数的命名需遵守相关约定 测试函数统一写在一个以 _test.go 为后缀名的文件中, 在编译时会自动忽略此类文件 使用 go test 命令会自己寻找当前包内的 *_test.go 文件, 然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。 基准测试 测试运行时间/占用资源等等数据 https://www.liwenzhou.com/posts/Go/16_test/#autoid-2-5-0 Setup和TearDown 测试开始前和结束后执行的逻辑 https://www.liwenzhou.com/posts/Go/16_test/#autoid-3-5-0 网络编程 https://www.liwenzhou.com/posts/Go/15_socket/ 123456789101112131415161718192021package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"net/http\")// HTTP serverfunc res(w http.ResponseWriter, r *http.Request) { // 接受参数&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(r.Method) // 请求方式&nbsp;&nbsp;&nbsp;&nbsp;r.ParseForm() // 解析数据&nbsp;&nbsp;&nbsp;&nbsp;r.Form.Get(\"name\") // 获取form表单中key为name的数据}func main() {&nbsp;&nbsp;&nbsp;&nbsp;http.HandleFunc(\"/\", res) // 访问根路径走res函数&nbsp;&nbsp;&nbsp;&nbsp;err := http.ListenAndServe(\":9090\", nil) // 监听本地端口&nbsp;&nbsp;&nbsp;&nbsp;if err != nil { // 错误捕捉&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}} MySql https://www.liwenzhou.com/posts/Go/go_mysql/ 驱动下载 go get -u github.com/go-sql-driver/mysql 普通连接 12345678910111213141516171819202122232425262728package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"database/sql\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysqlfunc main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;// 注册mysql信息&nbsp;&nbsp;&nbsp;&nbsp;db, err := sql.Open(\"mysql\", dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 这里的错误只是参数格式错误&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"db err\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 尝试连接数据库&nbsp;&nbsp;&nbsp;&nbsp;err = db.Ping()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"db filed\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}} 连接池连接 创建数据库句柄一般比较耗时, 所以我们使用连接池 123456789101112131415161718192021222324252627282930313233343536package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"database/sql\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版)// DB 数据库连接句柄var DB *sql.DBfunc initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sql.Open(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;err = DB.Ping()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;} // 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100) // 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}} 占位符 为防止SQL注入, 我们通常将用户信息等前端传来的可变数据通过占位符拼接, 需要注意的是, 不同数据库驱动的占位符不一样 查询数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"database/sql\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版) 增删改查// DB 数据库连接句柄var DB *sql.DB// User 结构体type User struct {&nbsp;&nbsp;&nbsp;&nbsp;id int&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;age int}func initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sql.Open(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;err = DB.Ping()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100)&nbsp;&nbsp;&nbsp;&nbsp;// 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;var user User&nbsp;&nbsp;&nbsp;&nbsp;// 查询单条数据&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"SELECT id,name,age FROM `user` WHERE id=1\"&nbsp;&nbsp;&nbsp;&nbsp;err = DB.QueryRow(sqlStr).Scan(&amp;user.id, &amp;user.name, &amp;user.age)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(user.id, user.name, user.age)&nbsp;&nbsp;&nbsp;&nbsp;var user2 User&nbsp;&nbsp;&nbsp;&nbsp;// 查询多条&nbsp;&nbsp;&nbsp;&nbsp;sqlStr2 := \"SELECT id,name,age FROM `user` where id &gt; ?\" // ?指占位符&nbsp;&nbsp;&nbsp;&nbsp;rows, err := DB.Query(sqlStr2, 0) // 将0替换到?&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// rows最后要close,不close会夯住&nbsp;&nbsp;&nbsp;&nbsp;defer rows.Close()&nbsp;&nbsp;&nbsp;&nbsp;// 循环读取数据&nbsp;&nbsp;&nbsp;&nbsp;for rows.Next() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = rows.Scan(&amp;user2.id, &amp;user2.name, &amp;user2.age)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(user2)&nbsp;&nbsp;&nbsp;&nbsp;}} 插入数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"database/sql\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版) 增删改查// DB 数据库连接句柄var DB *sql.DB// User 结构体type User struct {&nbsp;&nbsp;&nbsp;&nbsp;id int&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;age int}func initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sql.Open(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;err = DB.Ping()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100)&nbsp;&nbsp;&nbsp;&nbsp;// 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 插入数据&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"INSERT INTO `user`(`name`, age) VALUES(?, ?)\"&nbsp;&nbsp;&nbsp;&nbsp;name := \"u3\"&nbsp;&nbsp;&nbsp;&nbsp;age := \"33\"&nbsp;&nbsp;&nbsp;&nbsp;// 执行&nbsp;&nbsp;&nbsp;&nbsp;ret, err := DB.Exec(sqlStr, name, age)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 获取到插入数据的id(不同数据库有不同实现)&nbsp;&nbsp;&nbsp;&nbsp;ID, err := ret.LastInsertId()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ID)} 更新数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"database/sql\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版) 增删改查// DB 数据库连接句柄var DB *sql.DB// User 结构体type User struct {&nbsp;&nbsp;&nbsp;&nbsp;id int&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;age int}func initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sql.Open(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;err = DB.Ping()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100)&nbsp;&nbsp;&nbsp;&nbsp;// 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 更新数据&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"UPDATE `user` SET age=? WHERE id=?\"&nbsp;&nbsp;&nbsp;&nbsp;age := 222&nbsp;&nbsp;&nbsp;&nbsp;ID := 2&nbsp;&nbsp;&nbsp;&nbsp;ret, err := DB.Exec(sqlStr, age, ID)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 返回受影响的行数&nbsp;&nbsp;&nbsp;&nbsp;rowLen, err := ret.RowsAffected()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(rowLen)} 删除数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"database/sql\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版) 增删改查// DB 数据库连接句柄var DB *sql.DB// User 结构体type User struct {&nbsp;&nbsp;&nbsp;&nbsp;id int&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;age int}func initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sql.Open(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;err = DB.Ping()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100)&nbsp;&nbsp;&nbsp;&nbsp;// 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 删除数据&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"DELETE FROM `user`WHERE id=?\"&nbsp;&nbsp;&nbsp;&nbsp;ID := 3&nbsp;&nbsp;&nbsp;&nbsp;ret, err := DB.Exec(sqlStr, ID)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 返回受影响的行数&nbsp;&nbsp;&nbsp;&nbsp;rowLen, err := ret.RowsAffected()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(rowLen)} 预处理 sqly预处理是只不在本地进行SQL语句的拼接, 而是将sql语句和替换的字符串分开发送至sql server ,由sql server 对sql语句和字符串拼接/替换/执行. 预处理在应对大量重复sql语句的情况下会提高执行效率(例如执行某个表的100次相同操作), 而且可以避免SQL注入(不代表不预处理就不做防sql注入) 预处理增删改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"database/sql\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版) 增删改查// DB 数据库连接句柄var DB *sql.DB// User 结构体type User struct {&nbsp;&nbsp;&nbsp;&nbsp;id int&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;age int}func initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sql.Open(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;err = DB.Ping()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100)&nbsp;&nbsp;&nbsp;&nbsp;// 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 预处理&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"INSERT INTO `user`(`name`, age) VALUES(?, ?)\"&nbsp;&nbsp;&nbsp;&nbsp;// 不拼接&nbsp;&nbsp;&nbsp;&nbsp;stmt, err := DB.Prepare(sqlStr)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 注册关闭&nbsp;&nbsp;&nbsp;&nbsp;defer stmt.Close()&nbsp;&nbsp;&nbsp;&nbsp;// 执行重复的插入命令&nbsp;&nbsp;&nbsp;&nbsp;for i := 4; i &lt; 20; i++ {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name := fmt.Sprintf(\"u%d\", i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stmt.Exec(name, i)&nbsp;&nbsp;&nbsp;&nbsp;}} 预处理查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"database/sql\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版) 增删改查// DB 数据库连接句柄var DB *sql.DB// User 结构体type User struct {&nbsp;&nbsp;&nbsp;&nbsp;id int&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;age int}func initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sql.Open(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;err = DB.Ping()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100)&nbsp;&nbsp;&nbsp;&nbsp;// 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 预处理&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"SELECT id, name, age FROM user WHERE id=?\"&nbsp;&nbsp;&nbsp;&nbsp;// 不拼接&nbsp;&nbsp;&nbsp;&nbsp;stmt, err := DB.Prepare(sqlStr)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 注册关闭&nbsp;&nbsp;&nbsp;&nbsp;defer stmt.Close()&nbsp;&nbsp;&nbsp;&nbsp;// 执行重复的插入命令&nbsp;&nbsp;&nbsp;&nbsp;for i := 1; i &lt; 20; i++ {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rows, err := stmt.Query(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;defer rows.Close()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var id int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var age int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for rows.Next() {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rows.Scan(&amp;id, &amp;name, &amp;age)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(id, name, age)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 事务 事务开始后(Begin), 必须以 回滚(Rollback) 或 提交(Commit) 结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"database/sql\"&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版) 事务// DB 数据库连接句柄var DB *sql.DB// User 结构体type User struct {&nbsp;&nbsp;&nbsp;&nbsp;id int&nbsp;&nbsp;&nbsp;&nbsp;name string&nbsp;&nbsp;&nbsp;&nbsp;age int}func initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sql.Open(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;err = DB.Ping()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100)&nbsp;&nbsp;&nbsp;&nbsp;// 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 开始事务&nbsp;&nbsp;&nbsp;&nbsp;tx, err := DB.Begin()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 执行事务内操作&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"UPDATE user SET age=? WHERE id=?\"&nbsp;&nbsp;&nbsp;&nbsp;age := \"30\"&nbsp;&nbsp;&nbsp;&nbsp;ID := \"3\"&nbsp;&nbsp;&nbsp;&nbsp;// 执行&nbsp;&nbsp;&nbsp;&nbsp;_, err = tx.Exec(sqlStr, age, ID)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 出现错误回滚&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.Rollback()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;age = \"40\"&nbsp;&nbsp;&nbsp;&nbsp;ID = \"4\"&nbsp;&nbsp;&nbsp;&nbsp;// 执行&nbsp;&nbsp;&nbsp;&nbsp;_, err = tx.Exec(sqlStr, age, ID)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 出现错误回滚&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.Rollback()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 走到这里证明两条语句都执行成功&nbsp;&nbsp;&nbsp;&nbsp;// commit提交事务&nbsp;&nbsp;&nbsp;&nbsp;err = tx.Commit()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// commit也可能失败&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.Rollback()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}} 第三方库 SQLX 第三方库 sqlx 能简化操作, 特别是查询, 能够提高开发效率 安装 1go get -u github.com/jmoiron/sqlx 基本使用 查 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/jmoiron/sqlx\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版)// DB 数据库连接句柄var DB *sqlx.DB// User 结构体type User struct {&nbsp;&nbsp;&nbsp;&nbsp;ID int `db:\"id\"` // db的tag为sqlx所用,标记对应的字段名&nbsp;&nbsp;&nbsp;&nbsp;Name string `db:\"name\"`&nbsp;&nbsp;&nbsp;&nbsp;Age int `db:\"age\"`}func initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sqlx.Connect(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100)&nbsp;&nbsp;&nbsp;&nbsp;// 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}// 查询单行func queryDemo() {&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"SELECT id, name, age FROM user WHERE id=?\"&nbsp;&nbsp;&nbsp;&nbsp;var user User&nbsp;&nbsp;&nbsp;&nbsp;err := DB.Get(&amp;user, sqlStr, 1)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(user)}// 查询多行func querysDemo() {&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"SELECT id, name, age FROM user WHERE id&gt;?\"&nbsp;&nbsp;&nbsp;&nbsp;var users []User // 切片每个都是User&nbsp;&nbsp;&nbsp;&nbsp;err := DB.Select(&amp;users, sqlStr, 1)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;for _, user := range users {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(user)&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// queryDemo()&nbsp;&nbsp;&nbsp;&nbsp;querysDemo()} 增/删/改 与使用自带 sql 无区别 事务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/jmoiron/sqlx\"&nbsp;&nbsp;&nbsp;&nbsp;// 导入下载的驱动包, 前面加_ 代表只用了init()&nbsp;&nbsp;&nbsp;&nbsp;_ \"github.com/go-sql-driver/mysql\")// 连接mysql(连接池版)// DB 数据库连接句柄var DB *sqlx.DB// User 结构体type User struct {&nbsp;&nbsp;&nbsp;&nbsp;ID int `db:\"id\"` // db的tag为sqlx所用,标记对应的字段名&nbsp;&nbsp;&nbsp;&nbsp;Name string `db:\"name\"`&nbsp;&nbsp;&nbsp;&nbsp;Age int `db:\"age\"`}func initDB(dsn string) (err error) {&nbsp;&nbsp;&nbsp;&nbsp;DB, err = sqlx.Connect(\"mysql\", dsn) // 注意此处是将全局变量DB赋值mysql连接,所以是 = 而不是 :=&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置最大连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxOpenConns(100)&nbsp;&nbsp;&nbsp;&nbsp;// 最大空闲连接数(有默认)&nbsp;&nbsp;&nbsp;&nbsp;DB.SetMaxIdleConns(20)&nbsp;&nbsp;&nbsp;&nbsp;return nil}// 事务func transDemo() {&nbsp;&nbsp;&nbsp;&nbsp;// 如果MustExec引发panic, Beginx会自己Rollback&nbsp;&nbsp;&nbsp;&nbsp;tx, err := DB.Beginx()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;sqlStr := \"UPDATE user SET age=? WHERE id=?\"&nbsp;&nbsp;&nbsp;&nbsp;age := \"30\"&nbsp;&nbsp;&nbsp;&nbsp;ID := \"3\"&nbsp;&nbsp;&nbsp;&nbsp;tx.MustExec(sqlStr, age, ID) // 带Must方法一般指一出错直接panic&nbsp;&nbsp;&nbsp;&nbsp;age = \"40\"&nbsp;&nbsp;&nbsp;&nbsp;ID = \"4\"&nbsp;&nbsp;&nbsp;&nbsp;tx.MustExec(sqlStr, age, ID) // 带Must方法一般指一出错直接panic&nbsp;&nbsp;&nbsp;&nbsp;err = tx.Commit() // 提交&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.Rollback()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// dsn := \"user:password@tcp(ip:port)/databasename\"&nbsp;&nbsp;&nbsp;&nbsp;dsn := \"root:pwd@tcp(cdb-ecfs2q68.bj.tencentcdb.com:10075)/go_test\" // 连接信息&nbsp;&nbsp;&nbsp;&nbsp;err := initDB(dsn)&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(err)&nbsp;&nbsp;&nbsp;&nbsp;}} Go使用Redis https://www.liwenzhou.com/posts/Go/go_redis/ 12345678910111213141516171819202122232425262728293031package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/go-redis/redis\")// 连接池var redisDB *redis.Clientfunc initClient() (err error) {&nbsp;&nbsp;&nbsp;&nbsp;redisDB = redis.NewClient(&amp;redis.Options{ // 替换全局变量 redisDB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Addr: \"127.0.0.1:6379\", // HOST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Password: \"\", // 密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DB: 0, // 数据库&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;_, err = redisDB.Ping().Result() // 连接&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return err&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return nil}func main() {&nbsp;&nbsp;&nbsp;&nbsp;err := initClient()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 获取a1的值&nbsp;&nbsp;&nbsp;&nbsp;ret := redisDB.Get(\"a1\").Val()&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(ret)} NSQ消息队列 https://www.liwenzhou.com/posts/Go/go_nsq/ 依赖管理(old) https://www.liwenzhou.com/posts/Go/go_dependency/ 安装 1go get -u github.com/tools/godep 保存依赖信息 1godep save 会在当前目录下生成两个文件夹 Godeps vendor Godeps 存放项目依赖的包信息 vendor 存放项目依赖包的副本 使用 go语言编译时会优先找当前目录下的 vendor 文件夹,优先使用他的模块 依赖管理(new) go model 1.1后官方使用的依赖管理 https://www.liwenzhou.com/posts/Go/go_dependency/#autoid-2-5-0 go mod命令 打开mod支持 默认情况下 go mod 是关闭的, 我们需要先打开支持 1set GO111MODULE=on 生成mod 1go mod init 项目名 // 初始化 在当前目录下生成 go.mod 文件 下载依赖 1go mod download 根据 go.mod 文件下载依赖 Gin框架 https://gin-gonic.com/zh-cn/ https://www.liwenzhou.com/posts/Go/Gin_framework/ 安装/更新 123go get -u github.com/gin-gonic/gin 基础版 12345678910111213141516171819202122232425262728package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"net/http\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/gin-gonic/gin\")func indexHandler(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;// 返回 json, 状态码使用http包中的StatusOK(200)&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"msg\": \"hello\",&nbsp;&nbsp;&nbsp;&nbsp;})}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// 路由模式为 Default&nbsp;&nbsp;&nbsp;&nbsp;router := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;// /hello GET 返回JSON 状态码200&nbsp;&nbsp;&nbsp;&nbsp;router.GET(\"/hello\", func(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(200, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"msg\": \"hello\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;// /index GET&nbsp;&nbsp;&nbsp;&nbsp;router.GET(\"/index\", indexHandler)&nbsp;&nbsp;&nbsp;&nbsp;// 启动&nbsp;&nbsp;&nbsp;&nbsp;router.Run(\"127.0.0.1:9000\")} Gin请求方式 Gin支持接受所有请求方法, 包括GET/POST/PUT等等 当我们不想在路由时候限制某个请求的请求方式时, 选择 Any 即可 在函数内获取该请求的方式为 c.Request.Method 1234567891011121314151617181920package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/gin-gonic/gin\")func indexHandler(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;// 字符串形式 POST/GET/PUT ...&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(c.Request.Method)}// 路由组func main() {&nbsp;&nbsp;&nbsp;&nbsp;// Default默认使用Use 加了两个全局中间件, Logger(), Recovery(), Logger是打印日志, Recovery是panic返回500&nbsp;&nbsp;&nbsp;&nbsp;r := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;// Any代表匹配所有请求方式&nbsp;&nbsp;&nbsp;&nbsp;r.Any(\"/index\", indexHandler)&nbsp;&nbsp;&nbsp;&nbsp;r.Run(\"127.0.0.1:9000\")} Gin的渲染 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/gin-gonic/gin\")func indexHandler(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;// 返回 json, 状态码使用http包中的StatusOK(200)&nbsp;&nbsp;&nbsp;&nbsp;// c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;\"msg\": \"hello\",&nbsp;&nbsp;&nbsp;&nbsp;// })&nbsp;&nbsp;&nbsp;&nbsp;// 返回 HTMl(配合模板语法) 状态码, 模板文件, 模板文件传值&nbsp;&nbsp;&nbsp;&nbsp;// c.HTML(http.StatusOK, \"web/login.html\", gin.H{&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;\"msg\": \"login\",&nbsp;&nbsp;&nbsp;&nbsp;// })&nbsp;&nbsp;&nbsp;&nbsp;// 返回结构体对象(结构体字段首字母一定大写)&nbsp;&nbsp;&nbsp;&nbsp;// type info struct {&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;Info string `json:\"info\"`&nbsp;&nbsp;&nbsp;&nbsp;// }&nbsp;&nbsp;&nbsp;&nbsp;// i1 := info{&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;Info: \"aaa\",&nbsp;&nbsp;&nbsp;&nbsp;// }&nbsp;&nbsp;&nbsp;&nbsp;// c.JSON(http.StatusOK, i1)&nbsp;&nbsp;&nbsp;&nbsp;// 返回 XML&nbsp;&nbsp;&nbsp;&nbsp;// c.XML(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;\"msg\": \"hello\",&nbsp;&nbsp;&nbsp;&nbsp;// })&nbsp;&nbsp;&nbsp;&nbsp;// 结构体的XML&nbsp;&nbsp;&nbsp;&nbsp;// type info struct {&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;Info string&nbsp;&nbsp;&nbsp;&nbsp;// }&nbsp;&nbsp;&nbsp;&nbsp;// i1 := info{&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;Info: \"aaa\",&nbsp;&nbsp;&nbsp;&nbsp;// }&nbsp;&nbsp;&nbsp;&nbsp;// c.XML(http.StatusOK, i1)&nbsp;&nbsp;&nbsp;&nbsp;// yaml&nbsp;&nbsp;&nbsp;&nbsp;// c.YAML(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;\"msg\": \"hello\",&nbsp;&nbsp;&nbsp;&nbsp;// })}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// 路由模式为 Default&nbsp;&nbsp;&nbsp;&nbsp;router := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;// 加载模板文件夹(当前目录下的tpmplates文件夹下所有文件夹下所有模板文件)&nbsp;&nbsp;&nbsp;&nbsp;router.LoadHTMLGlob(\"templates/**/*\")&nbsp;&nbsp;&nbsp;&nbsp;// 设置静态文件目录(代码使用路径(url访问), 实际路径)&nbsp;&nbsp;&nbsp;&nbsp;router.Static(\"static\", \"./statics\")&nbsp;&nbsp;&nbsp;&nbsp;// /index GET&nbsp;&nbsp;&nbsp;&nbsp;router.GET(\"/index\", indexHandler)&nbsp;&nbsp;&nbsp;&nbsp;// 启动&nbsp;&nbsp;&nbsp;&nbsp;router.Run(\"127.0.0.1:9000\")} Gin获取参数 12345678910111213141516171819202122232425262728293031323334353637package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"net/http\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/gin-gonic/gin\")func indexHandler(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;// 获取url参数&nbsp;&nbsp;&nbsp;&nbsp;// a := c.Query(\"a\") // 没有参数为nil&nbsp;&nbsp;&nbsp;&nbsp;a := c.DefaultQuery(\"a\", \"av\") // 没有参数默认av&nbsp;&nbsp;&nbsp;&nbsp;// 获取form参数&nbsp;&nbsp;&nbsp;&nbsp;// f := c.PostForm(\"f\") // 没有参数为nil&nbsp;&nbsp;&nbsp;&nbsp;f := c.DefaultPostForm(\"f\", \"fdef\") // 没有参数默认 fdef&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"a\": a,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"f\": f,&nbsp;&nbsp;&nbsp;&nbsp;})}func urlHandler(c *gin.Context){&nbsp;&nbsp;&nbsp;&nbsp;// 提取url参数&nbsp;&nbsp;&nbsp;&nbsp;u := c.Param(\"id\")&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"u\": u,&nbsp;&nbsp;&nbsp;&nbsp;})}func main() {&nbsp;&nbsp;&nbsp;&nbsp;// 路由模式为 Default&nbsp;&nbsp;&nbsp;&nbsp;router := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;// /index GET&nbsp;&nbsp;&nbsp;&nbsp;router.GET(\"/index\", indexHandler)&nbsp;&nbsp;&nbsp;&nbsp;// 获取URL上的可变参数 id为可变参数&nbsp;&nbsp;&nbsp;&nbsp;router.GET(\"/urlget/:id\", urlHandler)&nbsp;&nbsp;&nbsp;&nbsp;// 启动&nbsp;&nbsp;&nbsp;&nbsp;router.Run(\"127.0.0.1:9000\")} Gin跳转 HTTP跳转 1c.Redirect(状态码, \"地址\") 路由跳转 12c.Request.URL.Path = \"跳转路由\"r.HandleContext(c) Gin路由组 当路由较多时, 我们通常将路由分组管理(美观易维护) 此时我们将路由进行分组 可多层嵌套(层越多效率越慢) 在HttpRouter包封装(使用前缀树匹配比其他的使用反射速度快很多) 原理是创造了路由地址的前缀树(所以层越多路由匹配越慢) 1234567891011121314151617// 路由组func main() {&nbsp;&nbsp;&nbsp;&nbsp;r := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;// 普通路由(多了不易维护)&nbsp;&nbsp;&nbsp;&nbsp;r.GET(\"/book\", bookListHandler)&nbsp;&nbsp;&nbsp;&nbsp;r.POST(\"/book\", bookInsertHandler)&nbsp;&nbsp;&nbsp;&nbsp;r.DELETE(\"/book/:ID\", bookDeleteHandler)&nbsp;&nbsp;&nbsp;&nbsp;// 分组路由(易维护,可多层嵌套)&nbsp;&nbsp;&nbsp;&nbsp;apiV1Group := r.Group(\"/api/v1\")&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apiV1Group.GET(\"/index\", v1IndexHandler) // URL: /api/v1/index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apiV1Group.GET(\"/home\", v1HomeHandler) // URL: /api/v1/home&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;r.Run(\"127.0.0.1:9000\")} Gin上传文件 单文件 12345678910111213141516171819202122232425262728293031323334package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"net/http\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/gin-gonic/gin\")func fileHandler(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;fileObj, err := c.FormFile(\"file\") // file为字段名&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusInternalServerError, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"err\": err,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// filePath 要保存在本地的路径(相对)&nbsp;&nbsp;&nbsp;&nbsp;filePath := fmt.Sprintf(\"./%s\", fileObj.Filename) // fileObj.Filename: 上传文件的文件名&nbsp;&nbsp;&nbsp;&nbsp;// 保存文件到本地&nbsp;&nbsp;&nbsp;&nbsp;c.SaveUploadedFile(fileObj, filePath)&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"data\": filePath,&nbsp;&nbsp;&nbsp;&nbsp;})}// 路由组func main() {&nbsp;&nbsp;&nbsp;&nbsp;r := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;// 提交文件默认是32MB大小&nbsp;&nbsp;&nbsp;&nbsp;r.MaxMultipartMemory = 8&lt;&lt;20 // 8MB&nbsp;&nbsp;&nbsp;&nbsp;// 接受文件&nbsp;&nbsp;&nbsp;&nbsp;r.POST(\"/file\", fileHandler)&nbsp;&nbsp;&nbsp;&nbsp;r.Run(\"127.0.0.1:9000\")} 多文件 123456789101112131415161718192021222324252627282930package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/gin-gonic/gin\")func fileHandler(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;form, err := c.MultipartForm()&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;files := form.File[\"file\"]&nbsp;&nbsp;&nbsp;&nbsp;for index, file := range files {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// index 顺序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(index)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst := fmt.Sprintf(\"./%s\", file.Filename)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.SaveUploadedFile(file, dst)&nbsp;&nbsp;&nbsp;&nbsp;}}// 路由组func main() {&nbsp;&nbsp;&nbsp;&nbsp;r := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;// 提交文件默认是32MB大小&nbsp;&nbsp;&nbsp;&nbsp;r.MaxMultipartMemory = 8 &lt;&lt; 20 // 8MB&nbsp;&nbsp;&nbsp;&nbsp;// 接受文件&nbsp;&nbsp;&nbsp;&nbsp;r.POST(\"/file\", fileHandler)&nbsp;&nbsp;&nbsp;&nbsp;r.Run(\"127.0.0.1:9000\")} Gin中间件 比如某些接口我们需要用户登陆后才可以进行操作, 这时候我们可以在每个函数内引用一次判断, 但是中间件可以统一并轻松的做到这一点. 中间件的信息传递使用 c.Set(“key”, “v”), 上文设置k,v, 下文使用 c.MustGet(“key”) 即可获得反射的值, 使用类型断言 比如 c.MustGet(“key”).(string)转字符串类型 12345678910111213141516171819202122232425262728293031323334353637package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"time\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/gin-gonic/gin\")func indexHandler(c *gin.Context) {}// 统计耗时的中间件func castTime(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;// 获取当前时间&nbsp;&nbsp;&nbsp;&nbsp;startTime := time.Now()&nbsp;&nbsp;&nbsp;&nbsp;// 运行下一个注册的Handler函数&nbsp;&nbsp;&nbsp;&nbsp;c.Next()&nbsp;&nbsp;&nbsp;&nbsp;// 统计耗时&nbsp;&nbsp;&nbsp;&nbsp;cast := time.Since(startTime)&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(cast)}// 路由组func main() {&nbsp;&nbsp;&nbsp;&nbsp;// Default默认使用Use 加了两个全局中间件, Logger(), Recovery(), Logger是打印日志, Recovery是panic返回500&nbsp;&nbsp;&nbsp;&nbsp;r := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;// (全局中间件) r.Use代表全局中间件&nbsp;&nbsp;&nbsp;&nbsp;r.Use(castTime)&nbsp;&nbsp;&nbsp;&nbsp;// (单url中间件) 路由注册时可以写多个函数, 请求进入先进第一个再往后走, 可以做中间件&nbsp;&nbsp;&nbsp;&nbsp;r.GET(\"/index\", castTime, indexHandler)&nbsp;&nbsp;&nbsp;&nbsp;// (组中间件)&nbsp;&nbsp;&nbsp;&nbsp;apiV1Group := r.Group(\"/api/v1\", castTime)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apiV1Group.GET(\"/index\", v1IndexHandler) // URL: /api/v1/index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apiV1Group.GET(\"/home\", v1HomeHandler) // URL: /api/v1/home&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;r.Run(\"127.0.0.1:9000\")} 参数绑定 我们处理用户请求的时候, 使用结构体绑定的方法来与用户发送的数据结合,往往能使代码更加简洁, 这就也是参数绑定 123456789101112131415161718192021222324252627282930313233343536373839package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"net/http\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/gin-gonic/gin\")// 数据绑定// User structtype User struct {&nbsp;&nbsp;&nbsp;&nbsp;// form tag 代表该字段对应的请求字段名, binding tag 代表没接收到传错(不写默认不报错)&nbsp;&nbsp;&nbsp;&nbsp;Username string `form:\"username\" json:\"username\" binding:\"required\"`&nbsp;&nbsp;&nbsp;&nbsp;Password string `form:\"password\" json:\"password\" binding:\"required\"`}func indexHandler(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;if c.Request.Method == \"POST\" {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 实例化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var u User&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 将结构体u与用户传来的字段进行绑定(根据Content-Type来按格式解析)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := c.ShouldBind(&amp;u)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"err\": err.Error(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 绑定成功,拿到数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(u)&nbsp;&nbsp;&nbsp;&nbsp;}}// 路由组func main() {&nbsp;&nbsp;&nbsp;&nbsp;// Default默认使用Use 加了两个全局中间件, Logger(), Recovery(), Logger是打印日志, Recovery是panic返回500&nbsp;&nbsp;&nbsp;&nbsp;r := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;// Any代表匹配所有请求方式&nbsp;&nbsp;&nbsp;&nbsp;r.Any(\"/index\", indexHandler)&nbsp;&nbsp;&nbsp;&nbsp;r.Run(\"127.0.0.1:9000\")} Gin连表查询 多表联合查询, 业务中常见的查询 跨表查询我们可以使用多种途径应对 sqlx结构体嵌套 因为sqlx传入的是一个结构体, 而与数据库的同步需要对照 db 的 tag, 所以我们可以使用结构体嵌套 要注意的是结构体嵌套过程中务必避免结构体的字段相同否则只会返回最外面的结构体(实际上只是 c.JSON 时出现的错误) sqlx结构体不镶嵌 我们也可以直接将所有返回值写一个结构体里 sql 我们不使用sqlx模块, 而是直接赋值给变量, 再组合拿到想要的结果也是可以的 logrus模块(日志) https://www.liwenzhou.com/posts/Go/go_logrus/ 使用 123456789101112131415161718192021222324package main// logrousimport (&nbsp;&nbsp;&nbsp;&nbsp;log \"github.com/sirupsen/logrus\")func main() {&nbsp;&nbsp;&nbsp;&nbsp;// 设置此项输出的日志为JSON格式&nbsp;&nbsp;&nbsp;&nbsp;log.SetFormatter(&amp;log.JSONFormatter{})&nbsp;&nbsp;&nbsp;&nbsp;// 设置此项有字段表示打印日志的文件位置(对性能有影响,不推荐线上使用)&nbsp;&nbsp;&nbsp;&nbsp;log.SetReportCaller(true)&nbsp;&nbsp;&nbsp;&nbsp;// 终端打印日志&nbsp;&nbsp;&nbsp;&nbsp;Userinf := log.WithFields(log.Fields{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"name\": \"t1\",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"age\": 3000,&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;// .Info指级别&nbsp;&nbsp;&nbsp;&nbsp;Userinf.Info(\"user info\")&nbsp;&nbsp;&nbsp;&nbsp;// time=\"2019-08-22T16:36:00+08:00\" level=info msg=\"user info\" age=3000 name=t1&nbsp;&nbsp;&nbsp;&nbsp;log.Info(\"info\") // 可不加自定义key/v&nbsp;&nbsp;&nbsp;&nbsp;// time=\"2019-08-22T17:08:16+08:00\" level=info msg=info} 搭配Gin使用 https://www.liwenzhou.com/posts/Go/go_logrus/#autoid-0-12-0 安装 1go get -u github.com/sirupsen/logrus Cookie/Session HTTP 协议是无状态的, 所以需要Cookie和Session来保存一些状态/标识 https://www.liwenzhou.com/posts/Go/Cookie_Session/ Cookie Cookie 本质上是存储在浏览器上的多个键值对, 是保存于某个文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport (&nbsp;&nbsp;&nbsp;&nbsp;\"fmt\"&nbsp;&nbsp;&nbsp;&nbsp;\"net/http\"&nbsp;&nbsp;&nbsp;&nbsp;\"github.com/gin-gonic/gin\")// Cookie示例// User structtype User struct {&nbsp;&nbsp;&nbsp;&nbsp;// form tag 代表该字段对应的请求字段名, binding tag 代表没接收到传错(不写默认不报错)&nbsp;&nbsp;&nbsp;&nbsp;Username string `form:\"username\" json:\"username\" binding:\"required\"`&nbsp;&nbsp;&nbsp;&nbsp;Password string `form:\"password\" json:\"password\" binding:\"required\"`}func getCookie(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;username, err := c.Cookie(\"username\")&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"code\": 1005,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// 设置username并执行下一个函数&nbsp;&nbsp;&nbsp;&nbsp;c.Set(\"username\", username)&nbsp;&nbsp;&nbsp;&nbsp;c.Next()}func cookieHandler(c *gin.Context) {&nbsp;&nbsp;&nbsp;&nbsp;// GET验证Cookie&nbsp;&nbsp;&nbsp;&nbsp;if c.Request.Method == \"GET\" {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;username, ok := c.Get(\"username\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ok {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 取到&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(username.(string))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 没取到&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"code\": 1008,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;// POST生成Cookie&nbsp;&nbsp;&nbsp;&nbsp;if c.Request.Method == \"post\" {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 参数绑定&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var u User&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err := c.ShouldBind(&amp;u)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"code\": 1001,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 身份验证&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if u.Username == \"t1\" &amp;&amp; u.Password == \"t1p\" {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 生成Cookie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.SetCookie(\"username\", u.Username, 20, \"/\", \"127.0.0.1\", false, true)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.JSON(http.StatusOK, gin.H{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"code\": 1003,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}}func main() {&nbsp;&nbsp;&nbsp;&nbsp;r := gin.Default()&nbsp;&nbsp;&nbsp;&nbsp;r.Any(\"/cookie\", getCookie, cookieHandler)&nbsp;&nbsp;&nbsp;&nbsp;r.Run(\"127.0.0.1:9000\")} Session Cookie是保存在浏览器端的, 所以Cookie有被人篡改或仿造的危险, 而且Cookie最大支持4KB的数据, 所以Session出现了 Session实际上是在服务器端保存用户的信息, 然后随机生成一个标识返回给浏览器Cookie, Cookie相当于这个钥匙, 拿到钥匙才能证明你的身份, 而且所有数据都在服务端, 客户端只有钥匙, 加大了安全性 Session是保存在服务器的键值对 Session必须依赖Cookie","link":"/2021/09/04/go_base/"},{"title":"使用Cron定时任务模块","text":"基本使用 本章介绍在Go中使用Cron定时任务模块来实现逻辑 在项目中, 我们往往需要定时执行一些逻辑, 举个例子, 财务系统每月需要自动的总结报表发生到指定邮箱, 生成饼图存储等逻辑, 作为服务方, 我们必须维护一个定时任务系统来做到定时触发任务执行 下面介绍Go项目中很出名的定时任务模块, Cron 他的star目前有9.6k(截止到本章更新) 下面我们来了解如何使用, 以Demo为例 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"context\" \"fmt\" \"log\" \"os\" \"os/signal\" \"github.com/robfig/cron/v3\")var myCron *cron.Cron// InitAndStart init cron taskfunc InitAndStart() { myCron = cron.New() // c.AddFunc // https://en.wikipedia.org/wiki/Cron userOfflineDetectionTaskID, err := myCron.AddFunc(fmt.Sprintf(\"*/%v * * * * \", 1), userOfflineDetection) if err != nil { log.Fatal(err) } log.Printf(\"Successfully Add userOfflineDetection To Cron, ID: %v\", userOfflineDetectionTaskID) // start myCron.Run()}// userOfflineDetection User offline detectionfunc userOfflineDetection() { log.Println(\"Run DEMO\")}func main() { go InitAndStart() _, cancel := context.WithCancel(context.Background()) defer cancel() // 关闭管道 c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) &lt;-c} 这里我是讲其作为一个模块来使用, 因为在实际使用中需要执行的定时任务不止一个, 而且代码逻辑可能比较长, 所以我将 cron 对象单独 var 出来供其他函数使用 代码的入口在 InitAndStart 函数, 在一切的开始, 我们需要先 New 出 *cron.Cron 寄存器才可以, 使用 cron.New() 生成一个任务的寄存器对象 我们希望在主程序运行结束时能主动的将寄存器停止, 所以在 New 完后立刻使用 defer 注册关闭逻辑 .Stop().Done() 是通知下游要关闭寄存器了, 等待下游手上的任务全部处理完毕即结束 随后就是注册任务了, 使用 AddFunc函数来注册任务, 他接受两个参数, 参数一指定了该函数什么时候去触发执行, 参数二就是其要执行的函数了 关于参数一, 采用的是和unix的任务定时任务一样的格式, 比如我写的代表每1分钟执行一次, 具体的规则可查看 wiki (需FQ) 此处我注册的30秒执行一次 userOfflineDetection 函数 同时 cron 可同时注册很多个定时任务, 只需使用 AddFunc 注册即可 myCron.Start() 则启动寄存器, 如果这个Goroutine中已经启动了 Cron, 则不进行任何操作 需要注意的是, 在寄存器启动后你仍然可以使用 AddFunc 来注册新的定时任务, 也是可以正常的注册的, 例如 12myCron.Start(). // Start 不会导致阻塞, Run 会阻塞myCron.AddFunc(\"* 1 * * *\", userOfflineDetection) 如果你想要对每一个注册过的定时任务进行控制, 还记得AddFunc返回的结果吗, 其参数1是这个任务的ID, 参数二为可能的err错误 以上为 Cron 的基本用法, 希望对你有所帮助 v3版本参数兼容 如果你使用了常用的在线 cron 生成器, 例如 在线Cron表达式生成器 (qqe2.com) 等, 需要特别注意的是, 目前99%的在线 cron生成的都是 6 位的 cron 表达式, 6位的 cron 实际上并不是标准的 cron 规则, 而是Tutorial 6 (quartz-scheduler.org) 提供的超集, 实现了秒级的控制 原版 cron 123456789# ┌───────────── minute (0 - 59)# │ ┌───────────── hour (0 - 23)# │ │ ┌───────────── day of the month (1 - 31)# │ │ │ ┌───────────── month (1 - 12)# │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday;# │ │ │ │ │ 7 is also Sunday on some systems)# │ │ │ │ │# │ │ │ │ │# * * * * * &lt;command to execute&gt; quartz 1234567891011Cron-Expressions are used to configure instances of CronTrigger. Cron-Expressions are strings that are actually made up of seven sub-expressions, that describe individual details of the schedule. These sub-expression are separated with white-space, and represent:SecondsMinutesHoursDay-of-MonthMonthDay-of-WeekYear (optional field)An example of a complete cron-expression is the string&nbsp;_“0 0 12 ? * WED”_&nbsp;- which means “every Wednesday at 12:00:00 pm”. 而在 cron v3 版本中, 默认并不支持秒级 cron, 也是就是6位表达式, 会抛出异常 1expected exactly 5 fields, found 6: 如果想要加入对秒级控制的支持, 可以参照如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"context\" \"fmt\" \"log\" \"os\" \"os/signal\" \"github.com/robfig/cron/v3\")var myCron *cron.Cron// InitAndStart init cron taskfunc InitAndStart() { myCron = cron.New(cron.WithSeconds()) // add seconds parse support // c.AddFunc // https://en.wikipedia.org/wiki/Cron userOfflineDetectionTaskID, err := myCron.AddFunc(fmt.Sprintf(\"0 */%v * * * * \", 1), userOfflineDetection) if err != nil { log.Fatal(err) } log.Printf(\"Successfully Add userOfflineDetection To Cron, ID: %v\", userOfflineDetectionTaskID) // start &amp;&amp; Run myCron.Run()}// userOfflineDetection User offline detectionfunc userOfflineDetection() { log.Println(\"Run DEMO\")}func main() { go InitAndStart() _, cancel := context.WithCancel(context.Background()) defer cancel() // 关闭管道 c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) &lt;-c}","link":"/2021/09/04/go_cron/"},{"title":"Golang 常问知识点(简略)","text":"前言 稍微记录一下问题点吧, 文章会不断的优化更新 有些比较大的知识点, 比如锁原理啥的, 会单独拎出来写一篇, 这里只是大概 Go 语言的基础数据类型占用大小 类型 大小(字节) Int8 1 Int16 2 Int32 4 Int64 8 int 4/8 Float32 4 Float64 8 string 1/2~4 bool 1 Go 语言的变量分配在栈还是堆 Frequently Asked Questions (FAQ) - The Go Programming Language 引用类型, 比如 切片,map 是堆 对于函数内部的变量, 其分配规则由编译器自己决定, 规则如下: 编译器会进行变量的逃逸分析. 当某个变量在函数外也使用时, 作用域不仅仅在函数内时, 比如 return 出变量的值的地址, 这种情况就会把数据分配到堆中. 此外, 如果某个变量的值很大的时候, 也会分配到堆中. 其他正常情况, 函数内的变量都在栈中 select是随机还是顺序 Why is the select statement non-deterministic? : golang (reddit.com) 是随机的 在 select 的执行函数selectgo中, 会先将 case 的顺序打乱 据说是为了保持均衡, 不出现比如总是命中第一个 case, 导致其他下面的 case 完全不执行的情况, 尤其是 select 还通常用来监听多个 channel Go 语言的垃圾回收 三色标记法与读写屏障 - 简书 (jianshu.com) Golang 垃圾回收剖析 | Legendtkl 什么时候进行垃圾回收 调用 runtime.GC() 进行主动垃圾回收(主动) 当堆上的活跃对象大于 4M(默认) 的时候进行 GC 上次 GC 的2分钟后 当前没有开启 GC 的时候 标记 GC go 语言使用的是三色标记法 他有三种颜色(标记): 白色代表还未访问过 灰色代表对象已经访问过, 但是本对象引用到的其他对象没有访问完 黑色代表对象和引用到的其他对象都已经访问完 1.初始时，所有对象都在 【白色集合】中； 2.将GC Roots 直接引用到的对象 挪到 【灰色集合】中； 3.从灰色集合中获取对象： 3.1. 将本对象 引用到的 其他对象 全部挪到 【灰色集合】中； 3.2. 将本对象 挪到 【黑色集合】里面。 4.重复步骤3，直至【灰色集合】为空时结束。 5.结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。 当 CG 过程中, 新增了变量, 或者手动把变量的值设置成 nil, 默认把他设置成黑色, 留给下一次 GC 再处理 Go 协程 Go 语言调度器与 Goroutine 实现原理 | Go 语言设计与实现 (draveness.me) Go 在启动的时候会根据硬件的状态占用对应的进程和线程(默认1核1个), 然后通过内部的调度器来进行协程的切换, 减少操作系统和硬件的负载. 从 1.14 版本开始, 使用的是抢占式调度. 调度器由 3 个部分组成, GMP 模型说的就是这个 G - goroutine, 就是需要执行的任务, 包含了任务的执行函数, goroutine 状态和一些信息 M - 操作系统的线程, 这个是由操作系统进行调度和管理, 这里是真正执行计算的部分 P - 调度器的逻辑. 存放线程 M 执行的上下文 G G 里包含了需要执行的任务, 是 Go 给用户态提供的类似线程的东西, 只是因为是自己维护的, 可以做到更小的占用内存空间, 同时降低了上下文切换的开销 M M 是真正的操作系统线程, 比如说 4 核, 就会有 4 个线程, 但是我们可以启动很多 goroutine, 而调度器帮助我们把这些 goroutine 落到线程中, 开发者感觉到 goroutine 是并行, 实际上是调度器将其进行排队后放到线程里运行 P P 是联通 G 和 M 的中间层他会去将若干个 goroutine 进行排队和调度, 比如说在某一个 goroutine 进行 I/O 操作时让出资源给另一个 G GMP 优势(相比多线程开发) goroutine 更加轻量(2kb), 线程1~2M 切换更加的快速, 减少内核切换的资源消耗 GMP 中 G 的状态 空闲(Gidle): 刚新建, 未初始化 等待运行(Grunnable): 在队列中等待运行 运行中(Grunning): 表示操作系统线程 M 正在运行这个 G 系统调用中(Gsyscall): M 正在运行这个 G 发起的系统调用, 此时 M 并不拥有 G 等待中(Gwaiting): G 正在等待某些东西完成, 这时候 G 没有运行也不在运行队列中 已终止(Gdead): G 没有被使用, 可能已经执行完毕 栈复制中(Gcopystack): G正在获取新的栈空间并且把原有数据复制进去(防止 GC 清理) GMP 中 M 的状态 自旋中: M 正在从运行队列中获取 G 执行 Go 代码中: 正在运行 G 执行原生代码中: 正在运行 G 的 syscall 休眠中: 没有 G 时进行休眠 GMP 中 P 的状态 空闲中: M 没有 G 需要运行时, P 空闲 运行中: M 正在运行 G 系统调用中: G 正在 syscall GC 停止中: GC 导致整个世界停止 终止: 多余的 P 会终止 GMP 抢占式调度 有一个额外的线程M进行死循环, 去检查 G 的运行时间, 如果超过10ms, 则去抢占这个 G 使用的 P, 交给其他的 G 使用 通知 G 停止使用的是信号协作 Go 两个结构体生成的对象能不能相互比较 同一个结构体生成的对象可以相互比较 不同的如果结构和顺序完全一致也可以 Go 的 context go语言的context - ChnMig的个人网站 context 主要是为了控制 goroutine 的生命周期, ctx 传进去之后 select 监听 Done 信号就行 另外 redis 包等一些包在调用时需要传入ctx 参数, 一般使用 TODO context有四种, 分别是: WithCancel 需要手动的出发Done才会取消 WithDeadline 指定一个终止时间(明确的时间), 当时间到就自动取消 WithTimeout 指定一个终止时间间隔, 当时间间隔到时自动取消 WithValue 这个目的不是取消, 而是上下文之间的数据传输 context 内有一个 channel, 当需要关闭时, 向这个 channel 发送数据通知关闭 interface interface 虽然说可以放进任意的数据, 比如说一个切片的 value 是 interface 类型, 但是放进去之后就变成了 interface 类型, 即使拿出来还要通过断言来转, 所以基本不用 用接口的稍微多一些, 比如统一的推送接口, 让钉钉包和邮件包都实现这个接口, 然后需要发送时 for 这几个对象, 调用接口即可 goroutine 控制 wg 来进行夯住整个程序操作, Add之后Done进行夯住程序结束 使用 context 生成 ctx, 监听 Done 队列可以在外层进行通知关闭, goroutine 内进行关闭操作, 主动退出 堆和栈 Golang内存分配逃逸分析 (driverzhang.github.io) 分配规则 栈存放占用小的数据, 栈先进先出, 而且栈在分配时必须要指定长度 当在函数内部申请栈的内存时, 当函数结束, 栈内存会直接释放而不通过 GC, 不会影响性能 当函数内部的变量, 作为返回值返回了, 也就是说其作用域不仅仅在函数内部, 那么即使占用小还是会分配到堆上, 引起 GC 如果申请的内存比较大, 比如长度为20000的切片, 即使作用域只在内部, 也会申请到堆上 对于在编译时不能确定长度的数据, 也会分配到堆上 逃逸分析 决定分配到堆还是栈的不是开发者而是 go 的编译器, 当编译器检测到某个变量会发生逃逸, 就一定会存放到堆上 指针逃逸: 函数返回局部变量的指针时 栈空间不足: 局部变量的数据长度过大时 动态类型逃逸: 函数的参数为 interface 这种, 编译器无法确认大小时 闭包引用对象逃逸: 变量被闭包引用时 优雅的结束程序 设置一个管道监听强制结束的 os 信号, 同时设置 defer 的 ctx 12345ctx, cancel := context.WithCancel(context.Background())defer cancel() // 关闭管道c := make(chan os.Signal, 1)signal.Notify(c, os.Interrupt)&lt;-c CSP 并发模型 不要以共享内存的方式来通信, 相反, 要通过通信来共享内存 例如Python, Java这种语言, 他们一般使用线程进行并发, 因为都是属于一个进程, 所以通过共享的内存来进行通信, 比如说如何控制关闭python下的某一个线程, 更安全的做法可能是维护一个字典保存对应状态, 让每个线程去获取字典来判断是否需要停止, 这种通过共享内存的方式进行通信, 要考虑一些问题 例如数据读写抢占问题, 比如Python在必要的时候会加一个锁来防止资源竞争, 这样其实就提高了编写时的逻辑复杂度, 因为你要考虑到死锁的可能性 而对于Golang来讲, 他使用 GMP 模型给开发者包装成了goroutine, 让开发者能很容易的启用并发, 而对于每个 goroutine之间的通信, Golang推荐使用channel管道来处理, 而不是共享内存 一般的, 逻辑可以抽象成流水式, 可能中间的某一步, 需要通过并发的方式来提高效率, 然后到某一步的时候, 又需要进行流控, 比如说数据的入库等, 使用共享内存的方式, 可能是向同一个变量存储数据, 而在Golang中, 我们就可以让并发的那一步数据向channel里发送, 而下一步从channel中读取, 从而进行流控 锁 当代码中确实可能存在多个goroutine试图修改同一个数据时, 就需要加锁, 锁分为两种 互斥锁 互斥锁在被占用后, 其他协程完全无法访问, 不可读更不可写 1234// 互斥锁, 占用后不可读也不可写var lock sync.Mutexlock.Lock() // 加锁lock.Unlock() // 解锁 互斥锁内部使用信号量+自旋的方式来进行锁的处理 读写锁 读写互斥锁可以添加两种锁, 读锁和写锁, 在读锁上锁时其他协程可读不可写, 写锁上锁时其他协程不可写不可读 1234567// 读写互斥锁var rwlock sync.RWMutexrwlock.RLock() // 读锁, 此时其他协程不可写, 不可读rwlock.RUnlock()rwlock.Lock() // 写锁, 此时其他协程无法写, 可以读rwlock.Unlock() 读写锁中写锁为互斥锁, 而读锁就是一个数字, 因为其并不互斥, 只是在加写锁时有用 单例 在很多时候, 我们需要保证某个操作只执行一次, 例如生成配置文件, 你可能把他包装成一个模块让别人使用, 而你无法控制使用者只调用一次你的读取函数, 有一种方法是在内部生成对象, 在调用读取函数时先查看是否为nil, 你也可以使用 sync.Once 1234567891011121314151617package configimport ( \"sync\")type Config struct {}var config *Configvar once sync.Once // 生成只执行一次的\"锁\"func InitConfig() *Config { once.Do(func() { // Do 接收一个函数 config = &amp;Config{} // 在函数内进行初始化 }) return config // 返回} sync.Once内部包含了一个互斥锁和一个布尔值, 互斥锁保证了在第一次执行时不会有抢占, 布尔值保证了只会执行一次 map 并发 在多个goroutine 操控同一个 map 时, 可能会出现并发数据争抢问题, 官方为我们提供了sync.Map, 是并发安全的, 使用时不需要 make, 他是并发安全的 sync.map生成的 map 有以下几种方法 store: 更新/插入 load: 获取 delete: 删除 loadOrStore: 有则返回, 没有则插入 range: 遍历输出 sync.map主要通过两个数据集的方式, 来读写分离, 提高效率 原子操作 go 当然也有很多的原子操作, 保证不会出现抢占问题, 在包 sync/atomic 中 比如 AddInt64 就是向一个 int64 值中增加某数 直接使用原子操作要比自己加锁来实现的效率高 map 的底层实现 go 语言的 map 是 hashmap, 使用数组+链表的形式实现 将key经过哈希并切分生成高位和低位数, 通过低位数寻找存储在哪个数组, 通过高位数寻找存储在这个数组的哪一个地方 map 内的key和value存储排列是 1key0, key1, key2, value0, value1, value2 这是因为key和value分别为不同的数据结构, 将至分别放在一起可以达到内存对齐的目的 sort 排序算法 自带的sort包使用简单, 实现对应接口即可 12345type Interface interface { Len() int // Len方法返回集合中的元素个数 Less(i, j int) bool // i&gt;j，该方法返回索引i的元素是否比索引j的元素小、 Swap(i, j int) // 交换i, j的值} sort内部根据不同情况选择不同的排序算法 当长度小于12时进行希尔排序 长度大于12时, 使用快速排序 希尔排序 希尔排序的时间复杂度是O(n^(1.3-2)), 在应对数据不长的时候速度较快, 其步骤如下 计算增量, 初始是gap=length/2, 如果列表长度是12就是6 将原本的列表按照步长跳跃, 分为6个子列表, 每个列表有2个数据, 例如[1, 3, 2, 4]就将其拆分为[1, 2]和[3, 4] 将这几个子列表进行排序比较(当然并不是真的独立出来, 只是在原列表中根据索引比对) 缩小增量, gap=gap/2 重复步骤2, 3, 4 增量缩小为1, 结束 在长度不多的时候, 增量不会很大, 缩小起来很快, 速度较快 快速排序 在数据较大的时候, 快排的速度更快, 时间复杂度为o(nlogn) 快速排序是有L(索引)和R(索引)和temp(固定值), 由此来进行分区, 步骤如下 L开始是第0位(索引), R开始是最后一位(索引), temp为第0位 将L向后移动, 如果扫描到L的值小于temp的值, 则将temp的位置与L当前的位置进行调换 L不动, 将R向前移动, 如果扫描到R的值小于temp的值, 则将temp的位置与R当前的位置进行调换 循环步骤2, 3一直到L和R相等, 此时以temp为界, 左边比temp小, 右边比temp大 按照temp为界, 将左边和右边分别重复步骤1到4, 一直到分不出来, 结束 快排主要是通过分界, 将列表切分, 然后对切分的子列表再切分, 达到排序的目的 Defer defer 主要用于延迟调用, defer 会在函数返回之前执行 defer 注册的函数 defer 的注册顺序和执行顺序是相反的, 也就是先进后出 另外, defer 可以与recover一起使用, 类似于 python 的try, 来捕捉程序的panic, 从而防止程序直接退出 12345defer func() { if r := recover(); r != nil { // 捕捉 fmt.Println(\"Recovered in f\", r) }}() goroutine如何阻塞 WaitGroup进行等待 监听ctx.Done()管道 for循环 向一个没有接受者并且缓冲区已满的 chan 发送数据 从一个没有发送者并且缓冲区为空的 chan 读取数据 goroutine 什么时候发生阻塞 等待 channel 发生一次系统调用等待回调结果 … goroutine 阻塞时调度器怎么做 调度器将阻塞的 goroutine 放到一边, 切换到其他 goroutine 继续执行, 直到这个 goroutine 结束阻塞 channel 自动关闭 在这个 channel 没有goroutine 持有时, 会自动关闭 goroutine 的最大数量 在1.4版本之后, 一个 goroutine 占用2kb的内存大小 限制协程数量 使用 channel 来限制协程数量, channel 缓冲区的长度就是协程最大数量 12345678910111213var ch chan intfunc test(i int) { fmt.Println(i) time.Sleep(1 * 1e9) &lt;-ch // goroutine 运行结束后将指标返回}func main() { ch = make(chan int, 10) // 最多允许10个 goroutine for i:=0; i&lt;1000; i++ { ch&lt;-i // 有指标再进行 goroutine 启动, 没有就一直夯住 go test(i) }} new 和 make 区别 new 分配内存 new 为新的类型分配内存, 返回对应的指针, 比如创建 对象, struct 等 new 返回的是指针, 不使用指针的时候一般不使用 new make 初始化 返回类型的初始值, 只适用于切片/map/channel go 的内存分配 分为3块 spans: 512MB bitmap: 16GB arena: 512GB arena 堆区, 动态分配的内存在这里, go 把内存分割成每个 8kb 的若干页(page) bitmap 标记 arena 对象的地址, 并有4bit 标志位标识了对象是否包含指针和 GC 标记信息 bitmap 中一个 bytes(8bit) 大小的内存对应 arena 里4个指针大小(32bit)的内存, spans span 是 go 内存管理的基本单位, span 有多种规格, 每个规格占用若干个 page, 最大的 span 是32kb, 超过32kb 则是特殊的 class 结构体作为参数传入时, 传值还是指针 go 都是值传递, 只是参数可以选值类型还是引用类型 看具体的逻辑, 如果需要修改结构体的值时, 需要传入指针来修改数据 其他时候传值, 因为结构体一般存储在栈上(前提是结构体不是特别大), 栈的代价很小, 而传指针有可能会引发内存逃逸 go 中使用过线程吗 GMP 模型中 M 为操作系统线程, 由 go 调度, 实际的应用开发中没有直接使用过 linux 有几种线程模型 一对一(M:1) 多对一(1:1) 多对多(M:N) go 线程中某一个发生了 OOM(内存泄露) 会怎样 kill 掉这个线程, 不影响其他线程 goroutine 发生 OOM 什么情况 没遇到过, 本地写代码发生过内存逃逸, 发现是 slice 的坑 OOM 排查 个人经验是 OOM 基本都是 giroutine 泄露, 使用 pprof 定位问题然后排查 错误处理怎么做 不是特别简单的逻辑, 牵扯到调用其他服务的函数, 一定有 error 返回值 外面通过判断 err!=nil 进行错误捕捉, 通过fmt.Errorf(\"test\")进行 error 创建 goroutine 发生 panic 会怎样 如果没有设置recover捕捉, 会导致整个程序崩溃 goroutine 是互相独立的, recover必须在本层, 否则无法捕捉 panic 怎么管理的 proto 文件 单独的仓库存放, 通过 git 管理 gin 框架使用参数校验 gin 内置了 go-playground/validator: 💯Go Struct and Field validation, including Cross Field, Cross Struct, Map, Slice and Array diving (github.com) 插件, 先定义校验的结构体, 通过tag的方式指定字段名字, 是否必填等信息, 通过 c.ShouldBind来进行参数的校验 gin 的中间件 经常使用自己写的同意跨域中间件 gin.Default()默认带两个中间件, 一个是打印日志, 一个是捕捉 panic 处理成500错误 使用router.Use()添加自定义中间件 gin 跨域中间件 跨域主要是浏览器从服务端返回的 Header 中获取指定的 key, 来判断是否是跨域的 浏览器将请求分为两种: 简单请求 使用 GET、POST、HEAD 其中一种请求方法。 HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求的同意跨域, 直接在返回值的 header 中插入Access-Control-Allow-Origin: *即可 非简单请求 请求方法是 put 或 delete, 或者 content-type 的类型是 application/json 其实简单请求之外的都是非简单请求了 浏览器在处理非简单请求时, 会先发送OPTIONS方法, 查看返回值的 header 字段, 符合要求则同意跨域 gin 使用中间件时, 使用c.Header添加Header数据, 使用c.Next()将请求处理移交到下一部分 go 怎么解析 tag 使用反射进行 tag 的解析 反射原理 go 的reflect包提供了反射的支持 获取对象的 type 和 value 的元数据和一些方法, 进行调用 反射一般不使用 可读性差 可能会 panic 影响效率 channel的坑 向一个已经 close 的 chan 写入数据会 panic 从一个已经 close 的 chan 读取数据会获取到 chan 数据类型的默认值 推荐使用for i := range chan或者select来读取 chan 数据, 这样在关闭后自动退出 有可能造成 goroutine 阻塞 负载均衡算法 哈希 根据 hash 取模进行分配, 保证同一个 key 会分配到同一个节点 可能会导致不均衡 轮询 所有节点进行轮询, 排序选择分配的节点 请求均衡, 但是负载不一定 随机 随机选一个节点 类似轮询 加权轮询 根据权重优先分配给权重高的节点 select 执行原理 具体的代码在selectgo中 先将 case 打乱顺序, 然后尝试从 chan 获取值, 没有则运行 default, 没有定义 default 时将所在的 G 加入到对应的 N 个 chan 监听队列中等待唤醒 channel 关闭后对 channel 操作会出现什么 使用clse(ch1)来关闭管道 在 close 时, go 会将 chan 中等待插入数据的 goroutine 全部唤醒, 并且设置插入的值为 nil 如果从 chan 中尝试发送数据, 会导致程序panic 如果从 chan 中尝试读取数据, 会读取出存储类型的默认值, 不会 panic 大对象/小对象/微对象 大对象 占用内存&gt;32kb 时, 认为他是大对象 大对象分配不走 mcache 和 mcentral, 直接通过 mheap 分配 小对象 16b&lt;占用内存&lt;32kb 时, 认为他是小对象 小对象先获取到合适大小的的 mspan, 并存储到 mheap 中 微对象 占用内存&lt;16b 时, 认为他是微对象 微对象直接存储在 mcache 上, 每个微对象的大小是16b","link":"/2022/01/20/go_interview/"},{"title":"Golang 的锁","text":"前言 go 语言的锁, 一说大家都知道, 一个是互斥锁Mutex, 一个是读写互斥锁RWMutex, 用起来很简单, 但是要想在技术上更进一步, 还是需要了解其原理 基础知识 进程同步 既然是锁, 就意味着在加锁之后, 其他goroutine获取锁, 就需要等待, 这里就需要了解操作系统的进程同步机制 进程同步其实是控制临界区内的权限, 当一个进程进入临界区时, 其他想进入临界区的进程只能等待, 也就是说, 临界区是互斥的, 而临界区内的资源, 则是临界资源 访问临界区有几种情况: 空闲让进: 当没有进程在临界区时, 代表临界区是空闲的, 此时一个进程可以立即进入临界区, 访问临界资源 忙等: 当已经有进程在临界区内时, 代表临界区有人正在访问, 所以其他想要进入临界区的进程必须等待 有限等待: 当进程等待访问临界区时, 设置一定的超时时间, 避免一直等待 让权: 当进程访问临界区发现需要等待时, 立刻释放资源, 避免夯住 信号量 那么在一个进程结束后, 怎么通知其他进程进入呢? 这就需要信号量 信号量分为四种类型: 整形信号量 记录型信号量 AND 型信号量 信号量集 以整形信号量为例, 核心是设置一个用于表示资源数量的整形 A, 这个 A 有两种操作, 一个是减小(wait), 一个是增大(signal) 在进入资源区时进行wait操作, 在退出时进行signal操作 通过对信号量的大小对比, 可以获取当前等待进程和正在运行的进程数量与当前的状态 自旋 在进程不能进入临界区时, 会进行等待, 但是并不是立刻就进入等待了, 而是先不停的去侦测这个锁是否有被释放掉, 这个过程被称作自旋, 这也是锁的一种, 在自旋过程中, 如果发现临界区空置了, 就立刻进入临界区. 自旋其实就是隔一段时间访问一次临界区查看是否空闲, 所以自旋过程中, 这个进程并不是等待的 自旋的存在目的是为了更加的高效, 因为有可能在等待时间很短, 自旋可以让进程不必切换状态 而缺点是因为进程不是等待, 还在运作, 会导致资源损耗, 所以在等待时, 先使用自旋进行获取锁, 在几次之后依旧获取不到, 则变为等待状态 自旋的问题 如果每一个新来的进程都在获取不到锁时, 进行回旋, 就会出现一个问题, 比如之前有3个进程在自旋后依旧没有获取到锁, 进入到了等待状态, 此时一个新的进程来了, 他在获取不到锁时, 进入了自旋状态, 而此时占用锁的进程退出了, 那么这一个新的进程就会最先获取到锁, 类似于插队的问题, 这样显然是不公平的, 为了解决这个问题, 一般是为锁增加饥饿状态, 在饥饿状态下, 不允许进程进入自旋, 直接等待 互斥锁 在了解基本的知识后, 我们来套入到 go 语言中 互斥锁在被占用后, 其他协程完全无法访问, 不可读更不可写 1234// 互斥锁, 占用后不可读也不可写var lock sync.Mutexlock.Lock() // 加锁lock.Unlock() // 解锁 结构 sync.Mutex的数据结构如下 1234type Mutex struct { state int32 // 当前互斥锁的状态 sema uint32 // 锁的信号量} state state记录了四个状态. 分别是: waiter_num(29bit): 当前等待抢占这个锁的goroutine数量 starving(1bit): 当前锁是否处于饥饿状态(0:无/1:有) woken(1bit): 当前锁是否有goroutine已经被唤醒(0:无/1:有) locked(1bit): 当前锁是否被goroutine持有(0:无/1:有) sema sema 记录了信号量, 当锁被一个goroutine释放时, 会释放这个信号量, 唤醒之前抢锁的正在阻塞的goroutine来获取锁 运行流程 正常模式 在正常模式下, 等待的协程按照先入先出的方式排列, 当一个协程被信号唤醒后, 这个协程并不是直接获取到锁, 而是和刚刚到达的协程一起竞争锁的所有权. 新到的协程有一个优势, 就是他因为刚到, 现在还在 CPU 上运行, 而唤醒的协程, 刚从等待状态准备启动, 而且新到的协程有可能不止一个, 所以这个被唤醒的协程很大概率抢不到锁. 为了解决这个问题, 被唤醒的这个协程会被放到等待队列的第一位. 由他来第一个获取锁, 如果等待的协程超过1ms 内没有获取到锁, 此时会把这个锁设置为饥饿模式 饥饿模式 在饥饿模式下, 解锁的协程会将锁的所有权直接交给等待队列第一位的协程. 并且新的协程到达也不会进行自旋来获取锁, 而是直接加入等待队列的队尾. 而等待队列中的协程获取到锁的时候, 会查看 自己是否是等待队列的最后一个协程 自己的等待时间是否小于1ms 如果有任意一个满足要求, 则将锁修改为正常模式 锁在初始时, 为正常模式, 正常模式下效率更高, 因为在释放锁的一瞬间新的协程可以迅速获取锁, 而饥饿模式则在有协程等待1ms 之后运行, 可以让等待的协程优先获取到锁 读写锁 读写互斥锁可以添加两种锁, 读锁和写锁, 在读锁上锁时其他协程可读不可写, 写锁上锁时其他协程不可写不可读 1234567// 读写互斥锁var rwlock sync.RWMutexrwlock.RLock() // 读锁, 此时其他协程不可写, 不可读rwlock.RUnlock()rwlock.Lock() // 写锁, 此时其他协程无法写, 可以读rwlock.Unlock() 结构 1234567type RWMutex struct { w Mutex // 写锁(互斥) writerSem uint32 // 写锁信号量 readerSem uint32 // 读锁信号量 readerCount int32 // 读锁计数器 readerWait int32 // 等待读锁释放的协程数} 读写锁中等级最高的锁还是写锁, 当加上写锁后其他协程无论是读还是写都会阻塞, 所以写锁也是互斥的 运行流程 这里就分为读锁和写锁了, 当用户上写锁, 其实就是上了个互斥锁, 此时所有新的协程都会阻塞, 类似于上面的互斥锁, 这里不过多的赘述 而加读锁, 实际上就是一个数字, readerCount自增, 此时如果加写锁, 会判断读锁计数器是否为0, 为0则上写锁(互斥), 如果加读锁, 就是readerCount自增 如果写锁释放了, 此时有一些协程请求加写锁, 一些请求加读锁, 会优先将锁分配给写锁 如果读锁释放了, 此时有一些协程请求加写锁, 会等待readerCount为0时加写锁","link":"/2022/02/11/go_lock/"},{"title":"Golang map 的底层原理","text":"前言 本文介绍 golang 中 map 的实现方式, 希望对读者和我有所帮助 结构 map是 go 语言中的基础的数据结构, 在寻找指定key时, 复杂度是O(1), 在某些场景能发挥很大的作用 golang 的 map 是 hashmap, 实现方式是数组+链表, 并且使用拉链法来取消 hash 的冲突 map 主要有两个核心的数据结构, hmap和bmap(bucket), 为什么说他核心呢? 因为 map 的实现就是依靠这两个结构体 hmap的结构有以下几个字段 元素个数: int flags: uint8 扩容字段: uint8 溢出的 bucket 数量: uint16 用于扩容的指针: *mapextra buckets 数组指针: unsafa.Pointer 搬迁进度: uintptr 扩容时用于复制的 buckets 数组: unsafe.Pointer hash seed: uint32 这里你需要重点了解的是buckets 数组指针, 也就是bmap, 那么bmap的结构如下 高位哈希: [8]uint8 字节数组(存储 key 和 value 的数组): []bytes 指向扩容 bucket 的指针: pointer 在bmap的字节数组中, 存储了我们真正的key和value 而高位哈希中存储了key的索引 指向扩容 bucket 的指针则存储了下一个bmap的位置, 所以说 bucket 是链表形式 对于bmap中的字节数组部分存储这个bmap里面的所有key和value, 他是一个数组, 里面存储的结构是这样的 1key0, key1, key2, value0, value1, value2 是将所有的 key和key排在一起,value和value排在一起 这是为了内存对齐, 目的是减少空间浪费 也就是说, hmap的结构应该是 123456 hmap bmap0 bmap1 bmap2| | |bmap3 bmap4 bmap5| | | 这种关系(我真是灵魂画手😘) 大致理解一下, 就是一个hmap里面包含了一个切片, 切片的每一个元素是bmap, 而每一个bmap里含有这个bmap的key和value(多个), 还有下一个bmap的指针地址 新增 key 时 当新增一个key和value时, 会先对这个key进行哈希函数计算, 得到一个唯一的值, 是一个数字, 将这个数字切分为两个部分高位和低位, 使用低位寻找这个key应该存储到哪个bmap中, 高位则记录了这个key在bmap的位置 map 扩容 当 map 空间不够时, 会将bmap的数组数量扩充一倍, 产生一个新的bmap数组 然后把老的数据迁移到新的数组中 这个转移并不是立刻完成的, 而是当访问到具体的某个bmap的时候, 才会把这个bmap中的数据转移到新的数组 而且, 将老的bmap转移到新的列表之后, 并不会将老的bmap删除, 而是留给 GC 去清理 查找 key 时 获取需要查找的key, 转成数字并切分为高位和低位, 通过低位定位bmap位置. 通过高位在bmap中寻找具体的值","link":"/2022/02/10/go_map_theory/"},{"title":"Golang 内存分配","text":"一般的内存分配 一般而言, 内存都会被程序分为以下几个逻辑块 全局区: 存放全局变量 栈区: 存放函数中的基础类类型变量 堆区: 动态分配的内存, 比如 go 的切片 常量区: 存放常量数据 程序代码区: 存放程序本身的代码 go 内存分配思想 go 内置了运行时的编程语言(runtime), 所谓运行时, 就是在程序开始时就申请了一大块的虚拟内存, 由 go 自己进行分配和管理. 用来避免在运行的时候再向操作系统申请内存, 带来性能问题. go 的内存分配核心思想是: 每次从操作系统申请一大块内存, 由 go 来对内存进行分配和管理, 减少系统调用 内存分配算法采用 google 的 TCMalloc 算法, 把内存切分的很细, 再通过多级进行管理, 降低锁粒度 回收对象内存时, 并不是真正的将内存返回给操作系统, 而是放回自己的大块内存中等待复用, 只有闲置过多时才会尝试返回部分内存给操作系统. go 的内存结构 go 的内存结构分为三大块: spans(512MB): 存放 span 指针, 每个指针指向 arena 的一个 page bitmap(16GB): 保存 arena 对应的某个地址是否存在对象, 和对象是否 GC 信息 arena(512GB): 真正存放值的地方, area 按照8KB 分配若干个 page arena arena 存放了真正的值, 很多人也把他称之为heap, heap 从两个角度来看, 有两种说法 从内存分配角度: 按照 8KB 分配若干个 page, page合在一起组成了 heap 从使用角度: heap 存放若干个对象 spans spans 可以理解为 heap 的户口信息, 用来管理 heap 区域的数据, spans 存放的是mspan指针, 每个 page都属于某个mspan bitmap bitmap存放了 arena 中的对象标记, 比如标记对应的地址中是否存在对象, 是否被 GC 标记 因此, bitmap 主要还是为了服务 GC go 内存管理组件 go 内存管理组件有以下几个: mspan: 内存管理基本单元, 管理 mcache: 缓存, 每个运行时的 goroutine 都会绑定一个 mcache, mcache 会分配这个 goroutine 运行时需要的内存空间(mspan) mcentral: 为所有 mcache 切分好后备的 mspan, 收集给定大小和登记的所有 span mheap代表Go程序持有的所有堆空间。还会管理闲置的span，需要时向操作系统申请新内存 mspan 上面提到了名词mspan, mspan 可以说是 go 内存管理的基本单元, 而 page 是内存存储的基本单元 mspan 可以解决内存碎片问题, 我们知道, 内存的地址都是连到一起的, 连续的, 举个例子, 同一时间申请了两个内存, a 和 b, a 和 b 是连续的, 两者在内存中是挨着的, 此时 b 被清理了, b 的地址内数据变成空, 此时申请存放新的数据, 并不会检测到 b 是空了就直接放到 b, 而是会在 b 后面申请 c, 这就造成了在内存中很可能有很多空位, 这就是内存碎片 go 为了解决内存碎片问题. 将内存分为67种, 每种有不同数量的 page, 这每一种就是 mspan.每次分配时, 根据数据的不同, 分配给不同的 mspan. 当某个 mspan 被清理后, 在语言内部将这个标记为已清理, 等待下一次重新使用 mchahe 为了避免多线程申请内存时不断的加锁, goroutine为每个线程分配了 span 内存块的缓存, 这个缓存即是 mcache, 每个goroutine都会绑定的一个 mcache, 避免了各个goroutine申请内存时存在锁竞争的情况 在 GMP 并发调度模型中, 每个 G 都绑定一个 mcache, 因此不会出现大家一起占用一个内存, 导致需要加锁竞争的情况, 提高速度 mcentral mcentral保存一种特定类型的全局 mspan 列表，包括已分配出去的和未分配出去的, 目的是为所有 mcache 提供切分好的 mspan 有67种 mspan, 也就有67种 mcentral 每个 mcentral 都会包含两个 mspan的列表： 没有空闲对象或 mspan已经被 mcache缓存的 mspan列表 有空闲对象的 mspan列表 由于 mspan是全局的，会被所有的 mcache访问，所以会出现并发性问题，因而 mcentral会存在一个锁。 mheap mheap可以认为是Go程序持有的整个堆空间， mheap全局唯一，可以认为是个全局变量 mheap 包含了整个 go 内部的 heap 数据信息, 除了 mcache, mcache被包含在GMP 中的 G 里 因为有些对象通过 mheap 分配(大于32kb), 而 mheap 全局唯一, 而 mcache有时候需要进行申请内存分配, 因为 GMP 中 G 不止一个, 所以为了防止资源竞争, 在 mheap 中有一个互斥锁, 保证同一时刻只有一个 G 可以申请内存","link":"/2022/02/20/go_memory_theory/"},{"title":"go pprof 分析内存和 CPU 占用","text":"前言 pprof 是 golang 自带的非常好用的性能分析工具, 可以分析 CPU/内存占用等, 本篇来简单记录一下基本使用 pprof 的基本信息可见: pprof/README.md at main · google/pprof (github.com) web 版 针对长时间运行而不中断的项目, 我们想实时获取最新的分析数据, 可以使用 pprof 新增一个 http 服务, pprof package - net/http/pprof - Go Packages, 让我们可以持续的监听性能数据, 例如: 12345678910111213141516package mainimport ( \"net/http\" _ \"net/http/pprof\")func main() { go func() { // 启动一个 goroutine, 不阻止正常代码运行 http.ListenAndServe(\"localhost:6060\", nil) // 使用 pprof 监听端口 }() for { // 死循环模拟不停止的项目 }} CPU分析 保持分析程序未结束时, 在新的命令行运行命令 1go tool pprof -http 127.0.0.1:8848 http://localhost:6060/debug/pprof/profile\\?seconds\\=30 这命令的意思是使用 pprof 分析 http://localhost:6060/debug/pprof/profile?seconds=30 的数据, 当我们访问这个接口时, 会下载对应文件再分析, 比如这个网址代表最近30s 内的 cpu 运行数据, 此时会等待30s, 抓取数据, 而后会使用默认浏览器打开网址 127.0.0.1:8848 里面就展示了 cpu 运行信息, 我们可以点击上方菜单栏选择使用火焰图等方式进行展示, 具体的图表这里不放了, 看再多不如自己真实试一试. 内存占用分析 大体逻辑一样, 只是数据源换成了内存分析, 例如 1go tool pprof -http 127.0.0.1:8849 http://localhost:8080/debug/pprof/heap 更多 还有更多的数据类型, 比如锁分析, 堆数据, 线程追踪等, 可查看 http://localhost:6060/debug/pprof/ 查看可分析的数据类型, 使用只需替换 pprof 最后的网址即可 runtime 版 针对执行一段时间就关闭的程序, 可以使用 pprof package - runtime/pprof - Go Packages 来进行分析, 具体用法为在执行结束后生成 pprof 源文件, 再通过 pprof 工具来打开, 例如有代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"flag\" \"fmt\" \"log\" \"os\" \"runtime\" \"runtime/pprof\")var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to `file`\") // 指定 cpu 分析文件名var memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\") // 指定 meme 分析文件名func main() { flag.Parse() if *cpuprofile != \"\" { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(\"could not create CPU profile: \", err) } defer f.Close() // error handling omitted for example if err := pprof.StartCPUProfile(f); err != nil { log.Fatal(\"could not start CPU profile: \", err) } defer pprof.StopCPUProfile() } // ... rest of the program ... if *memprofile != \"\" { f, err := os.Create(*memprofile) if err != nil { log.Fatal(\"could not create memory profile: \", err) } defer f.Close() // error handling omitted for example runtime.GC() // get up-to-date statistics if err := pprof.WriteHeapProfile(f); err != nil { log.Fatal(\"could not write memory profile: \", err) } }} 运行代码, 同时携带参数指定保存文件 1go run main.go -cpuprofile cpu.pprof -memprofile=mem.pprof 随后会发现, 在项目根目录创建了同名的文件 CPU分析 与 web 版类似, 只是源文件由http 接口下载变成了文件, 其实 http 接口也是 get 时下载对应的文件再分析 1go tool pprof -http 127.0.0.1:8848 ./cpu.pprof 内存分析 1go tool pprof -http 127.0.0.1:8848 ./mem.pprof","link":"/2022/08/01/go_pprof/"},{"title":"go select 原理解析","text":"概述 go 的 select 语句是专门为了 channel 发送和接收消息而诞生的专用语句(不要和 switch 搞混了), 在语句的运行期间, 该 goroutine 是阻塞的. select 在 golang 的语言层提供了I/O 多路复用, 可以同时检测多个 channel I/O 多路复用 有必要了解一下 I/O 多路复用概念 在不使用 select 时, 如果要监听 N 个 channel. 对于普通的多线程处理, 可能需要启动 N 个 goroutine, 每个 goroutine 监听一个 channel, 这样的缺点显而易见: 系统需要额外的创建和维护goroutine, 因为大多数时候, channel 都会阻塞, 只有少部分会接受到数据 而使用 select 时, 可以做到在一个 goroutine 里监听多个 channel, 系统只需要维护一个 goroutine, N 个 channel 都依靠这一个 goroutine 进行数据的\"运输\", 当其中某一个 channel 有数据时, 根据对应的 channel 走不同的流程, 无需对额外的 goroutine 进行管理, 无疑提高了效率 当然, select 也不要无节制的使用, 最好是在逻辑上有一定的关联性, 否则会破坏代码的可读性. demo 举个例子 12345678910111213141516func main() { ch1 := make(chan int, 1) ch2 := make(chan int, 1) select { case v := &lt;-ch1: // 如果ch1通道成功读取数据，则执行该case处理语句 fmt.Printf(\"ch1 = %v\", v) case v := &lt;-ch2: // 如果ch2通道成功读取数据，则执行该case处理语句 fmt.Printf(\"ch2 = %v\", v) default: // 如果上面case都没有成功，则进入default处理流程 // 如果没有 default, 会一直阻塞等待某个 case 成功 fmt.Println(\"default!\") }} 注意两个问题: select 并不是一个循环, 如果你需要反复的监听多个 channel, 搭配 for{}使用 default 作用是当 case 都不成功时, 立刻进入 default 流程, 结束 select, 如果你需要阻塞住, 就不要使用 default 当搭配for{}反复的执行 slelct 时, 如非业务要求, 否则不要使用 default, 会造成select 立即退出后重新循环 所以, 常用的方式如下 1234567891011for { select { case v := &lt;-ch1: // 如果ch1通道成功读取数据，则执行该case处理语句 fmt.Printf(\"ch1 = %v\", v) case v := &lt;-ch2: // 如果ch2通道成功读取数据，则执行该case处理语句 fmt.Printf(\"ch2 = %v\", v) } // 一次读取之后立刻再次监听} 数据结构 select 底层由两部分组成, case 语句和执行函数 每一个 case 语句结构如下 1234type scase struct { c *hchan // chan elem unsafe.Pointer // 读或者写的缓冲区地址} 这里的 hchan, 存放了监听的 channel, 在一个 select 中, 包含了多个 case. 这些 case 组成了一个数组 selectgo 而执行的 select 语句, 实际上调用了函数func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) 参数意义如下: cas0: case 数组中第一个case的地址 order0: case数组两倍长的缓冲区 ncases: case 数组的长度 selectgo 返回的说所选的 scase 的索引, 而如果 scase 是接收操作, 则返回是否收到值 流程 我们在运行一个 select 时, 函数的调用顺序如下 func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool) func rselect([]runtimeSelect) (chosen int, recvOK bool) func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) 前两个都是简单的初始化参数, 重点其实就在selectgo里 selectgo 的处理流程如下: 根据 cas0 获取 case 数组 将 case 数组顺序打乱 将 case 数组内的每个 chan 全部上锁 遍历所有的 case 数组元素, 查看其是否可读和可写 如果有可读或可写 case, 解锁所有的 chan, 返回对应的 chan 数据 如果没有可读或可写, 有 defalut, 解锁所有的 chan, 返回 default 对应的 case 如果两者都没有, 则将当前的 goroutine 阻塞, 将当前 goroutine的 G加入到case 数组内的所有 chan 的等待队列中, 然后所有 chan 解锁 如果其中有一个 chan 可读或者可写时, 并且轮到这个 G 进行操作时, 将 goroutine 唤醒 执行步骤3-7","link":"/2022/02/22/go_select_theory/"},{"title":"go 语言的 slice 注意点","text":"前言 起因是在编写某个模块时, 考虑到slice良好的伸缩性, 便使用slice来存储大量的数据, 业务是slice的数据会慢慢的弹出减少, 理想状态下内存占用会越来越少, 结果发现, 占用的内存并不会返还, 于是查了一下, 好家伙 😵‍💫, 坑还不少, 索性这里记录一下坑吧 slice slice其实是一个指向底层数组的指针结构体, 这个结构体有三个属性, 分别是: 指向数组的指针 元素的长度 底层数组的长度 我们都知道, 数组是固定长度的, 而切片是动态扩容的, 所以, 切片结构有一个底层数组的长度, 使用cap()可以查看, 当发现插入后的长度大于原先的底层数组的长度时, 会进行扩容, 即将申请一个新的数组,将原来的数据放置到新的数组中, 将指向数组的指针也修改为新的指针 slice扩容的策略是: 原先的数组长度 &lt; 1024 时, 扩容后的容量为原先的2倍 原先的数组长度 &gt; 1024 时, 扩容后的容量为原先的1.25倍 数据共享问题 看以下代码 123456789func t1() { a1 := []int{1, 2, 3, 4} a2 := a1 a3 := a1[:3] a1[0] = 5 fmt.Println(a1, a2, a3)} 运行结果是 1[5 2 3 4] [5 2 3 4] [5 2 3] 可以看到, 只修改了a1, 却造成了a2和a3一起改变, 这代表此时a1/a2/a3共享了数据 我们再看代码 123456789func t2() { a1 := []int{1, 2, 3, 4} a2 := append(a1, 6) a3 := a1[:3] a1[0] = 5 fmt.Println(a1, a2, a3)} 结果是 1[5 2 3 4] [1 2 3 4 6] [5 2 3] 这里的a1/a3共享了数据, a2就单独使用了, 这是因为append()会面临内存的重新分配问题, 在a2进行append()时候, 重新申请了内存空间, 将a1指向的数据拷贝一份, 然后增加了新值5, 放入了新的地址中, 此时a2的地址与a1/a3不一样, 所以对a1进行修改只影响到了a1/a2 再看代码 123456789101112func t3() { a1 := []int{1, 2, 3, 4} a2 := append(a1, 6) a3 := a1[:1] fmt.Println(cap(a3)) a3 = append(a3, 6) fmt.Println(cap(a3)) a1[0] = 5 fmt.Println(a1, a2, a3)} 运行结果 12344[5 6 3 4] [1 2 3 4 6] [5 6] 我们这里发现了两个疑点 a3经过append()还是与a1共享数据 还记得最开始提到的切片扩容机制吗? 没错, 对于append(), 在执行时也会有两种分支区别, 只有容量不够才会进行重新分配, 步骤与普通的切片扩容一致 如果容量够, 比如这里, a3的容量与a1一致是4, 而a3长度由1增加到2, 没有超过4, 因此没有进行内存的重新分配, 导致a3/a1继续共享数据 而a2在append()时, 长度变成5, 原有的容量不够, 因此进行了内存的重新分配 对a3进行append()在a1的中间进行了数值插入 因为a3是截取的a1[:1], 所以对a3进行append()在不重新分配内存的时候就会在a[0]后添加数据 变量逃逸问题 因为存在变量共享的问题, 那么变量逃逸也就出现了 举个例子 123456func t5() { a1 := []int{1, 2, 3, 4, 5, 6} b1 := a1[:2] // a1 不再使用 fmt.Println(b1)} 假如a1很大, 占用很多内存, 此时你只想获取a1的某一段数据, 而a1以后不再使用, 因为变量共享, 此时就会导致 GC 时a1的长切片不会被回收, 仍然存在与内存中, 如果这个函数一直运行, 这将是一个很大的隐患 正确做法是, 在明确a1不使用时, 将a1赋值成nil, 例如 12345678func t5() { a1 := []int{1, 2, 3, 4, 5, 6} b1 := []int{} // 创建一个空切片 b1 = append(b1, a1[:2]...) // 通过 append 添加需要的元素 a1 = nil // 将 a1 设置为 nil // a1 不再使用 fmt.Println(b1, cap(b1))} 运行结果为 1[1 2] 2","link":"/2022/02/14/go_slice_memory/"},{"title":"sync.waitGroup 原理分析","text":"前言 sync的常用包好像都快讲完了, 最近几天进度很快啊, 希望能多多保持. sync.WaitGroup是为了解决任务编排而出现的, 主要就是解决并发-等待问题, 因此在真正编写过程中也很常用, 本篇大致讲解其内部实现的方式 Demo 简单介绍一下用法 123456789func main() { wg := sync.WaitGroup{} wg.Add(1) // wg计数+1 go func() { defer wg.Done() // wg计数-1 time.Sleep(3 * time.Second) }() wg.Wait() // 等待 wg 结束(wg计数为0)} 对应sync.WaitGroup来讲, 只有三种方法: Add(delta int): 为计数器添加一定的数字 Done(): 为计数器数字减去1 Wait(): 夯住等待计数器数字变成0 结构 和往常一样, 先从结构开始看起 123456789type WaitGroup struct { // 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则 noCopy noCopy // 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数 // 另外32bit是用作信号量的 // 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法 // 总之，会找到对齐的那64bit作为state，其余的32bit做信号量 state1 [3]uint32} noCopy: 这个是一个使用技巧, 如果一个结构体中有此字段, vet 工具会在编译时检查避免被 copy 使用 state1: 从定义可以看出, 其长度为3, 每个32bit, 里面包含了waitGroup的计数值和信号量和 waiter 计数 state1 结构 123state[0] // 调用 wait 等待的 goroutine 数量state[1] // 计数state[2] // 信号量 Add Add主要是对state1字段中的计数值部分进行操作, 步骤如下: 将参数delta左移32位 将值加到计数值上(state1[1]), 这个值是可负可正 Done Done实际上就是调用Add(-1) 而检测到-1之后的计数值为0时, 通过信号量唤醒正在wait的阻塞协程 Wait 调用wait时, 会将waiter+1, 然后将自身加入到等待队列中并阻塞, 等待Done时的唤醒","link":"/2022/02/15/go_sync_waitgroup_theory/"},{"title":"vscode 设置引用分层","text":"前言 对于一个团队来讲, 维持一样的代码风格非常重要. 而现代的开发工具, 都提供了很好的支持, 这里简单记录一下 VsCode 的一些设置 VsCode 安装 Go 插件 在 VsCode 中安装插件: Go - Visual Studio Marketplace 该插件使用tools/gopls at master · golang/tools (github.com)进行代码的格式化, gopls 是 google 官方出品, 品质有保障 在安装完插件之后, 还需要下载一些依赖才可以正常运行 在 VsCode 内使用快捷键(mac) command+shift+p, 会弹出一个窗口, 在窗口内输入Go: Install/Update Tools, 然后回车等待安装完毕即可, 或者可以参照官方文档的安装方式: Go - Visual Studio Marketplace VsCode 设置 import 风格 在安装了 go 插件之后, 默认在每次保存代码时(手动和自动), 都会格式化代码, 包括 import 区域, 可以看到默认情况下将 import 分为两大块, 一块是引用的开源包, 一块是内部的引用包和 go 内置的包, 例如 1234567891011import ( \"fmt\" // go 内置的模块 \"os\" \"scmdb/common/mongo\" // 本项目的其他模块 \"scmdb/config\" // 本项目的其他模块 \"time\" \"github.com/globalsign/mgo\" // 开源包, 存在 vendor 中 \"github.com/globalsign/mgo/bson\") 其中, 将内置的模块与本项目的模块混合在了一起, 导致可读性出现些许问题, 其实这些可以在 gopls 中指定本地包名: tools/settings.md at master · golang/tools (github.com) 我们需要在本地的项目根目录下新增.vscode文件夹, 下新增settings.json文件(已经有则直接新增内容), 新增内容如下 12345{ \"gopls\": { \"formatting.local\": \"scmdb\" // 设置为本地包名 }} 随后重新打开 VsCode, 执行一次保存后(有时候需要删除 import 块让他重新添加), 发现已经变成了 1234567891011import ( \"fmt\" \"os\" \"time\" \"github.com/globalsign/mgo\" \"github.com/globalsign/mgo/bson\" \"scmdb/common/mongo\" \"scmdb/config\") gopls 的更多设置项查看tools/settings.md at master · golang/tools (github.com)","link":"/2022/04/18/go_vscode_style/"},{"title":"sync.map 原理分析","text":"普通的 map 普通的map并不是并发安全的, 但是在 go 的1.6之前不会报错, 但是会出现问题, 1.6之后会直接报错.例如以下代码: 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"time\")func main() { m := map[string]int{\"age\": 10} // 普通的 map // 启动协程对 map 修改数据 go func() { i := 0 for i &lt; 1000 { m[\"age\"] = i i++ } }() // 启动协程对map 修改数据 go func() { i := 0 for i &lt; 1000 { m[\"age\"] = 100001 i++ } }() time.Sleep(time.Second * 3) fmt.Println(m)} 运行时出现错误fatal error: concurrent map writes: 123456789101112131415161718192021➜ task_test go run main.gofatal error: concurrent map writesgoroutine 19 [running]:runtime.throw({0x10a49a0, 0x0}) /usr/local/Cellar/go/1.17.6/libexec/src/runtime/panic.go:1198 +0x71 fp=0xc000052f38 sp=0xc000052f08 pc=0x102f691runtime.mapassign_faststr(0x0, 0x0, {0x10a1edc, 0x3}) /usr/local/Cellar/go/1.17.6/libexec/src/runtime/map_faststr.go:211 +0x39c fp=0xc000052fa0 sp=0xc000052f38 pc=0x100ff3cmain.main.func2() /Users/chenming/Work/Code/Go/task_test/main.go:24 +0x3f fp=0xc000052fe0 sp=0xc000052fa0 pc=0x108a4ffruntime.goexit() /usr/local/Cellar/go/1.17.6/libexec/src/runtime/asm_amd64.s:1581 +0x1 fp=0xc000052fe8 sp=0xc000052fe0 pc=0x105b421created by main.main /Users/Work/Code/Go/task_test/main.go:21 +0xc8goroutine 1 [sleep]:time.Sleep(0xb2d05e00) /usr/local/Cellar/go/1.17.6/libexec/src/runtime/time.go:193 +0x12emain.main() /Users/Work/Code/Go/task_test/main.go:29 +0xd2exit status 2 这就代表出现了冲突, 对于普通的 map 来讲, 如果有多个协程对同一个 map 进行修改, 就会出现错误. 于是 go 提供了sync.map, 我们在面对有多个协程对一个 map 进行处理的时候, 必须要使用sync.map, 当然, 不过如果不涉及到多协程处理, 还是使用普通的 map, 因为普通的 map 比sync.map效率更高 sync.map 优点 sync.map的主要思路是读写分离, 使用空间换时间, 相比自己使用锁来实现, 有一定的优化 Demo 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"sync\" \"time\")func main() { smap := sync.Map{} // sync.Map smap.Store(\"age\", 10) // 添加 key/value // 协程 go func() { i := 0 for i &lt; 1000 { smap.Store(\"one\", i) // smap 修改数据, key 不存在是新增 i++ } }() // 协程 go func() { i := 0 for i &lt; 1000 { smap.Store(\"one\", 1001) // smap 修改数据, key 不存在是新增 i++ } }() time.Sleep(time.Second * 2) fmt.Println(smap.Load(\"one\")) // 查看 key one 数据} 这时候就不会报错 数据结构 123456type Map struct { mu Mutex // 如果有脏数据操作时, 使用这个互斥锁 read atomic.Value // 只读的数据, 保存了一部分键值对, 只读并不需要加锁 dirty map[interface{}]*entry // 保存了一部分键值对, 对这部分操作需要获取互斥锁 misses int // 计数器, 记录获取 read 数据时不存在的次数} 这里的mu是互斥锁, 目的是保护read和dirty read是保存了只读的数据, 其中的数据操作是 go 内部的进行操作, 具有原子性 read的数据结构如下 1234type readOnly struct { m map[interface{}]*entry // 包含所有的只读键值对 amended bool // 标志位, 为 true 则代表 read 的数据并不完整} readOnly 作为只读 map 存在, 这个 map 的元素增加是由 dirty 中迁移过来的, 由 go 来进行数据控制, 不需要加锁 dirty是非线程安全的原始 map, 其中存储了新写入的数据, 和read中所有未被删除的数据 dirty的数据结构如下(dirty与read.map都是) 123type entry struct { p unsafe.Pointer // p 保存了数据的指针} 这里的 p 有三种可能 nil: entry已经被删除, 并且 m.dirty 为 nil expunged: entry已经被删除了, 并且 m.dirty 不为 nil 其他: entry是正常值 流程 Store store 是更新数据, key 已经存在则更新 value, 不存在则插入 1smap.Store(\"one\", i) // 给 smap 更新 key 为 one 的值为 i store 流程如下: 如果在 read 里能够找到待存储的 key，并且对应的 entry 的 p 值不为 expunged，也就是没被删除时，直接更新对应的 entry 即可。 第一步没有成功：要么 read 中没有这个 key，要么 key 被标记为删除。则先加锁，再进行后续的操作。 再次在 read 中查找是否存在这个 key，也就是 double check 一下，这也是 lock-free 编程里的常见套路。如果 read 中存在该 key，但 p == expunged，说明 m.dirty != nil 并且 m.dirty 中不存在该 key 值 此时: a. 将 p 的状态由 expunged 更改为 nil；b. dirty map 插入 key。然后，直接更新对应的 value。 如果 read 中没有此 key，那就查看 dirty 中是否有此 key，如果有，则直接更新对应的 value，这时 read 中还是没有此 key。 最后一步，如果 read 和 dirty 中都不存在该 key，则：a. 如果 dirty 为空，则需要创建 dirty，并从 read 中拷贝未被删除的元素；b. 更新 amended 字段，标识 dirty map 中存在 read map 中没有的 key；c. 将 k-v 写入 dirty map 中，read.m 不变。最后，更新此 key 对应的 value。 简单来讲, 就是在插入的时候, 去read中查看key 是否存在, 如果已经存在则直接更新read中的 value, 如果不存在则先上锁, 然后新增到dirty中, 不写入到read中 Load load 是获取 map 中的值 12345v, ok := smap.Load(\"one\") // 获取 key 为 one 的值if !ok { fmt.Println(\"key 不存在\") // key 并不存在}fmt.Println(v) // value 处理路径分为 fast path 和 slow path，整体流程如下： 首先是 fast path，直接在 read 中找，如果找到了直接调用 entry 的 load 方法，取出其中的值。 如果 read 中没有这个 key，且 amended 为 fase，说明 dirty 为空，那直接返回 空和 false。 如果 read 中没有这个 key，且 amended 为 true，说明 dirty 中可能存在我们要找的 key。当然要先上锁，再尝试去 dirty 中查找。在这之前，仍然有一个 double check 的操作。若还是没有在 read 中找到，那么就从 dirty 中找。不管 dirty 中有没有找到，都要\"记一笔(misses+1)\"，因为在 dirty 被提升为 read 之前，都会进入这条路径 简单来讲, 就是在获取值时, 先在read中查找, 有就直接返回, 没有则加锁后去dirty中查找, 同时将 misses+1, 如果 misses 大于或等于dirty的长度, 就将dirty变成read, 然后建立新的空的dirty,同时misses设置为0 Delete Delete 可以删除这个 map 中的 key 1smap.Delete(\"one\") // 从 smap 中删除 key one 都是先从 read 里查是否有这个 key，如果有则执行 entry.delete 方法，将 p 置为 nil，这样 read 和 dirty 都能看到这个变化。 如果没在 read 中找到这个 key，并且 dirty 不为空，那么就要操作 dirty 了，操作之前，还是要先上锁。然后进行 double check，如果仍然没有在 read 里找到此 key，则从 dirty 中删掉这个 key。但不是真正地从 dirty 中删除，而是更新 entry 的状态。 简单来讲, 就是先查找read中是否存在, 不存在则加锁后去dirty删除 LoadOrStore LoadOrStore 结合了 Load 和 Store 功能, 如果存在这个 key 就返回, 不存在则新增 具体过程简单来讲, 就是先read中查询, 有就返回, 无就去dirty查询, 有就返回, 无就插入 Range Range 作用是输出所有的 key 和 value, 用起来比较特殊, 需要自己传入一个处理函数 123456smap.Range(func(key, value interface{}) bool { name := key.(string) age := value.(int) fmt.Println(name, age) return true}) 只要 return true, 就会停止遍历 具体过程简单的说, 就是先加锁, 然后将dirty的数据提升到read, 然后遍历read中的数据 优点 sync.map是线程安全的 通过读写分离(read和dirty), 降低锁的使用次数, 提高速度, 适用于读多写少的场景","link":"/2022/02/12/go_sync_map_theory/"},{"title":"好的礼仪","text":"前言 这几天老妈的单位在搞线上培训, 要听课, 她自己不想看, 我就趁着周末在家用电脑给她挂一下, 课程包括了生产安全, 防疫知识, excel 操作, 社保 等视频, 最后一部分是讲怎样做好自己的礼仪, 看了两节觉得挺对的, 我个人觉得也是有必要简单的了解一下相关的知识, 所以这里简单的记录一下总结, 本身课就三个小时, 所以本篇内容不多 来源 这个课是截取的视频, 不知道来源, 讲解人是 逯瑶 (bjwbh.cn), 简历看起来很厉害 什么是礼仪 尊重, 适合 礼仪是让人得到尊重, 礼仪需要适合自己和对方, 而不是刻意的去装 礼仪不是用来装的, 而是去用的 孔子的论语中有说 恭而无礼则劳，慎而无礼则葸，勇而无礼则乱，直而无礼则绞, 强调了礼仪需要掌握对的方法, 否则会适得其反 作者认为 人生就是一场成交, 人生无处不成交, 这里的成交并不是指的双方进行交易, 而是广义的成交, 指双方达成了共识. 婴儿在生下来之后第一件事就是哭, 目的是找到其母亲, 告诉她我很健康, 这就是人生的第一场成交 如果一个人, 周围人给他的评价都是好的, 正面的, 说明这个人有很强的成交能力, 这就是成功的, 所以, 学习礼仪是让双方达成协议, 促成成交 学好礼仪, 可以加强个人品牌的塑造和营销 五感开关 要想成交, 必须要先给对方留下印象, 人每天会做很多事情, 大脑会抛弃掉大部分记忆, 为什么有些记忆是很深刻的呢? 在脑白金疯狂打广告的时候, 相信经历过的人都对其印象深刻, 甚至现在还忘不了. 这是一个成功的营销, 成功的让用户记住了自己. 人的脑袋分为左右, 左脑是理性脑, 存放浅层的记忆. 右脑是感性脑, 存放深度的记忆. 当某件事情被分到左脑存放时, 多半是不会被记住的. 举个例子, 一个销售面对客户推销商品. 当销售一直在说话, 而客户很少说话的时候, 一般成功率都不高, 因为销售的话已经被客户放到了左脑进行处理. 同样的, 为什么很多人不听老妈的唠叨, 也是因为是\"唠叨\", 被放进了左脑 想要放到右脑中, 需要打开右脑的\"开关\", 有那些呢? 视觉, 听觉, 嗅觉, 味觉, 触觉. 我们现在想到脑白金, 脑子里会有一个老头一个老太在扭动, 同时\"今年过节不收礼, 收礼只收脑白金\"也出现在脑子里, 这就是视觉和听觉, 一般的对某一件事情印象深刻, 必定是多于其中某一个开关的. 可以回顾一下最近发生的事情记得清楚的是不是这样. 按照占用比例来进行区分的话, 视觉语言占了 55%, 声音表情占了 38%, 文字语言只占 7%. 文字语言 文字是需要通过介质去传播的, 可能是声音, 可能是纸, 可能是微信. 文字语言实际上是很重要的, 是核心部分, 直接体现了你的态度, 逻辑思维等等, 他是起到了画龙点睛的作用, 但是光有文字语言也是不行的, 刚才也说了, 文字语言需要通过介质去传播, 那么剩下的93%就是你需要通过介质去将你的语言, 你的思想表达出来. 作者举了例子, 当你听到你发出去的语音微信, 或者录音的时候, 会惊讶自己的声音怎么与自己设想的不一致, 这是因为你的发声没有受到过专业的训练 同样的一句话, 或者说几个字, 配合发声人的表情, 语调等就会有不同的表现, 同样是几个字 你怎么回来了, 可以表现出 失望/ 惊讶/ 惊喜/ 发怒 等心理, 这是因为你的心理通过 表情/ 动作/ 语调 等介质散发出来的. 视觉语言 有些人, 你与他沟通时, 会觉得他有一种 气场, 这就是通过视觉语言表达的. 视觉语言有三种类型, 仪容/ 仪表/ 仪态 仪容是指的身体所有露出来自己原生态的地方, 比如 头发, 眼睛, 鼻子 等 仪表指的是盖住身体的所有非原生态的地方, 比如 眼镜, 手表, 上衣 等 仪态指的是所有会动的, 比如 走, 跑, 蹲, 笑 作者认为这三个最重要的往往是 仪态, 因为你想表达思想, 最直接的就是仪态 而要提高自己的仪态, 一定记得需要提高自己的意识, 因为 意识决定行动, 行动决定结果 我们需要有 恭敬心, 比如去拜佛的地方, 大家都很安静(除了特别的人), 有很好的氛围, 那为什么大家都不由自主的维持秩序呢? 因为对这里有 恭敬心, 那其实我们应该对万事万物有恭敬心, 而不是在特定的地方. 比如在公共场合, 不抽烟, 垃圾不要随地扔, 这其实就是礼仪, 就是你对有些东西心存恭敬, 为什么垃圾不随地扔, 因为你知道清洁工们很辛苦, 对他心存恭敬, 这是很好的事情, 我们常说 德行, 人有道德, 就会通过行为来释放, 就会让自己的仪态变得更好, 修身齐家治国平天下, 修身是在最前面的, 随后是自己的小家, 后来才是对社会有贡献. 微表情/微动作 掌控我们的微表情, 这属于仪态的一部分, 如何面对有气场的人? 眼睛 首先是眼睛, 眼睛是心灵的窗户, 我们很少与人对视, 而对于有气场的人, 你更难与他对视, 会不知不觉的别开眼睛, 这时候就代表你示弱了. 主要是让我们有了压迫感, 怎么来减轻压迫感呢? 我们可以交谈时盯着他们的小三角区看, 小三角区指的是 两只眼睛与鼻梁 连接形成的倒三角, 这样会缓解一些压力, 提升自己的气场. 同时要注意, 不要频繁的, 或者动作幅度过大的, 将视线离开 大三角区, 大三角区指的是, 头顶到两肩形成的三角形, 尤其是与异性交谈的时候, 如果不遵守, 很可能让对方觉得你有别的想法. 眼睛向下与别人说话, 会让人觉得 轻蔑, 动机不纯 向上让人觉得是 若有所思, 不自信 所以面对领导或者客户时, 千万要记住 而向左右时会让人觉得 不被尊重, 没有关注对方 手 手部动作也是非常重要的, 同样说一句话, 当你说话时竖起大拇指, 就让人觉得是在夸赞, 而竖起食指则让人觉得在指责 在交流时, 食指代表 指责, 挑衅和距离感 在交流时, 掌心对着人代表 高高在上和距离 在交流时, 抱着收代表高傲 我们发现领导在开会坐下时, 有些喜欢叉手抱胸, 这是因为人体有三把锁, 眉锁, 手锁, 脚锁, 这种被称为 封闭式姿势 眉锁往往让人觉得在为事情发愁, 有些人会在思考问题时皱着眉头, 这是不好的, 会让人觉得 形象不佳, 心事重 上手锁(叉手抱胸)则让人感觉不满意, 高高在上, 锁脚同样这样 在心理学中, 手代表对人的认可程度, 脚代表对事情的认可程度. 而一只手横着胸前, 一只手竖着, 这就代表正在思考问题, 正在纠结. 当一对多讲话时, 手放在肚子上, 就代表不自信和紧张 个人修为(修养)越高, 坐着越四平八稳, 没有过多的动作 向人递交资料的时候. 需要注意: 双手递送 书本上的字朝向对方 眼睛要盯着对方的小三角, 对方拿到后再移开 向人递送笔时, 需要注意: 拔下笔帽(如有) 笔尖朝向自己 眼睛盯着对方小三角 如果需要对方签字, 同时注意要解释和指导对方在哪里签, 手指向签字的地方, 注意大拇指收起来, 隐藏在手掌中. 握手 握手是非常重要的, 怎么样握手 距离一米之内, 与别人保持一样的站姿或者坐姿 力量均当或者稍稍用力, 代表热情 两者之间不要有桌子或者椅子的阻隔 如果两者之间隔了一个人, 要先与这个人打招呼握手, 然后再与他打招呼握手 和他打招呼要考虑其他人的感受 与对方握手不要是\"空心\"的, 就是你和对方的手掌心直接是空的, 这叫留一手, 应该与对方贴合 握手时颠两下, 同时打招呼 握手时另一只手不要插兜或者背后面, 自然垂下即可 一般的, 被尊敬者先伸手, 当拜访时, 是主人先伸手, 离开时, 客人先伸手 职场中领导先伸手 社交时, 女性先伸手 正确坐姿 在交流时. 把肘关节到手指的 2/3 放到桌面上, 显得有亲和力 身体微微前倾 坐下时, 屁股越靠前越显得谦恭, 越靠后越自信 如果要靠后坐, 直接靠到背靠上, 注意不要尾椎骨和椅子直接有空隙, 显得吊儿郎当且对身体不好 男生坐着不要两腿并直合在一起, 显得阴气重 男生两腿分开, 但是不要宽过肩膀 可以一个脚在前一个在后, 不要距离太远, 不要靠在一起(脚锁) 不要出现脚锁, 显得隔阂 餐桌座次 主一: 宴请方 主二: 陪同方, 处理琐事的 按照圆桌举例, 一般主一坐在正对门, 最里面, 主二坐在门口, 背对门, 方便交际 客一坐在主一右手边第一个, 客二坐左手边第一个这样排序 站姿男 抬头, 挺胸, 收腹, 收下巴 大拇指永远不要插进另一只手 方案1 手放两侧, 手开放式 方案2 庄重站姿 仪式感强, 但是显得有距离感 右手半握, 左手搭右手手腕 左手大拇指不要单独张开, 张开显得张扬 左手大拇指不要握着手腕, 握住显得不自信 当可以放松的时候(认识之后), 可双手搭在一起了, 显得放松, 拉近距离 招手 肘关节在肩以上, 显得热情开放, 休闲自由 肘关节在肩膀和肚脐之间, 显得沉稳大气, 优雅端庄 仪容(男) 手指甲不要长, 显得阴气重 头发前不遮眉, 侧不盖耳, 后不及领, 不要夸张","link":"/2021/09/04/good_etiquette/"},{"title":"记一次goroutine与wg一起使用导致的问题","text":"Send Closed Chan 问题概述 代码逻辑是启动时启动多个 channel, channel1 获取数据监听数据处理后发送给 channel2 , channel2 处理后再给 channel3 等等 在 channel1 写完数据后将通道 channel1 关闭, channel1 关闭后 channel2 也关闭, 达到任务执行完毕后通道全部关闭的效果 我之前的代码是 12345678910111213141516171819func StartVerify() { wg := sync.WaitGroup{} for { data, ok := &lt;-TypicalResChan if !ok { wg.Wait() close(VerifyBossDNSChan) break } go func() { wg.Add(1) ok := Verify(data) if ok { VerifyBossDNSChan &lt;- data } wg.Done() }() }} 后来使用中发现有时候会报 send closed channel 的错误,大佬看了一眼就发现了问题 问题剖析 就以上面的举例, 上游向 TypicalResChan 发送数据时, 如果不是 close 请求, 会启动一个 goroutine 去处理逻辑, 而在 启动这个 goroutine 后在内部进行 wg 的 Add 注册, 注意这个过程是有耗时的, 所以问题来了, 当上游向 TypicalResChan 发送 close 时, 进入 !ok 的逻辑, 此时等待 wg 释放, 此时有可能上一个数据接收到后还在启动一个 goroutine ,还没有 Add注册, 此时wg没有监听到这个 goroutine 的注册, 造成不会等待这个 goroutine ,直接就关闭了 TypicalResChan, 而这个 goroutine 执行后向 TypicalResChan 发送数据时 TypicalResChan 已经关闭, 所以会报错导致 panic 另外, 还需要注意的是在 wg 没有注册前就 wait 是不推荐的, 很容易出现问题 还有就是判断通道关闭更推荐使用 range 省去判断 !ok 的步骤保持代码整洁 问题解决 修改成这样即可 123456789101112131415func StartVerify() { wg := sync.WaitGroup{} for data := range TypicalResChan { wg.Add(1) go func(data Result) { defer wg.Done() ok := Verify(data) if ok { VerifyBossDNSChan &lt;- data } }(data) } wg.Wait() close(VerifyBossDNSChan)} 在上游 close 时 range 会自动结束, 而受到正常数据先 Add 防止时间差导致的 Add 失败问题, 在 1.14 后 go 优化了 defer 的逻辑, defer 基本不再有消耗, 所以推荐使用 defer 注册 wg 的关闭, 而在 close 时, for 循环结束, wg 在 wait 后再 close","link":"/2021/09/04/gorouting_and_wg/"},{"title":"为什么gRPC使用HTTP2而不是WebSocket","text":"在跟同事聊天(摸鱼)的时候, 谈到gRPC使用HTTP2的好处, 然后同事抛出来一个问题, 为什么不使用websocket, 于是在我查找了相关资料后有了这一篇博客 什么是RPC 本文的主要目的不是讲什么是RPC, 什么是gRPC, 但还是稍微带一点(怎么可能是为了凑字数😗) RPC其实就是**远程过程调用(Remote Procedure Call)**的缩写, 是属于计算机通信协议的一种. 其实从名字也能看出来, 就是在一台计算机的程序去调用另一个地址空间(可能是本机的不同虚拟空间, 也可能是不同计算机)的程序, 而作为开发者来讲, 无需关注这部分细节. RPC是一种 服务端-客户端(Client/Server)模式, 通过客户端发送请求到接受回应这个过程来进行信息交互. 因为是调用另一个地址空间的程序, 所以需要进行信息的传递和发送接收, 抽象出来流程大致如下 123客户端: 本地调用 --&gt; 参数封装 --&gt; 发送调用信息服务端: 接收调用信息 --&gt; 解除封装 --&gt; 调用本地服务 --&gt; 获取结果 --&gt; 封装结果 --&gt; 发送结果客户端: 接收结果 --&gt; 解除封装 --&gt; 本地返回结果 因为是跨空间调用, 为了保证运行正常, 肯定要约定好内容的格式/规范, 就跟你让别人帮忙买彩票, 对面是个不懂汉语的外国人, 他就不知道你想要他干嘛, 就会导致无法正确执行下去. 这里面可分为两部分 内容组织约定: 分为调用语法和内容解压缩两个部分, 比如我要调用你的哪个功能, 给你的信息是怎样的结构等 网络传输: 涉及到真正的互联网传输, 就比较复杂了, 怎么区分二进制的哪一部分是RPC调用, 哪一部分是消息体, 这些解析都要通过协议去实现和约束. 怎样去传输信息, 就比如ONC RPC, RESTFULL HTTP JSON, gRPC 等等 wiki: 远程过程调用 - 维基百科，自由的百科全书 (wikipedia.org) 什么是gRPC gRPC也是RPC的一种, 是google使用C++开发的一款跨语言, 二进制编码的数据序列化协议, 他有几个显著特点 gRPC使用 protobuf 来进行数据的编码与内容的定义, 数据压缩率很高, 直接提高了传输的效率. gRPC使用 HTTP2 进行网络传输 gRPC的爸爸是google, 所以他有很好的 社区支持, 版本迭代, 生态, 插件 等等 gRPC官网: gRPC protobuf: protocolbuffers/protobuf: Protocol Buffers - Google’s data interchange format (github.com) HTTP2是什么 HTTP2是2015年IESG批准的新的HTTP协议, 使用了类似SPDY协议的方案. HTTP2的优点(相比1.1)有: 真正的多路复用: 虽然1.1中就有了keep_alive, 但是本质上只是保持不断TCP链接, 而并发时还会申请多个keep_alive, 导致资源损耗, 而且当keep_alive链接存在的数量超过限值时, 其他的新请求就会阻塞直到空出位置, 而2则是真正的多路复用, 将指向同一个域名的请求都由一个TCP链接发送, 防止资源损耗 HTTP2传输数据使用的是二进制数据, 因此可以通过数据封装(二进制帧)来实现多个请求通过同一个链接发送和接收, 也就实现了多路复用 HTTP2协议中针对每个请求, 可以放置优先值, 双方可以通过优先值来决定不同的处理策略. 服务器主动推送: 服务端可以主动推送给客户端数据, 而不是被动的返回数据 更小的数据: 因为是二进制数据, 所以使用压缩算法(HPACK)可以减少数据的大小 wiki: HTTP/2 - 维基百科，自由的百科全书 (wikipedia.org) 为什么使用HTTP2 看过上面, 可能你的脑中就有了模糊的答案, 我们再翻翻gRPC的最早一篇博客gRPC 的动机和设计原则 | gRPC, 里面记录了gRPC的设计原则, 大致如下: 服务不是对象, 消息不是引用: 微服务的概念 覆盖广和简单性: gRPC需要在每个流行的平台上可以使用, 而且足够简单的使用, 没有很高的硬件要求 免费开放: 所有人免费使用基本的功能 互操作性和范围: 必须能在常见的互联网基础设施上运行 通用和高性能: 应适用于广泛的用例, 同时不会牺牲性能 分层: 代码分层, 版本迭代不影响基础使用 多种数据类型: 不同的服务需要使用不同的消息类型和编码，如协议缓冲区、JSON、XML和Thrift；协议和实现必须允许这样做。同样，对有效载荷压缩的需求也因用例和有效载荷类型而异：协议应允许可插拔的压缩机制。 同步和异步: 同时支持异步和同步处理客户端和服务器交换的消息序列。这对于在某些平台上扩展和处理流是至关重要的。 取消和超时: 取消允许服务器在客户行为良好时回收资源。当跟踪因果链时，取消可能会级联。客户端可能指示呼叫超时，这允许服务根据客户的需求调整其行为. 限流: 在必要时可以对请求进行限流 等等… 我们发现, HTTP2 符合 gRPC 的要求: 覆盖广: 在标准推出后, HTTP2 就被主流浏览器和网关等支持, 最小可用的硬件标准十分的低, 手机端/电脑端/服务器端/iot端 受网络的推动, HTTP2发展普及很快 简单性: 大量的网络框架和组件/网关等支持简单的开启HTTP2, 开发者无需关注更底层的socket处理, 专心业务. 免费开放: 是开放的标准, 任何人都可以使用 天然支持物联网/手机/浏览器: 互联网推动 高性能: 相比1.1有长足的进步 流控: HTTP2维持一个TCP连接, 所以对流控制比较简单 安全性: 天然支持SSL 鉴权成熟: 从HTTP1发展出的鉴权系统很完善, 可以使用到2上 当然, 与人无完人一样, HTTP2也有其缺点: 传输还不够高效: 虽然有HPACK, 但是对于RPC来讲, 还可以更加的简单快速, 比如将某个功能标记为一个int数字, 客户端直接传入数字即可标识调用服务端的哪个功能 gRPC使用HTTP2需要解码两次, 一次是HEADERS一次是DATA HTTP2标准是本身只有一个TCP, 但是其实gRPC的实现会有多个TCP 在速度上, 有更加快速的协议, 但是综合考虑后还是HTTP2更加适合, 相信很多书都会强调一个观点适合的才是最好的 为什么不使用websocket websocket看似也是流式传输, 也可以做到一个websocket传输所有信息, 为什么不选择websocket? stackOverflow有一个提问类似: http2 - Does HTTP/2 make websockets obsolete? - Stack Overflow 其实还是适不适合的问题, websocket和HTTP2是有所不同的, HTTP2的推出也不是为了替代或者超越websocket, 他们是不同的作用领域, 相比于websocket, HTTP2在通用性上更加适合gRPC Will WebSocket survive HTTP/2? (infoq.com) 适合的才是最好的","link":"/2021/09/05/grpc_use_http2/"},{"title":"自卑与超越 (1)","text":"书籍信息 书名: 自卑与超越 作者: 阿尔弗雷德.阿德勒 出版: 中国妇女出版社 作者生平 作者真的是很传奇的人物, 你也可以自行百度, 这里简述一下 作者 阿尔弗雷德.阿德勒 是奥地利人, 出生于商人家庭, 生活富裕, 家人爱好广泛, 但是作者的哥哥很优秀, 活泼好动, 惹人疼爱. 让作者感到自卑, 认为自己又矮又丑. 但是他友善又随和, 他的父亲宠爱阿德勒, 常常鼓励他 阿德勒, 你不能害怕任何事情, 鼓励阿德勒. 阿德勒从小患有脊柱炎, 导致身体虚弱, 行动缓慢, 在他三岁时他的弟弟在他身边去世, 他小时候被车撞过两次, 导致她对死亡特别恐惧, 5岁时又得了肺炎, 在痊愈后, 他决定当一名医生来帮助他人. 他的妻子是一位俄国人, 比较独立, 而阿德勒相对保守, 所以两人生活并不和谐, 但是还是走到了最后 因为阿德勒待人友善, 不拘小节, 所以朋友很多, 所以认识了弗洛伊德, 是另一位心理学家, 从此进入了心理学 阿德勒的观点是, 由身体缺陷或者其他原因导致的自卑, 不仅可以摧毁一个人, 还能让其自甘堕落或引发疾病. 但是合理的看待, 就可以让自己奋发图强, 积极进取, 弥补缺点, 走向成功 同时, 他认为人类都有一种强烈的愿望, 希望自己变得强大 还认为儿童天生具有自卑感, 因为他们身体弱小, 当儿童利用自卑感逃避生活时, 就会出现神经问题. 自卑不是心理变态, 而是在追求优越时的正常表现. 阿德勒创建了个体心理学, 认为人类的行为都是出于自卑感以及对自卑的克服和超越 第一章: 生活的意义 现实生活是具有意义的, 人在生活中, 并不是单纯的体验环境, 而是以他们对人类的意义去评判事物 如果有人排除事物的意义而只去关注环境, 就会孤立自己, 脱离人类. 人类的存在无法脱离生活的现实, 自我封闭毫无意义 当人遇到挫折时, 总是会问: 人的意义是什么? 活着是为了什么? , 对于这种问题, 其实每个人都有自己的理解和答案, 这个答案不需要口述, 从这个人的言行举止就可以看出来. 你的性格决定了你的态度和生活的观点, 而性格是自己养成的, 是自己对事物的理解. 所以, 对人生意义的理解多少会包含谬误, 但是每个人的理解都不一样, 没有人是真理, 因此不能说谁谁的理解是绝对错误的, 因为对个人而言都是相对正确的, 但是要注意, 只要坚持普遍的标准, 那么我们就能得到科学的理解, 得到相对于人类而言正确的意义. 人生总要面对的三个大的问题, 所有问题都绕不开这三个终极问题 人类的活动范围是有限的, 现阶段人只能生活在地球表面, 生活范围是有限的, 同时又心存希望, 人必须发展才能生存下去, 才能延续. 这是每个人逃不开的问题, 每个人都是人类这个群体的一份子, 人类其实很脆弱, 所以为了生存, 人会去努力强化自身 每个人都是无法独立生存的, 人类是一个整体, 一个人无法存活, 只能走向灭亡, 单独人无法完成目标, 也无法延续生命, 因此人总是需要合作, 我们和他人是互相联系的, 为了生存, 我们必须合作, 所以我们需要让自己的感情与与他人合作相适应 人类有男有女, 这是人类延续必须面对的问题, 无论是谁, 无论男女, 一生中都无法绕开爱和婚姻这个问题, 而每个人在面对这些问题时的选择不同, 他们的选择就是对这个问题的答案. 他们的行动就是他们认为的最佳的解决方法 这三个问题引申出三个问题: 怎样在地球自然环境的限制下生存 在人海中, 如何给自己定位, 相互协助, 发展共赢 如何进行自我调节, 适应两种性别和人类的延续依赖于两性关系的事实 个体心理学将人的所有问题归为三大类: 职业, 交际, 两性 每个人对这三个问题的不同回答精准的揭示了每个人对生活意义的理解. 比如说有一个人, 他缺乏爱情, 在工作中不积极, 不喜欢交朋友, 认为人际交往是令人痛苦的, 这样会我们会认为他成功的几率不高, 他认为: 生命的意义就是让自己免受伤害, 把自己封闭来保证自己的安全 另一个人, 爱情美满, 交际广泛, 朋友多, 善于协作, 工作有成, 那么这个人就是善于成功的, 他认为声明的意义就是懂得发现别人的价值, 让自己发光发热, 为社会做贡献 对人生的意义的理解, 无论是正确还是错误, 都有一定的共同性: 精神病,罪犯,酗酒者,问题少年等失败者, 之所以失败, 是因为缺少友情, 对社会冷漠, 在处理问题时, 对合作缺乏信心, 不寻求他人的帮助, 认为人生是以自我为中心, 他人无法分享自己的成功, 这种心态, 就算取得了自我认为的成功, 实际上也只是虚无的优越感, 这种成功只有对自己才是有意义的, 对他人完全没有意义. 自我意义是没有任何意义的, 真正的意义是与人交往中体现出来的, 同样的, 我们的目的和行为也是这样. 我们每个人都为成功而奋斗, 但是如果不明白成功是建立在为他人做贡献的基础上, 那么就会出现错误, 而且, 自我意义是无法得到别人的认同的, 也就是禁不起实践的检验 真正的人生意义是具有普遍性的, 就是可以与他人共享, 并且大多数人可以接受. 我们可以发现, 在生活中, 对于某个问题好的解决方法同样适用于他人, 当我们将某个人称为 天才/伟人的时候, 必定是这个人对社会有贡献, 对社会有益. 所以, 人生的意义是 对整体作出贡献. 他们都是珍爱他人并且善于合作的人, 即使遇到困难也不会损害他人的利益 可能有人会问, 如果人生的意义在于贡献,关爱和合作, 如果我总是以别人利益为重, 那我自己呢? 我自己的利益谁来保证呢? 谁来回报我呢? 这样的观点是错误的, 因为只有为别人考虑, 为别人做贡献, 才会体现出自己的价值, 同时会提高自己的能力. 因为若要实现目标, 必定会提升自己, 进行实践. 举个例子, 在爱情和婚姻中, 如果我们想要让对方感受到辛福和快乐, 肯定会提升自己, 让自己变得更好, 同时尊重对方, 为对方奉献. 如果自我独立, 只会让自己变得盛气凌人, 令人生厌. 再进一步, 我们还会发现, 人生的真谛在于奉献, 我们可以发现, 所谓的遗产, 就是前人留下的东西, 其中被称赞的遗产, 必定是对他人有好处的, 这些前人就是在奉献. 他们都领悟到了人生意义, 反之, 有些人逝去时什么都没有留下, 这种在历史上没有丝毫痕迹, 就像风一样逝去了. 但凡被大众认可的宗教, 无一例外也是推崇为人类做贡献的, 都推崇普渡众生的思想. 在人一出生的时候就开始了对人类意义的探索. 在小时候, 人对社会没有经验, 不知道人生意义. 但是需要知道的是, 在到我们5岁的时候, 其实我们的行为模式已经养成了, 这样会导致我们已经有了自己的方式去了解人生意义, 这样就可能出现一个问题, 如果我们已经养成了错误的习惯, 就会导致我们可能会通过错误的方法得到错误的人生意义. 但是这并不代表已经无药可救, 只是说如果已经得出了错误的人生意义, 即使他们因此遭受了不幸和痛苦, 也很难去改变, 但是如果你重新思考, 并对自己的认知加以修正, 就会改变现状. 探寻到真正的人生意义, 让自己走的更远. 有人的童年是不快乐的, 痛苦的, 但是会出现两种结果, 一种是千方百计的摆脱困境. 在他的心中, 会有这样的想法: “我一定要努力加油, 改善自己, 让我的孩子不像我一样” 反之则会自甘堕落. “老天爷对我真残忍, 所以我为什么要对别人好呢?” 还有一种则是走向极端, “我童年就这个样, 所以我见不得别人好, 我吃的苦很多, 所以我做什么都是情有可原的” 由此可见, 对人生意义的理解是与个人的行为绑定的, 如果不改变思想, 行为是不会改变的. 每个人的经历并不能决定人生的成败, 但是会对其命运造成影响. 环境并不能决定我们对人生的理解, 单身我们可以通过解读人生境遇来改变自己 成年人中的失败者, 很大部分是因为小时候就没有对人生意义有正确的理解, 并且一直受其影响, 他们无法意识到人生的意义就是为社会做贡献, 除非有人引导, 否则会一直的以自我为中心. 这本来会导致变得自傲, 然而因为小孩子没有安全感, 反而会变得自卑, 因为被排挤变得内向, 认为自己不会对社会造成任何贡献. 而对于身体不健康的孩子也是这样, 但是我们也能够看到, 那些有困难的孩子在克服困难的同事, 也会激发自己巨大的潜能 有不少杰出人才身体上有缺陷, 甚至因此英年早逝, 但是他们留下的贡献是巨大的, 但是这总归是少数, 更多的缺陷者因为没有正确的引导, 变得越来越自卑, 抵触与外界接触. 以自我为中心, 这也让我们明白, 他们因为过度的关注自己的缺陷, 让自己产生了无形的压力. 同时家长对孩子的溺爱也会导致人生意义的曲解, 他们会认为他们的愿望就是法律, 因为他们总能被满足, 而不需要自己付出. 但是当他长大后, 发现他不再是人群中的焦点, 便会不知所措, 觉得别人对他有所亏欠, 同时, 之前习惯了索取而不付出, 导致没有自立的能力, 不知道自己能做该做什么. 不懂的与人相处, 寻求合作. 而是在遇到困难的时候直接求助别人. 被过分的宠爱的小孩子很可能会在长大后变成危险人群, 如果让他们与别人合作, 他会觉得不满, 甚至会恶意的捣毁这件事情, 如果他们得不到别人的呵护和关心, 便会认为他人在背后使坏. 导致与很多人为敌, 如果别人不赞同他的行为方式, 便认为这是欺辱, 这样会导致与周围人都是敌对的. 受人冷落的儿童同样会出现问题, 因为他们不会与别人合作, 不懂得关心, 当他们遇到困难, 就会不愿意求助他人, 导致失败, 同时在看到社会冷漠的一面时, 就会认为社会一贯如此, 他们会怀疑别人, 同时无法相信自己 在小孩子出生后, 母亲的最初任务就是让孩子一出生就感觉到对自己的依赖, 然后帮助孩子慢慢的将这种依赖的范围扩大, 直到周围的环境, 如果不这样, 不让孩子对周围一切感到兴趣, 很可能就会让孩子对社会不感兴趣, 不善于合作. 我们发现, 对于不受重视, 总是孤独的孩子, 通常缺乏对人的依赖感, 也不会与人合作, 导致失败. 上面的说明, 证明了, 对于孩子来讲, 过于被溺爱, 身体残缺, 被忽视, 都会导致心理出现问题. 人在睡梦中压力很小, 所以在梦中性格会毫不犹豫的表现出来, 学会解析梦境很重要, 因为梦中的事情总是最真实的你所做的事情, 梦其实是在告诉你, 看, 这就是你得到的结果 儿童早期的记忆对我们的生活有直接的影响, 因为这是我们对自己和周围环境的最初印象. 也是我们主观印象的开始. 对人生观的建立有重要影响. 性格是可以被改变的, 我们可以通过培养自己的勇气和乐于合作的精神来改善孩子错误的人生观 要培养他们的合作精神, 因为孩子在受宠时总是变得自私与自大, 当他们长大后, 该缺点会愈发的放大, 我们需要让他们知道. 术业有专攻, 没有一个人是全知全能的, 复杂的事情通过合作会有更好的结果. 我们必须要有自己的人生, 这是我们的事情, 我们应该感觉到做起来得心应手, 我们是独立自主的, 我们自强不息, 应当有推陈出新的义务","link":"/2022/09/04/inferiority_and_transcendence(1)/"},{"title":"逻辑学入门(45-66)","text":"书籍信息 书名: 逻辑学入门 作者: 格桑 出版: 中国纺织出版社 正文 结构歧义 今天有两个报社的记者参加了活动 逻辑学上, 由于语句中的语法结构具有不确定性导致判断产生的歧义叫做结构歧义 比如上面的语句, 有可能理解为一个报社的两个记者参加了活动, 也可能理解为两个报社的多个记者参加了活动, 这种就是表述者犯了结构歧义的错误 要消除歧义, 最好的办法就是重新组织表述的结构 隐含命题 听话听声, 锣鼓听音 即听人说话的时候, 为了准确把握对方的思想, 听明白对方真正想表达的东西, 不能只听对方话语表面的意思, 因为对方可能在暗示什么 这种别人说的命题中, 隐藏着另一个命题, 被称为隐含命题 隐含命题是一只高明的, 非常实用的表达方式, 用好了的话, 即可以委婉的提出观点, 又不至于得罪人. 你们这的蚊子很聪明, 懂得提前来踩点, 方便晚上就餐 意思是蚊子很多 同构异悖 A: 你这样不会有好结果的, 说真话的话, 富人会怨恨你. 说假话, 穷人会指责你 B: 我会有好结果的, 说真话, 穷人会拥护我, 说假话, 富人会喜欢我 这种仿照对方的辩词的话语结构, 构建一个与对方话语结构完全相同, 表述意思却完全悖的观点, 以此来反驳对方的方式, 叫做同构异悖 大多数时候, 这种反制方式会取得比较好的成果, 往往令人无言以对 分解问题 在日常生活中, 我们一定要学会分解自己的问题, 这样可以让人更好的理解我们的问题; 也要学会分解他人的问题, 为的是减少答非所问的发生 如何更好的提问问题? 确定问题的方向 生活中最简单的疑问句, 莫过于5W+1H When 什么时候? Where 什么地点? What 什么情况? Who 什么人? Why 为什么? How 怎么? 提问时首先要确认你要问的是什么类型, 比如: 你周末去了什么地方? 你上午和什么人在一起? 你昨天为什么不来? 而不是: 你周末什么情况? 你上午怎么了? 你昨天在什么地方? 强调问题的目的 其实, 上面举出的错误例子, 也能从侧面问出来答案, 而正确的提问可以直接的强调你问问题的目的, 更具有目的性, 让对方知道你想要的答案, 让交流顺利的进行 一个问句的疑问词要少于三个 无论什么问题都有侧重点, 这就要求我们在提问时不能在一个问句中包含太多疑问词, 这样会导致回答者无法了解我们的目的 最好一个问句只有一个疑问词, 只问一个问题 你昨天没来上课, 和谁? 去了哪? 干了什么? 这样一句话有三个疑问词, 让人很难回答 在生活中我们要学会分解问题, 提高沟通的效率 虚假两分 这个人是好人还是坏人? 这件事是对是错? 在我们小的时候, 对很多事物没有充分的认知, 认为世界非黑即白, 非善即恶. 到大了才知道, 事情都是有两面性的, 不能像二极管一样去看待事物. 当你认为某件事情非黑即白的时候, 你可能就已经犯了虚假两分的谬误 虚假两分, 指把一个可能存在多个答案的事情, 假设成只有两个答案, 通常这两个答案还是两级反转的, 似乎世界上所有问题都只有两面 而当我们把结论限制在两个以内的时候, 我们的视野就会被限制, 思维会遭到严重的束缚 了解虚假两分的逻辑错误, 有助于我们用开放性的思维去思考问题, 特别是受挫的时候, 能够及时的提醒自己和他人, 还有第三种可能 这样的话就不会走向极端的思考误区, 也不会因为一次失败就彻底丧失自信, 否认自己的价值与努力 从表面上看, 遇到挫折一蹶不振, 是心态过于悲观. 实际上是陷入了虚假两分的逻辑陷阱. 稍加分析, 这是把人生错误的分为了两个极端, 一个是正极端, 一个是负极端, 不是这个就是那个, 没有其他的可能 遇到这种时候, 我们要牢记, 人生并不是只有两种可能, 他是未知的, 发散的, 有无限种可能, 每种都可能实现 我高考失败了, 我这辈子完了 高考失败了可以重新复读, 或者选择其他学校, 不是考不上人生就凉了 我失恋了, 我要单身一辈子了 失恋了可以再谈恋爱, 不是这次没谈好就一辈子单身 当我们意识到了多种可能性时, 我们就能从牛角尖中钻出来, 会发现人身其实不存在绝境, 处处都有转机 事实断言 在提问的过程中, 我们遇到的所有的推理论证, 几乎都涵盖了以下三方面内容 过去是什么样 现在是什么样 将来是什么样 这些看法形式不一, 有可能是假设, 有可能是理由, 也有可能是结论. 但是说话者的目的都是让你相信他的结论 在逻辑学上, 这种被称之为事实断言 当面对 事实断言, 我们不要立刻的选择相信, 要先去分析, 看看这个结论是否有疏漏 如果需要验证 事实断言, 需要完成几个问题 我为什么要相信他 是否需要证据来证实这个断言 证据的效力可靠吗 如果这个断言缺乏有力的证据, 那么这个断言就是 孤立断言, 因为他没有给出证据, 因此我们必然要怀疑 孤立断言 的可靠性, 向对方进一步求证 有时候, 事实断言的真实与否与个人的感觉无关, 比如 “大部分的美国议员都是男性” 可能看起来更加真实, 而 “练习瑜伽可以降低癌症” 看起来不那么真实 所以对于大部分的断言来讲, 要证明他是对的, 还是错的, 是一件很困难的事情 通常来讲, 某个断言的证据越多, 质量越高, 他的可信度就越高, 我们也就越能把这种断言称之为\"事实\", 那么怎么样来帮助我们确定断言的可靠性, 我们可以借助提问来实现 我们可以向阐释者提问 你的证据是什么 你怎么知道他是真的 你有什么证据 你为什么相信他 你能确定他是真的吗 你可以证明吗 这些问题要求阐释者进一步解释这些断言的证据, 以证明准确性, 如果他能大方的立刻的回答你的问题, 大概率是掌握了足够的证据 而顾左右而言他, 回避问题的人, 你就要留意这个断言的准确性了, 因为很可能他意识到了, 自己没有足够的证据去证明自己的断言 隐瞒证据(采樱桃谬误) 这个很容易举例, 现实中也很多, 比如楼盘的销售人员, 总是向你隐瞒房子的缺点 租房的中介 等等 在销售过程中, 业务员会有选择性的摆出论据, 挑对自己有利的话来说, 这就是隐瞒证据, 也叫采樱桃谬误(人们只会采好的樱桃) 比喻有选择性的说话, 只呈现好的部分, 把不利于自己的部分隐藏起来 作为消费者, 我们一定不要被销售轻易打动 答非所问 在某些特殊情境下, 真话说不得, 假话也说不得, 最好的办法就是不说. 这种诡辩被称为 答非所问, 即回答问题时, 有意无意的回答不相关的问题 这通常是为了在某些尴尬的场合, 有些话不方便直接的回答, 但是又不能失礼, 于是就 答非所问, 来避免尴尬 需要注意的是, 在该说真话, 需要表达意见的时候, 还是要真实的表达, 说出答案, 否则就会被认为是虚伪狡猾, 让人觉得不够真诚, 不可信任 绝对化谬误 诡辩术在古代非常盛行，古希腊哲入苏格拉底也精干此道。他有一次和欧西德辩论。 苏：“偷盗的行为对不对？” 欧：“不对。” 苏：“侮辱他人呢？” 欧：“不对。” 苏格拉底转语又问：“为了诱敌而窃取敌物，这种行为可对？”欧西德的头脑很清醒，不为迷惑，答道：“对。” 苏又问：“侮辱敌人可对？” 欧：“对。” 苏格拉底争辩说：“你刚才说偷盗和侮辱他人是不对的，难道敌人不是他人吗？你怎么又说’对’了呢？” 欧氏不甘示弱，解辩说：“那是因为对象不同、刚才我说的是对付友人，现在说的是对付敌人。” 苏格拉底便继续间道：“假如有一名将军，见其部下士气低落，便欺骗他们．说是救兵即将来到，从而鼓舞了部属的斗志、使斗争取得胜利、这样做对吗？” 欧：“对。” 苏又问：“孩子生了病却不肯吃药，父亲就欺骗孩子，说药是甜的。结果孩子吃了药治好了病，这做法可对？” 欧：“对！” 苏格拉底又争辩起来：“士兵和孩子都是自己人，你刚才说，不对的事情只能对敌，怎么又可对自己人呢？岂非自相矛盾？” 欧西德无法回答了。 我们可以看到, 欧西德已经输了, 他无法自圆其说 这启示我们. 回答问题太过绝对, 会让自己很被动 欧西德就犯了 绝对化谬误 的逻辑谬误, 没有具体问题具体分析, 结果被对方抓住了把柄, 最终输了辩论 世界上的所有事情都是有两面或多面性的, 需要具体问题具体分析, 绝对不能一概而论 在不同的现象, 不同的条件下, 针对某个问题或事物, 有不同的结论是正确的, 虽然是不同的结论, 但是他们相对于各自所处的事件/地点/条件下是正确的 在生活中, 我们要拥有辩证的思维, 对待不同的事物, 不但要具体分析, 还要辩证分析, 就算是真理也不一定放之四海而皆准 二难诡辩术 普罗塔哥拉悖论_百度百科 (baidu.com) 在这场辩论中, 双方都使用了 二难诡辩术 二难诡辩术 指的是辩论过程中, 只列出两种可能性, 此外别无选择, 迫使论敌从中做出选择. 无论对方选择哪一种可能性, 都对他不理. 这就迫使敌人进入进退两难的境地. 从而落入自己的控制之中. 二难诡辩术的两种可能性, 全部都是虚假的, 前后没有必然的联系, 这个假设的设置, 都是诡辩者出于自己的利益出发的. 目的是让敌人陷入进退两难的境地. 辩论的双方, 他们的立论都是错误的, 因为他们都违背了 “同一律” 原则, 同时概念和判断混乱, 从而导致是非不分, 所以就是诡辩. 关于上面的案例, 对于 欧提勒士 来说 如果我打赢了这场官司, 按照法院判决, 我不应该支付另一半学费 如果我输了这场官司, 按照合同规定, 我不应该支付另一半学费 对于 普罗塔哥拉 来说 如果欧提勒士打赢了, 按照合同, 他应该支付我另一半学费 如果欧提乐士打输了, 按照判决, 他应该支付我另一半学费 但是对于 欧提勒士 来说, 他的前提是不真实的, 推导不出结论, 因为这个官司的胜诉与败诉的区别在于给不给支付另一半学费. 如果他输掉了官司, 就必须需要支付另一半学费, 不然的话, 败诉的\"着力点\"在哪? 对于 普罗塔哥拉 来说, 它的前提也是不真实的, 因为前件与后件不存在必然的联系, 欧提勒士打赢了官司, 与支付另一半学费没有必然的联系, 因为合同规定欧提勒士第一次出庭打赢官司, 指的是他以律师的身份, 而这次是以被告的身份 这双方的二难推理, 采取的是不同的标准: 一个是法院判决, 一个是合同规定. 两个标准各有利弊, 他们都从为自己有利的标准为自己诡辩, 所以才会得出针锋相对的结论. 如果他们都使用同一个标准, 那案子就不复杂了. 破解这种诡辩可以采用三种角度 指出对方的假设前提是虚拟的, 不现实的 不正面回答对方的问题 以其人之道, 还其人之身 简化因果关系 导致大量人员死亡的原因是地震 大雪导致了铁路交通的瘫痪 就比如论点1, 你可以说直接原因或者最主要的原因是地震, 但是忽略了其他原因, 比如说房子的牢固性等等 在对某件事情进行解释时, 强调许多因素的某一个或多个因素, 就犯了过度简化因果的谬误 故意曲解 明明知道对方的意思, 却故意曲解成另一个意思, 造成概念或话题转移, 以便达成自己的目的, 这就是故意曲解 故意曲解是一种诡辩技巧, 把对自己不利的话语转成对自己有利的意思. 但有时候, 面对自己无法回答, 不能回答的问题, 也可以使用故意曲解的方式来回应, 这样可以缓和气氛 命名谬误 他为什么脸色不好? 因为他心情不好 这一问一答, 表面上看起来是在沟通, 实际上什么实际性的内容也没有说, 脸色不好与心情不好本来就是同一个意思, 通过贴标签或者命名的方式来描述发生的事实, 以掩盖说话者无知的情况, 被称为命名谬误 命名谬误很容易让人产生错觉, 认为说话者知道原因, 实际上, 说话者只不过是换个说话重复问题 同语重复 小明是小明爸爸的儿子 与命名谬误差不多, 这种属于在下定项中直接使用了被定义的概念, 互相套娃, 等于没说, 而且无法证明什么 一厢情愿 快过节了, 超市的商品肯定会有大的折扣 这句话是绝对正确的吗? 不一定 逻辑学上的一厢情愿, 是一种常见的谬误. 指的是人总是认为事物和人总是按照自己的想法来运行, 相信自己愿意相信的事情, 相信让自己快乐的事情. 这样只会让自己逃避现实, 回避真相, 对成长没有任何好处 区群谬误 男同胞都喜欢足球 仅仅基于群体的统计数据, 就对其下属的个体性质得出结论, 区群谬误假设了群体中的所有个体都拥有群体的性质, 是以偏概全 直觉思维 他肯定有什么事情瞒着我, 我的直觉一向很准 对某件事情没有经过分析, 仅仅根据直觉就下定论. 从逻辑上来讲, 直觉是无法作为论据的, 因为他没有可信度和说服力 只有经过证明的直觉, 才能作为论据 预期理由 这辆车马上要涨价了, 现在买最划算 这里将没有发生的事情拿来作为论据, 这就是预期理由的谬误 指在证明或反驳一个观点时, 把真实性有待验证的判断作为论据, 不具有可信度和说服力 巧合谬误 萧敬腾真的是雨神吗? 这句话只是调侃, 如果是当成真的, 就犯了巧合谬误 巧合与偶然不等于必然, 要找出结论与现象之间的必然性, 还是要深入的研究背后的原因 因果倒置 给懒惰的人发两头牛, 他们就勤奋了 这就是因果倒置的谬误, 并不是给懒惰的人发两头牛就勤奋了, 而是勤奋了会拥有自己的牛 回归谬误 A考试, 第一次考了100分, 第二次考了90分, 被骂之后又考了100, 所以骂会让人进步 这就是回归谬误, 从统计学上看, 事件发生的概率都是围绕一个均值来回波动的, 如果忽视了这个特点, 就会得出错误的结论 这里的A, 考试的分数与被不被骂没有必要的联系, A的水平就是90-100之间, 来回波动是正常的, 因为挨骂和得分就得出来骂会让人加分的结论简直离谱 推不出来 为什么把孩子扔进水里? 他的父亲擅长游泳 这两者之间并没有必然的联系, 由父亲会游泳, 就推倒出孩子也会实在是太牵强 这就是推不出来的谬误","link":"/2021/09/04/introduction_logic(45-66)/"},{"title":"跳出循环的几种方式","text":"比如这样的需求, 遍历一个 切片, 切片内容是切片1, 需求是判断切片1中某个是否有相应数据, 有就返回 我们需要考虑的是在写两层遍历时如何在获取结果后结束这两层遍历 变量法 设置一个变量, 在外层监听该变量, 获取到结果后修改该变量 123456789101112131415func main() { t := [][]int{{1, 2, 3, 4, 5}, {5, 6, 7, 8, 9}} s := false for _, v := range t { for _, v1 := range v { if v1 == 5 { s = true // 判断成立修改标量退出二层循环 break } } if s { // 检测标量结果，为true代表命中 break } }} 缺点很明显, 如果套更多层需要在每个层都写一个判断标量的逻辑一层层退出 goto 1234567891011121314func main() { t := [][]int{{1, 2, 3, 4, 5}, {5, 6, 7, 8, 9}} for _, v := range t { for _, v1 := range v { if v1 == 5 { goto Loop // 跳转到注册名为Loop的标记处，中间的代码直接跳过 } } } fmt.Println(\"nil\") return // 此处return防止继续执行loop的代码Loop: // Loop标记处， Loop只是一个标记，正常顺序执行也会执行Loop的代码,,一般叫Loop,可以自定义,与上面一致即可 fmt.Println(\"success\")} 此方法不止适用于循环,实际上他可以贴在任意地方,比如 1234567func main() { fmt.Println(1) goto Loop fmt.Println(2)Loop: fmt.Println(3)} 上面的 2 永远不会打印 这种方法的问题是会破坏正常的代码结构, 一个项目的代码必定是很多的, 有很多逻辑, 使用goto会破坏原有的代码结构, 大大降低了可读性和可维护性, 因此请尽可能的避免使用 goto break Label 给某一层循环设置一个Label,指定跳过某一个Label 12345678910111213141516func main() { t := [][]int{{1, 2, 3, 4, 5}, {5, 6, 7, 8, 9}} s := falseLoop: // 标记该循环为Loop,一般叫Loop,可以自定义,与下面一致即可 for _, v := range t { for _, v1 := range v { if v1 == 5 { s = true break Loop // 跳出Loop标记的循环 } } } if s { fmt.Println(\"success\") }} 相比于 goto, break Label 只能在循环中使用, Loop只能注册到循环中, goto是跳转到某行执行, break是跳出Loop标记的循环,相对来说限制大一些, 没有那么随意, 而相比于 方法一,则无需写多层判断, 需要注意的是, break Label 的 Label 不一定是顶层, 可以在任意一层 123456789101112131415161718func main() { t := [][][]int{{{1, 2, 3, 4, 5}}, {{5, 6, 7, 8, 9}}} s := false for _, v := range t { Loop: // 标记该循环为Loop for _, v1 := range v { for _, v2 := range v1 { if v2 == 5 { s = true break Loop // 跳出Loop标记的循环 } } } } if s { fmt.Println(\"success\") }} 单独写一个函数 这个不多说, 因为 return 直接退出函数了 1234567891011121314151617func t1(t [][][]int) bool { for _, v := range t { for _, v1 := range v { for _, v2 := range v1 { if v2 == 5 { return true } } } } return false}func main() { t := [][][]int{{{1, 2, 3, 4, 5}}, {{5, 6, 7, 8, 9}}} fmt.Println(t1(t))} 总结 条条大路通罗马, 其实哪种都可以, 但是我还是推荐使用函数的形式, 因为goto和lable或多或少都会降低可读性. 何况, 如果真的出现多个循环在一个函数, 应该思考是不是设计的有问题或者实现的有问题.","link":"/2021/09/04/jump_out_of_loop/"},{"title":"逻辑学入门(1-22)","text":"书籍信息 书名: 逻辑学入门 作者: 格桑 出版: 中国纺织出版社 序言 逻辑是什么? 很多人对此一知半解, 逻辑可以是思维的规律/规则, 可以是某种理论/观点/行为方式, 也可以是客观事物的规律性, 当然也可以是逻辑学的总称. 本书写的并不是什么大道理, 而是生活中的推导和证明某一件事的思考的过程 人总是习惯性的陷入一种\"一厢情愿\"的思维方式中, 诚然, 这样会让我们觉得温暖/快乐/踏实/惬意, 如果你是在梦里, 那没什么不好, 但是令人沮丧的是, 我们生活在真实的世界, 事物的发展总是不那么符合我们的预期， 所以我们最好早点摒弃\"一厢情愿\"的思考方式, 这样才能让我们面对生活时更加得心应手 人的一生有N多次选择, 免不了的我们会在一些选择中犯下错误, 其中逻辑错误是在底层, 因为现实生活中一切都有其逻辑, 所以如果我们犯了逻辑错误, 或者说违反了逻辑, 那么必然会导致出现一连串的错误 这也意味着, 如果我们可以掌握好逻辑, 去按照正确的逻辑思考事情, 就可以少走部分弯路 奥斯卡-王尔德说: “逻辑没有爱情一半重要, 但他能证明事情” 逻辑可以让我们分辨别人对我们说的话是真是假, 因为世界上的事情不以某个人的意志为转移, 很多的事情其本质和表现出来的现象并不是完全相同的, 因此在遇到事情或者看到东西时, 我们需要去思考, 这件事是不是真的, 怎么证明他是真的, 如果我们去理性的思考和分析, 就可以识别出大部分不符合逻辑的, 不正确的事情, 发现事物的本质. 往往对我们造成伤害的, 不是我们不知道的事情, 而是被伪装了的我们已经知道的事情 正文 偷换概念 课堂上, 老师提问学生， 你是怎样认识孙中山的？ 学生答， 我不认识孙中山 很明显的, 老师所说的 认识 指的是对孙中山这位历史人物的理解, 而学生所说的 认识 则是日常生活中的交往关系 此学生就犯了 偷换概念 的逻辑错误，即在同一思维过程中，在中途改变某个概念的内涵或者外延，用一些听起来一样的概念进行偷换，把某个事物的原意用狡辩的手法替换成另一个看起来也可以成立的解释，把假的说成真的，来达成目的 我们在日常与人交流时，一定要牢记对方提到的概念，当对方口中的概念发生偏移时，一定要多加留意，防止落入对方的 偷换概念 的逻辑陷阱 混淆概念 在逛商场的时候，远远的看到有某个花生油上面贴了买一送一的牌子，走近一看发现是买一个花生油送一个漏斗 对于 买一送一 这个词语，就包含了混淆概念的问题，混淆概念，即在同一逻辑思维过程中，把不同的概念当成同一个概念来使用，这几个不同的概念一般是表面相似来达到混淆的效果 我们需要注意对比较容易混淆的概念进行区分和辨别，提高警戒，严格区分和确认概念是否一致，并结合真实的情况和语境来综合判断是否是一样的概念 模糊概念 伯乐告诉儿子千里马是 脊骨弯曲、额头隆起、眼睛突出、善叫会跳，结果其儿子拿起蛤蟆认为蛤蟆是千里马 这与伯乐的表述有关， 伯乐并没有表述清楚千里马的范围，只是说了其特征，伯乐的儿子在没有充分了解概念的情况下就犯了模糊概念的错误 在思维的过程中，人们提及的概念都应该有明确的范围，如果你形容一个人的身高为 挺高的 这就是模糊的表达，这是难以衡量的 所以在听别人讲话时，一定要仔细辨别有相对含义的概念，并进一步追问以免出错，同时我们表达观点时也要注意表述清晰，遵守 简单原则，避免抽象描述，简化语言的枝叶，做到 言简意赅，这样对倾听者来说就不是一头雾水了 归纳谬误 有一只鸡喜欢归纳，他见每次主人喂食都在6点，于是他认为每天6点是喂食时间，直到有一天主人6点钟将其宰杀 无论归纳了多少事例，归纳的结论始终是充满不确定性的，只要出现了一个反面例子，归纳的结论就会被推翻 善于归纳总结是好事，但是不要武断的做出结论，这样很容易陷入偏执之中，如果我们使用总结出来的归纳谬论与别人争辩，很容易火上浇油，对沟通有害无益 要记住，客观的世界其实很复杂的，我们的认知总归是有限的，过去的规律和经验不一定能帮助我们解决当前的问题 我们需要在生活中使用归纳法，但是更要明白：有限的归纳法存在谬误的可能，这本身也是风险所在，我们永远要秉持质疑精神，确信所有的东西都是暂时的，一旦陷入偏执，对某些事物产生路径产生依赖，或者想当然的去以为什么，很容易面临失误 人们在澳大利亚发现黑天鹅之前一直认为天鹅都应该是白的 协和谬误 年轻人在打折期间办了健身房会员卡，后来得病医生禁止其剧烈运动，当健身卡无法退款的情况下，年轻人选择依旧去健身 年轻人明知道带病锻炼对身体的伤害是巨大的，依旧选择去健身，是因为他花钱购买了会员卡，又无法退款，浪费会员卡让其无法接受，所以铤而走险 年轻人面临的问题在逻辑学上被称为：协和谬论， 指在某件事情上投入了成本后，当发现不适合继续时，因为不舍得之前的投入，选择将错就错，造成更大的损失 正确的做法是果断地抛弃沉没成本，带着痛苦转身，如果不止损，继续投入。可能会有柳暗花明的那一天，但是概率很小，并不是所有事情坚持到最后都有好结果。很多时候我们要敢于认赔服输，半途而废，开始新的事情，而不是继续在协和谬论中苦苦挣扎 滑坡谬论 印度电影：起跑线 中的妻子不愿意 让自己儿子读她自己小时候的学校，认为孩子上不了好的幼儿园就上不了好的中学，就上不了好的大学，找不到好的工作，被同龄人抛在身后，然后走入歧途 但是我们知道，孩子上不了好的幼儿园不代表上不了好的中学，被同龄人抛在身后更是无稽之谈，我们都是普通人，妻子其实就是犯了 滑坡谬论 滑坡谬论指的是不合理的使用一连串的因果关系，将 可能性 转化为 必然性，得出某种结论 通常是链条式的，由 A 到 B，再到 C， 再到 D，一步步的推导出极端的结论 这种情况并不是因为其本身是链条式，而是在于链条中的每一个环节因果强度是不一样的，有些因果关系只是可能，而不是必然，所以在没有足够的证据之前，不要认定极端的结果必然会发生 赌徒谬论 40位博士参加一个实验，玩100局游戏，赢的概率是60%，每人初始额度1万元，最后金额大于1万的只有2个人，其实每次投资100元，最后能得到1.2万元 研究发现，人倾向于在不利的情况下投资更多的筹码，而在有利的情况下则反之 比如在连续输了3把之后他们会认为，下一把一定可以赢，然后投资更多的筹码，这就是赌徒心理，也叫赌徒谬论 这是一种不合理的逻辑推论，他们错误的认为随机序列中的一个事件发生的概率与之前发生的事件有关，即发生的概率会随着之前没有发生该事件的次数而增加 比如抛硬币，实际上我们知道每次的正反面概率都为50%, 但是赌徒谬论认为：连续两次抛出正面的概率为50%*50%=25% 其实无论你之前抛了多少次，正面多少次，反面多少次，下一次的概率依旧为50%，他不受之前的结果影响 看透赌徒谬论可以让我们更加理性的看待生活，避免让主观上的自信影响了自己的逻辑判断 诉诸怜悯 被警察抓住的小偷总是会说：我刚从外地过来，钱包丢了等等，总之是不得已才行窃 我们知道，任何事情总有其代价，这样的解释在法律面前并不适用，那他们为什么还要这样说呢？这就是诉诸怜悯的问题 诉诸怜悯是指在论证某个问题时，不是通过正面论题论证，而是利用受众对弱势的怜悯心理，诉说某个人的惨状来激起人们的恻隐之心，这其实就是转移话题，是一种逻辑谬误，无论所说是否真假，也与所作所为没有必然联系，不是支持论断的逻辑理由 我们在看待事情时，不要被同情心蒙蔽了双眼，而忽略了其所作所为，忽略了问题的本质 人人都有恻隐之心，但是情归情，法归法，两者不能混为一谈，一个理智的人不能用逻辑谬误去代替理性思考，更不能被情绪左右而丧失了客观的分析与判断 诉诸大众 诉诸大众的逻辑谬误, 指在论证一个观点时, 只是因为多数人赞同该观点, 则认为该观点为正确 诉诸大众的典型案例则是所谓的 从众心理 , 即多数人认为他是对的就是对的, 这根本就不是逻辑推论, 而是利用了人的不自信和盲从等弱点 人们总是倾向于让自己的观点得到更多人的赞同, 反之, 多数人都赞同的观点也会对个体的判断产生压力 但是我们要知道, 一个观点的正确与否, 与多少人赞同他无关, 没有必然的因果关系, 永远记住: 检验真理的唯一标准是实践 诉诸个体 与诉诸大众相反的是诉诸个体, 指仅仅根据个案做出总结和结论, 或者以个人经验作为论据来论证 我们要注意的是, 个人的经验是有局限性的, 单个事件也可能存在特殊的因素, 不能将其作为普遍性的材料进行论证 诉诸经验 当儿女的观念与父母不和时，父母往往会说：我走过的桥比你走过的路还多，这就是诉诸经验，我们知道，年龄并不是判断是非对错的标准，观点的正确与年龄大小没有明确的关系，而是要看论据和论证是否符合逻辑 当然，不得不承认，年龄越大、经历越多的情况下，其看待事情的正确性要优于小辈，所以对于经验，我们要辩证看待，既要吸收其合理部分，也要学会辨别其中不合理的部分，尤其注意要具体问题具体分析，不能被经验画地为牢 诉诸无知 没有人能证明外星人存在，所以外星人一定不存在 只是因为没有强有力的证据去证明或者反证，就认定某个观点是对的或者错的，此为诉诸无知的诡辩，也是很多阴谋论者的逻辑 人的认知是有限的，要证明某个事物的存在是很困难的，更别说去证明外星人这种我们没有见到过的事物 诉诸规则以外 凡事都有其规律，也有其规则，比如信用，失信者总是会诡辩说失信的事情是例外，殊不知 规则与例外，本身就是对立的，规则就是规则，例外就是破坏规则，破坏了规则就要付出代价，比如失信者不被别人信任，这就是代价，破坏规则一定会付出代价 诉诸完美 如果这件事情，我没有办法做到完美，那么就干脆不做了 这就是诉诸完美的逻辑谬误，总觉得不完美的是不能做的，这种想法只会导致无线拖延，错过大量的良机，甚至一事无成 谁也无法保证做一件事情可以万无一失，任何事情只有先去做了才有完美的可能，很多时候都是机不可失，时不再来 诉诸最差 我只是偷东西，又没有伤人 作恶者通常使用对比来祈求原谅 作恶与没作恶，是根本性质的问题，大恶与小恶，是严重程度的问题。两者不可混为一谈 诉诸信心 人们总是希望能得到他人的信任和理解 诉诸信心，指依仗信心作为论据的根基，而不是靠逻辑或证据的支持 诉诸信心的误区：以他人信心为论据，此为诉诸非理性的论证方式 我们要知道，一个人对另一个人的信任，不是建立在“我和你感情好”的基础上，而是建立在事实论据的基础上 诉诸恐惧 恐惧是人类最原始的情感之一, 诡辩者通常利用恐惧来强化自己的观点, 即为诉诸恐惧 诉诸恐惧通常刻意描绘危险, 让人感觉到恐惧, 从而愿意听信诡辩者的建议, 通常诉诸恐惧并不是凭空捏造, 而是有一定的根据, 只是可以的夸大其词, 以达到效果, 达到说服他人的目的 诉诸反诘 你说刷手机对眼睛不好，你不也老刷吗？ 说这些的目的是为了批驳对方的观点，但是采用的方式不是通过讲道理，摆事实去论证问题，而是通过向对方反诘来用对方的行为去批驳对方的观点。 正确的方式(以刷手机为例)，应该分析诸如手机屏幕发出的蓝光对视力有什么影响等才是有理有据的论证 我们不能因为刷手机这件事有人做就认为他是无害的 诉诸沉默 不说话不等于默认，不说话不等于心虚 诉诸沉默，指由于论点的主张者没有论证该论点，从而推断该论点是假的，这是不对的，论点的主张者没有论证论点这个行为，本身并不能成为该论点为假的理由 诉诸势力 人在屋檐下不得不低头 书的作者认为必要时也要为自己寻求权利，而不是因为多数人选择承受而随大流 动机论 在生活中，切记不能 以小人之心，度君子之腹 这种怀疑主义，是一种动机论，属于逻辑谬误，这与科学精神中强调的质疑精神有本质区别 科学精神中的质疑精神都是有前提条件的，他们有充足的理由，建立在实证和理性的基础上，是以事实条件为基础，以实验和检测为手段的，有根据、合理的怀疑 诉诸权威 我们要知道，名人说的话不一定是对的，诉诸权威的谬误，指的是认为权威人士说的话都是对的，实际上，权威具有相对性、多元性、可变性、时效性。 我们在引用权威时，需要注意以下几点 诉诸的权威必须是论题所在领域的权威，毕竟隔行如隔山 权威会过期，时代在进步，上限在不断提高 权威所秉持的观点，要在诸多权威中形成普遍共识，如果权威之间本身存在分歧则不适宜作为论据","link":"/2021/09/04/introduction_logic(1-22)/"},{"title":"limiter 源码分析","text":"前言 对于很多业务或者说是代码来讲, 运行速度的瓶颈都不在代码运行时本身, 所以我个人对于新业务的语言选型, 更多的是考虑其他方面, 而不是运行速度, 甚至有些业务, 还需要专门进行限流才可以达到目的, 比如说我要去测试 IP 和端口是否通畅, 需要通过测试是否能进行 TCP 连接来判断, 但是我们需要对这些进行一定的流速控制, 以免被机房自动告警或者占满带宽, 比如说我们需要对执行爆破任务的 work 限定最多同时运行 50000 个任务, 就需要进行限流处理了. 令牌桶 说起怎么样去限流, 一个很经典的模式 令牌桶 就出现在脑海中. 令牌桶这东西我更愿意用一种数学题来解释, 还在上学的时候, 相信大家都做过类似这样的题目: 一个游泳池, 有一个水管匀速向其中注水, 还有一个管子匀速从池中放水, 这其实就是达到了限流的目的 如果漏水的管子粗细代表 work 的多少, 而注水管和池子才是管控速率的关键, 当水已经漏完, 则是代表当前流速已经达到了峰值, 只能等注水管再流水, 而当注水管粗于漏水管, 也有一个游泳池可以作为缓冲 本人之前也写过一个简单的令牌桶模式的限流器, 简单来讲就是有一个goroutine持续的进行注水, 就是向一个chan进行写入, 而有一个goroutine持续从chan读取数据, 读取到就认为拿到了令牌, 使用goroutine生成一个新的任务, 代码类似于 1234567891011121314151617func GetBucket(capacityPs, maxCapacity int) chan struct{} { var bucketToken = make(chan struct{}, maxCapacity) timeD := time.Second / time.Duration(capacityPs) ticker := time.NewTicker(timeD) go func() { for _ = range ticker.C{ bucketToken &lt;- struct{}{} } }() return bucketToken}func GetToken(block bool, bucket *chan struct{}) { for _ = range *bucket { // TODO }} 这样基本满足了业务, 但是学无止境, 还是要看一下大佬们的实现. 方便以后可能的需求迭代, 于是找到了一个开源项目 ulule/limiter: Dead simple rate limit middleware for Go. (github.com) 并尝试理解其源代码","link":"/2021/07/07/limiter_analyze/"},{"title":"逻辑学入门(23-44)","text":"书籍信息 书名: 逻辑学入门 作者: 格桑 出版: 中国纺织出版社 正文 重复谎言 三人成虎的故事 众人的言论往往能混淆是非, “谎言重复一千遍就是真理” ，不断地重复一个虚假的观点，就算没有进一步提供论证或支持，也可以削弱论敌的反驳，因为不断地重复会增加逻辑的合理性，让人误以为事实就是那样。 但是要牢记的是，谎言永远不能变成真理，哪怕重复一万遍也是如此，谎言重复再多次也与事实无关，谎言永远无法变成正确的逻辑 强制推理 有些人，看见别人有钱，就说：“这个人，肯定是干了坏事才挣到这么多钱” 之类的话语 强制推理，即将不同的事物错误的勉强的联系在一起，从而得出结论。看似是结论，其实毫无意义，完全是歪曲事实。 比如上面的例子，有钱与干坏事并没有必然的联系，却被有些人强行的联系到一起。将两个不相关的事务强行联系到一起，得出来的结论自然是谬误。 真正理性的是,客观的观察和总结事物的关系, 不掺加主观看法, 不把没有逻辑的事务联系到一起 因果混淆 研究发现, 越是成功人士, 睡眠时间越短 研究发现, 去医院越多, 越容易生病 许多人喜欢把 “接连发生” 的事情引为环环相扣,互为因果. 这种思考方法是错误的, 属于 因果混淆 的谬误. 事物之间有相关性, 并不能证明他们之间存在因果关系. 而有时候, 两者之前的关系恰恰相反, 或者两者之间并没有关系 我们在分析事物时一定要谨慎, 不能把巧合的相关关系视为因果关系, 否则的话就会得出错误的结论 惯性思维 人类无法抗拒的十大心理之一, 鸟笼心理 人们在遇到问题时, 通常都会先入为主的按照自己熟悉的某个方向或途径去联想, 把自己遇到的问题纳入自己熟悉的框架内进行分析, 从而让思维形成惯性, 也就是惯性思维. 就比如鸟笼心理, 人们习惯的认为, 只有鸟才生活在鸟笼里. 家里有鸟笼就证明之前养过鸟. 不要用惯性思维去看待生活中的问题, 偶尔尝试突破鸟笼心理, 进行发散性的思维, 也许我们就会发现鸟笼外有另一个世界 诉诸出生 龙生龙, 凤生凤, 老鼠的儿子会打洞 有些子女与其父母在某种行为或性格上存在相似性, 但是不要过度的 “迷信” 这句话, 甚至将其作为推断一个人 道德/品行/能力/成就 的依据, 这就犯了诉诸出生的逻辑谬误 本章给出两个真实的例子: 赵国名将赵奢/新东方创始人俞洪敏 人从出生开始, 就会受到来自 家庭/社会/他人 等各方面的影响, 这些影响很重要, 但是终究只是外因, 而非决定性的因素, 毕竟人还有主观能动性 出生并不能代表一个人的品行和能力, 出生也无法决定一个人的命运和前途, 我们在看待别人和自己时, 一定不要犯诉诸出生的错误 诉诸人身 有些商家, 当顾客对商品提出异议时, 比如\"东西有点贵\", 商家就翻脸, 用比如 “你可以去买便宜的/一看你就没有眼光” 等话语来反驳 商家这种是诡辩, 根本不符合逻辑, 完全是人生攻击 如果一个人在驳斥他人的观点和结论时, 忽略了论证本身, 而是去直接攻击提出观点的人或团体, 那他就犯了 诉诸人身 的谬误 诉诸人身的谬误门槛很低, 生活中经常遇到, 其主要有两种 直接性诉诸人身: “这个人之前偷过东西, 所以他说的肯定是错的” 处境性诉诸人身: “你买了A公司的股票, 你当然会说A的股票会涨” 直接性诉诸人身指的是, 因为某个人身上存在某种积极或消极的特质, 就认为其想法或论点是错误的, 而通常一个论点是否正确,在于它是否符合事实, 我们是否相信某个人的看法与这个人的说法正确与否没有直接的绑定关系 处境性诉诸人身指的是, 因为某个人处在某个团体中, 这个团体与其有利益关系, 就认为该人的想法是不客观/不中立/不理性 的, 事实上, 当我们考虑某个人的论点时, 可以去考虑是否与某人有利益关系, 但是某人的处境和利益关系并不能直接判断这个人的论点为不真实的/错误的 我们在辩论某个观点时, 切记要对事不对人, 如果遭到了诉诸人身的问题, 不必再争论下去, 直接远离即可 循环论证 A: “你为什么这么胖” B: “因为我吃得多” A: “你为什么吃这么多” B: “因为我胖” 循环论证, 即用来证明论题的论据本身的真实性需要靠论题来证明, 就以上面为例, A最后也不知道为什么这么胖 为什么会出现循环论证的谬误, 归根结底是在论证过程中, 将论证的前提当成了论证的结论, 此为 先定结论. 先预设前提 x, 求出 y, 再用 y 去证明 x 正确. 当然, 循环论证在逻辑上是说得通的, 因为x可以求出y, 所以y可以反推到x, 但是因为结论可能与前设完全相同, 所以结论并不是其前设的推论 在论证的过程中, 所有循环论证都必须假设其命题成立 即x推出来的一定是y, 所以循环论证本身并不能证明什么, 他只不过是回避问题的手段 稻草人谬误 劳动人民会在田地里插上一个稻草人, 目的是欺骗并吓走动物 稻草人谬误, 指的是在辩证过程中, 为了反驳对方, 而 歪曲/夸大/以其他方式曲解 对方, 使得被攻击的不是对方的论点, 而是更容易被批判的立场 比如A想反驳B, 就在B旁边树立一个稻草人当做B, 然后攻击稻草人来冒充和替换A的观点, 此为刻意扭曲 A: “我认为小孩不应该在马路上乱跑” B: “把小孩关起来, 不让他们活动, 这才是不对的” A的观点是不让小孩在马路上跑, B却刻意的曲解观点, 树立了一个稻草人 “把小孩关起来”, 然后攻击稻草人, 但是其实不让小孩在马路上跑并不是要将小孩关在屋子里 我们在生活中, 要站在真实的立场去思考问题, 秉持平和的心态, 减少歪曲/夸大来攻击他人的立场, 一切都拿事实和证据来说话. 当有人对你声情并茂的讲起某件事或某个人时, 不要被颠倒是非的语言影响, 要有自己的判断 要记住的是, 稻草人再逼真也不是真实的人 转移论题 明代有一个学士, 其父并不出名, 其子也不争气, 其孙考上了进士, 其就责骂他的儿子不成材 其: “你真是个废材” 其子: “你的父亲不如我的父亲, 你的儿子不如我的儿子, 我有什么不成材的呢?” 转移论题就是在思维过程中, 吧有些联系或表面上相似的不同话题当做相同的话题使用 其本人要跟儿子辩论的是 “儿子是否成才”, 其子则转换成了 “你的父亲和我的父亲, 你的儿子和我的儿子相比”, 恰好把原来的问题给回避了 为了避免出现这样的谬误, 我们必须要对自己的批判对象了解清楚, 认真把握原意, 避免犯错 诉诸感觉 刻舟求剑的典故 两小儿辩日的典故 当事人为什么认为可以找到宝剑呢? 全凭他个人的感觉, 这种凭借表象和感觉经验来作出判断和推理的, 并且认为以此得出的结论是绝对正确的, 无视事实的情况, 就为诉诸感觉的谬误, 当然经验很多时候也是正确的, 但是经验也要经得起推敲, 同时要注意并不是绝对正确, 还是要仔细的推理和论证才行 同样的, 两小儿辩日, 也是两个人都按照自己的经验来作为结论, 得出的结论就是错误的 我们在生活中, 不要 “想当然” , 否则就会陷入到逻辑谬误中, 有的时候, 我们感觉正确的可能与事实大相径庭 预设谬误 有一些论证是基于假设的, 即用那些被认为理当如此的预设或背景信念去做论证, 但是如果这个假设本身就是有问题的, 那么得到的结果也是不成立的 争议前提 前提1: 在堕胎的过程中, 胎儿被杀害了 前提2: 胎儿是无辜的 前提3: 故意杀害一个无辜的人是谋杀 结论: 堕胎属于谋杀 其中, 前提1是属实的, 但是前提2和3是有争议的, 争议之处在于胎儿是否算是一个人? 拿有争议的论据去论证某个结果, 这个论证本身是存在争议的, 所以不能当做论据 窃取论题 问题: 为什么中国人都爱说谎? 直接给出了结论, 而没有任何论据去支撑, 把需要去论证的结论当作一个前提, 比如这里应该去论证中国人是否爱说谎, 而不是论证为什么中国人爱说谎 复杂问句 A: 我见过C B: C是白猫还是黑猫 A: 有黑有白 B: 你在说谎, 因为C不是一只猫 复杂问句指的是以问句预设了某些假设为真的方式来询问, 你只能去回答对和错, 当这个假设本身为假时, 回答对和错都会导致对这个为假的假设的肯定, 作为被提问者, 我们要仔细辨别假设的真伪, 防止被套路. 当我们身为提问者时. 可以通过这种方式来探听虚实 虚假选言 要么所有英国大学都把项目完全变成在线课程, 要么所有英国人都会破产 这种属于选言, 选言指有两个命题或者选言肢的复合命题, 比如这里的两个 要么, 但是当出现了推理错误, 就会导致影响结果出现错误, 比如这里的两个选择根本上是错误的, 没有实际关联的 例外谬误 狗是友好的动物 我的皮皮是一条狗 皮皮是一只友好的动物 当一个论据是通过普遍的规律来论证的, 并且这个论据占了得到该论点的关键性因素, 但是事实是一个例外时, 就是例外谬误 比如皮皮是一只友好的动物, 但是当皮皮乱咬人时, 这个结论就不成立, 该用户以普遍的规律来论证, 却忘了什么事情都有可能有例外 需要牢记的是: 通常为真的不一定总是真的 诉诸后果 我们公司每月底薪+提成有8000 以讨好或不讨好的结果来说服他人 诡辩者不是通过正常的逻辑来证明自己的观点, 而是通过告知被说服者会有怎样的后果, 来 引诱/哄骗/威胁 被说服者, 来达成目的 否定前件 如果一个人想要出国, 他就需要学习英语, 如果一个人不想出国, 那么他就不需要学习英语, 因为我不想出国, 所以我不学英语 在 如果…那么… 这种格式的论证中, 把 如果… 称为前件, 把 那么… 成为后件 如果前件就是错的, 比如这里的 想要出国 与 学习英语, 两者并无直接的关系, 想要学习英语的动机有很多, 不一定是出国 机械类比 东施效颦_百度百科 (baidu.com) 其中东施就犯了机械类比的错误, 他只看到了西施捂住胸口皱着眉头, 认为是这样才好看, 却没有发现西施的美是客观存在的, 是多方面决定的 类比是一种表达思想, 是进行教育和说服的有力工具, 但是要注意类比前后的事物, 必须要有尽可能多的共性, 还有就是两个事物的本质属性和结论之间一定要有必然的联系 无理假设 我不是故意的, 再给我一次机会, 我一定不… 我们经常可以听到这种话, 听起来真挚动人, 但是要记住, 这只是一种美好的假设, 现实是无法改变的, 在逻辑学上, 假设是一种方法, 可以用于各个领域的研究, 但是如果进行不科学的假设, 目的是为了安慰自己, 平缓情绪, 表达悔恨的, 这种假设就是无理假设 面对一些人的假设, 要保持冷静和理智, 不可轻信和心软, 因为这可能是一种逻辑谬误 双否定前提 所有哺乳动物都是温血动物 猫是哺乳动物 所以猫是温血动物 这种属于典型的三段论, 即先列出两个陈述, 再在这两个陈述的前提下推导出第三个结果, 这种是没有问题的, 但是下面这种 不喜欢吃甜食的人比较瘦 有些抽烟的人不喜欢吃甜食 所以抽烟的人比较瘦 这种就属于错误, 这种三段论的前两段都是否定的, 逻辑学上, 这种被称之为 双否定前提, 这种得出来的结论是不可靠的 不当周延 所有骑自行车的都是节俭的人 没有企业老板是骑自行车的 所以, 没有企业老板是节约的 可能猛一看觉得有点道理, 但是细细思考其实这个逻辑推论是不符合逻辑的, 因为企业老板是否节约与他是否节俭没有直接的关系, 不能因为不骑自行车就说老板不节俭. 这个推导就犯了 不当周延 的错误, 这是因为第一句所有骑自行车的都是节俭的, 这句话只能说明 骑自行车的都是节俭的人, 而忽略了 骑自行车的只是节俭的人的一部分, 有些不骑自行车的人也很节俭, 当你的论据中出现了某个群体中的某个部分的例子, 在结论中却使用某个部分来论证整个群体, 这就是 不当周延, 再看例子, 论据中使用 节俭人群中的骑自行车的人 这个 借鉴群体的一部分人 , 结果中却将 整个节俭人群 来作为证据, 明显是错误的 在很多情况下, 诡辩者会使用 不当周延 来忽悠人, 我们一定要注意这种情况 罗素悖论 罗素悖论_百度百科 (baidu.com) 我们这里不谈对数学的影响, 单从逻辑来讲, 这就属于悖论, 指逻辑上可以推导出相互矛盾的逻辑, 但是表面上又可以自圆其说的命题或理论体系 还有许多这样的例子, 比如 一个年轻人对大发明家爱迪生谈起自己的设想,他满怀信心地说：“我想发明一种万能溶液,它可以溶解一切东西.” 爱迪生听罢,惊奇地说：“那么,你想用什么器皿盛这种万能溶液呢?” 年轻人哑口无言. 这是因为, 万能溶液能把任何东西都溶解了,所以装溶液的器皿也都溶解了,不能用任何东西来盛万能溶液. 但是液体就需要器皿去盛放, 但是如果你能用器皿去盛放了, 这个溶液还叫万能溶液吗? 还有许许多多的悖论, 这并不是一种诡辩, 实际上, 悖论的提出和解决, 是人类智慧的闪光, 也是科学发展的酵母, 在不断的启发人们进行深入的思考 排中律 排中律是事物的规律, 也是思维的规律, 一个事物在某个时间里, 一定会具有某个属性, 或者不具有某个属性, 必须满足两者之一, 比如 A是B, 或者A不是B, 那么对于相互矛盾的两个命题, 一定是有一个是正确的, 不可能同时正确或错误, 此为排中律 西瓜是甜的 西瓜不是甜的 这两个肯定有一个是真的, 不可能两个都是真的或假的 充足理由律 充足理由律_百度百科 (baidu.com) 充足理由律是逻辑思维必须遵守的基本规律之一, 指在论证和思维过程中, 要确定一个判断为真, 必须有足够证明他真实的理由. 如果缺乏足够的理由, 就没有论证性. 正确的思维是思路严谨的思维, 论证的过程要摆事实, 讲道理, 以理服人, 言之以理, 持之以故 现实中经常有人违背这种理由论 毫无理由: 不讲任何理由, 没有任何依据就下结论 理由虚假: 对一个命题来提供理由, 但是这个理由毫无根据, 这个理由是主观的, 是不存在的或者虚假的 论证错误: 指证明论题的理由是真实的, 但是理由与结论之间没有必然联系 在逻辑思维过程中, 无论是被说服者或说服者, 都要找到充足的理由来证明结论, 以理服人 范畴错误 师范大学在哪里? 师范大学指的是一种大学的种类, 而不是指某一所大学, 两者是包含和被包含的关系, 而不是并列关系, 这就是一种统筹错误 曹雪芹是一个天文学家 哈弗大学面积排名第几? 曹雪芹是文学家不是天文学家 哈弗大学是世界名校, 面积大小不影响排名 这种也属于范畴错误, 指的是将既有的属性归属到不可能会拥有该属性的对象上, 是语义学和存在论的错误 小孩子经常会犯这种错误, 因为他们对分类没有明确的概念 断章取义 爱迪生说过: “天才就是1%的天赋+99%的汗水, 但那1%的灵感是最重要的，甚至比那99%的汗水都要重要。” 很多人只看到了 “天才就是1%的天赋+99%的汗水”, 但是爱迪生的原话强调的是灵感的重要性, 只看到第一句可能认为勤奋可以成功, 这就与爱迪生的原义相差甚远 类似于这样的断章取义的谬误越来越多, 不顾整篇文字或谈话的真实意图, 单独的截取一句话进行分析, 尤其是短视频的火热与人们习惯汲取碎片知识 甚至还会被人恶意的引导, 曲解原义而进行攻击, 比如 知识就是力量 原话: 知识就是力量, 但更重要的是运用知识的技能 原义是强调运用知识的技能, 可能被变成过分强调知识本身 吾生有崖, 而知无涯 原话: 吾生有崖, 而知也无涯, 以有涯随无涯, 殆已！ 原义是说生命是短暂的, 知识是无限的, 用有限的生命去学习无限的知识, 是很危险的 我们在引用名言警句作为论据时, 必须要注意不要断章取义, 同时在生活中也要有自己的思考, 不要被带歪","link":"/2021/09/04/introduction_logic(23-44)/"},{"title":"LeetCode解题(1-10)","text":"1.两数之和(简单) https://leetcode-cn.com/problems/two-sum/ 题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解答 1234567891011121314151617181920212223package main/*URL: https://leetcode-cn.com/problems/two-sum/解题思路: 维护一个map,key为nums的值,value为该值的索引, 遍历一遍nums, 假设每个值为b, 算出a+b中a的值, 判断map存不存在, 如存在则获取到map中a的value(索引), 不存在则将b的值与索引加入map中, 有可能都不匹配,注意在遍历结束后返回一个空切片 */func twoSum(nums []int, target int) []int { sumMap := map[int]int{} for index, value := range nums{ mapValue, ok := sumMap[target-value] if !ok{ sumMap[value] = index continue } return []int{mapValue, index} } return []int{}} 2.两数相加(中等) https://leetcode-cn.com/problems/add-two-numbers/ 题目 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解答 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package main/*URL: https://leetcode-cn.com/problems/add-two-numbers/解题思路: 新建函数 addNodeaddNode 多接收一个参数为偏移值读取两个结构体的 val，相加，大于10则pre为1使用递归来层层读取调用 addNode*/type ListNode struct { Val int Next *ListNode}func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { return addNode(l1, l2, 0)}func addNode(l1 *ListNode, l2 *ListNode, pre int) *ListNode { // 处理链表 if l1 == nil &amp;&amp; l2 == nil{ if pre == 0{ return nil }else { return &amp;ListNode{ Val: pre, Next: nil, } } } if l1 == nil{ l1 = &amp;ListNode{ Val: 0, Next: nil, } } if l2 == nil{ l2= &amp;ListNode{ Val: 0, Next: nil, } } count := l1.Val + l2.Val + pre // 计算本次数据结果,pre为上一次计算满10进1 p := 0 if count &gt;= 10{ p = 1 count = count - 10 } node := &amp;ListNode{ Val: count, Next: addNode(l1.Next, l2.Next, p), } return node} 3.无重复字符的最长子串(中等) https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 题目 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 123输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 1234输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 解答 12345678910111213141516171819202122232425262728package main/*URL: https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/滑块模式，维护一个map，存放当前滑块内的内容，滑块向前滑动，新的字符直接加入滑块老的字符先判断是否在滑块内，在则滑块起始为老的字符出现位置+1每次获取一下长度，如果大于已保存的最大长度则最大长度+1*/func lengthOfLongestSubstring(s string) int { var ins = make(map[int32]int, len(s)) // 建立存放已出现字符的map，key为该字符，value为下标 max := 0 // 最大值 startIndex := 0 // 起点下标 for index, value := range s { // 遍历字符串 oldIndex, ok := ins[value] // 判断字符是否已经出现过 ins[value] = index // 如出现过将map字符下标替换成新的，未出现过新增 if ok &amp;&amp; startIndex &lt;= oldIndex { // 如果之前出现过且老的下标在起点下标之内，代表之前虽然有出现过且在·滑动窗口内 startIndex = oldIndex + 1 // 将起点下标向前偏移一位，去除重复字符 } if (index - startIndex + 1) &gt; max { // 判断现在的长度是否超过记录的最大长度 max = index - startIndex + 1 // 更新最大长度 } } return max} 4. 寻找两个正序数组的中位数(困难) https://leetcode-cn.com/problems/median-of-two-sorted-arrays/ 题目 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 解答 pass 5.最长回文子串(中等) https://leetcode-cn.com/problems/longest-palindromic-substring/ 题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000 示例 123输入: \"babad\"输出: \"bab\"注意: \"aba\" 也是一个有效答案。 12输入: \"cbbd\"输出: \"bb\" 解答 1234567891011121314151617181920212223242526272829303132333435363738394041package main/*URL: https://leetcode-cn.com/problems/longest-palindromic-substring/中心扩散法: 遍历目标字符串, 以当前字符为中心, 向两边扩散, 如一致则继续扩散, 比较找出最长的, 此为奇数扩散针对类似于 baa 这种情况, 连续两个相同的字符串, 在遍历时考虑将当前字符与下一个字符当作扩散的中心, 此为偶数扩散*/func longestPalindrome(s string) string { maxStr := \"\" // 长度为0或1直接返回 if len(s) &lt;= 1 { return s } // 循环 for i := range s { t := verify(s, i, i) if len(t) &gt; len(maxStr) { maxStr = t } t = verify(s, i, i+1) if len(t) &gt; len(maxStr) { maxStr = t } } return maxStr}func verify(s string, l int, r int) string { for { if l &gt;= 0 &amp;&amp; r &lt; len(s) &amp;&amp; s[l] == s[r] { l-- r++ } else { // 如果匹配不上了, 返回上一个匹配成功的回文 // list包头不包尾, 所以 l+1 而 r 不包 return s[l+1 : r] } }} 6.Z字形变换(中等) https://leetcode-cn.com/problems/zigzag-conversion/ 题目 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 12输入: s = \"LEETCODEISHIRING\", numRows = 3输出: \"LCIRETOESIIGEDHN\" 123456789输入: s = \"LEETCODEISHIRING\", numRows = 4输出: \"LDREOEIIECIHNTSG\"解释:L D RE O E I IE C I H NT S G 解答 123456789101112131415161718192021222324252627282930313233343536package main/*URL: https://leetcode-cn.com/problems/zigzag-conversion/解题思路: 我们把 Z 结构的中间的空格全部去掉, 会发现实际上是一个二维数组,每独取一个新的字符, 将其存储进当前数组, 再读取下一个字符存储进下一行数组,当触碰到行底时, 下一个字符存储进上一行直到行初再正序存储*/func convert(s string, numRows int) string { if numRows == 1 { return s } var resList = make([][]string, numRows) res := \"\" rowIndex := 0 flag := 1 for _, v := range s { resList[rowIndex] = append(resList[rowIndex], string(v)) switch rowIndex { case numRows - 1: flag = -1 case 0: flag = 1 } rowIndex = rowIndex + flag } for _, v := range resList { for _, k := range v { res = res + k } } return res} 7.整数反转(简单) https://leetcode-cn.com/problems/reverse-integer/ 题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 示例 12输入: 123输出: 321 12输入: -123输出: -321 12输入: -123输出: -321 解答 1234567891011121314151617181920212223242526package mainimport \"math\"/*URL: https://leetcode-cn.com/problems/reverse-integer/首先我们可以使用 math 包下的变量来判断是否超限反转方面使用求余+取模计算即可*/func reverse(x int) int { if x &lt; math.MinInt32 || x &gt; math.MaxInt32 { return 0 } res := 0 for x != 0 { temp := x % 10 x = x / 10 res = res*10 + temp if res &lt; math.MinInt32 || res &gt; math.MaxInt32 { return 0 } } return res} 8.字符串转换整数 (atoi)(中等) https://leetcode-cn.com/problems/string-to-integer-atoi/ 题目 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 本题中的空白字符只包括空格字符 ’ ’ 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 12输入: \"42\"输出: 42 1234输入: \" -42\"输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 123输入: \"4193 with words\"输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 1234输入: \"words and 987\"输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 1234输入: \"-91283472332\"输出: -2147483648解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN 。 解答 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"fmt\" \"math\" \"strconv\")/*URL: https://leetcode-cn.com/problems/string-to-integer-atoi/解题思路: 普通的逻辑处理*/func myAtoi(str string) int { si := \"\" sum := 1 stop := false for _, v := range str{ vs := fmt.Sprintf(\"%c\", v) if vs == \" \" &amp;&amp; stop == false &amp;&amp; si == \"\" { // 捕捉最开始是空格的情况 continue } if vs == \"-\" &amp;&amp; stop == false{ // 捕捉以-开头 sum = -1 stop = true continue } if vs == \"+\" &amp;&amp; stop == false{ // 捕捉以+开头 sum = 1 stop = true continue } if _, err := strconv.Atoi(vs); err == nil{ // 捕捉数字 stop = true si+=vs continue } break } res, _ := strconv.Atoi(si) if res &lt; math.MinInt32 || res &gt; math.MaxInt32 { if sum == 1{ return math.MaxInt32 } return math.MinInt32 } return res * sum} 9. 回文数(简单) https://leetcode-cn.com/problems/palindrome-number/ 题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 12输入: 121输出: true 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶 你能不将整数转为字符串来解决这个问题吗？ 解答 12345678910111213141516171819202122package mainimport ( \"strconv\")/*URL: https://leetcode-cn.com/problems/palindrome-number/解题思路: 转换成字符串，遍历一半即可，对于基数长度，最中间的数字不必要比较*/func isPalindrome(x int) bool { s := strconv.Itoa(x) l := len(s) for i := 0; i&lt;= l/2-1; i++{ if s[i] != s[l-i-1]{ return false } } return true}","link":"/2021/09/04/leet_code(1-10)/"},{"title":"总结一下 linux 中的线程模型","text":"概述 linux 最开始使用的线程是linuxThreads, 但是linuxThreads不符合POSIX标准, 后来出现了NGPT, 性能更高, 之后又出现了NPTL, 比NGPT更快, 随着时间推移, 就只剩下NPTL了 NPTL&gt;NGPT&gt;linuxThreads 线程的模型分为三种: 多对一(M:1)的用户级线程模型 一对一(1:1)的内核级线程模型: 例如linuxThreads和NPTL 多对多(M:N)的两极线程模型: 例如NGPT 多对一 多对一很好理解, 在多对一中, 线程的创建/调度/同步的细节都由进程的用户空间线程库来处理, 也就是说由语言自己来处理. 用户态线程的很多操作对内核来讲, 都是透明的, 不需要内核来进行接管, 就意味着不需要进行内核态和用户态进行频繁的切换. 导致线程的创建/调度/同步的处理速度非常的快. 当然也有缺点, 当多线程并发执行时, 其中一个线程执行 IO 操作需要经过内核时, 内核接管了操作出现阻塞, 就导致了用户态的其他线程都会被阻塞. 因为这些线程实际上都是一个内核调度处理. 如果语言不对多核进行优化时, 就会导致只有一个内核处理线程, 也就无法调度到其他的核心, 就变成了伪线程 一对一 在一对一模型中, 每个用户线程都对应各自的内核调度实体, 内核对每个线程进行调度, 在阻塞时将可以其他线程调度到其他核心处理. 线程每次操作都会在用户态和内核态直接进行切换, 消耗一定的资源, 同时, 内核为每个线程都配置一个核心, 导致线程如果很多时, 会影响性能 在现代硬件上, CPU 一般都是多核, 因此相比多对一来讲, 一对一能更好的使用资源 多对多 多对多综合力一对一和多对一的优点, 每个线程可以拥有多个调度实体, 也可以多线程对应一个调度实体 但是多对多的调度需要内核态和用户态一起联动实现, 导致该模型非常复杂 go go 的 GMP 模型, 属于是多对多模型, 默认情况下, 真正的核心实体数量为 CPU 的内核数量, go 的 goroutine 是 go 内部的线程, 对应 GMP 中的 G, GMP 中的 P 会对 G 进行调度, 落到真正的核心实体, 也就是 GMP 中的 M 进行运行 更多的 go 调度部分逻辑, 查看我的其他相关文章","link":"/2022/02/21/linux_thread_model/"},{"title":"mongo 的 bulk 功能","text":"前言 Tips: go 的 mongo 模块, 有两个, 一个是 go-mgo/mgo: The MongoDB driver for Go. UNMAINTAINED - SEE BELOW (github.com) 一个是 mongodb/mongo-go-driver: The Go driver for MongoDB (github.com) 这里演示使用后者, 也推荐大家使用后者, 因为 mgo 已经于2018年停止更新, 对 mongo 的版本支持也只到4.8, 而后者是由 mongodb 官方维护, 对于 go 和 mongo 的版本更新都很及时 问题 在实际开发中, 我们可能遇到这样的需求场景: 有一个消费者要不停的获取到数据并且根据数据修改/增加 mongodb 的值, 可能第一时间我们考虑到的是获取一个数据后立刻对数据进行处理并同步到 mongo, 他的代码类似于 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( \"context\" \"fmt\" \"go.mongodb.org/mongo-driver/bson\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\")var mongoClient *mongo.Clientfunc InitMDB() error { // Set client options clientOptions := options.Client().ApplyURI(\"mongodb://user:pwd@127.0.0.1:15000/test?replicaSet=replica\") // Connect to MongoDB client, err := mongo.Connect(context.TODO(), clientOptions) if err != nil { fmt.Println(err) return err } // Check the connection err = client.Ping(context.TODO(), nil) if err != nil { fmt.Println(err) return err } mongoClient = client return nil}func GetMDBCollection(dataBase, collection string) *mongo.Collection { return mongoClient.Database(dataBase).Collection(collection)}type Task struct { ID primitive.ObjectID Age int}var TaskChan chan Taskfunc Demo() { for t := range TaskChan { // 监听 chan, 有任务就处理 f := bson.M{ \"_id\": t.ID, } u := bson.M{ \"$set\": bson.M{ \"age\": t.Age, }, } c := GetMDBCollection(\"test\", \"demo\") c.UpdateOne(context.TODO(), f, u) // c 是 mongo 连接 }}func main() { InitMDB() TaskChan = make(chan Task, 1) Demo()} 使用监听 chan 的方式, 每获取到一个 task, 便去 mongo 进行一次更新, 当量不大时不会出现问题, 但如果生产者的速度非常快, 例如 1s 有50个 task 被生产, 这时候, 通过每次获取一个 c 进行一次更新的方案就会导致消费者消费速度出现瓶颈, 导致性能问题出现 使用 goroutine 尝试解决 获取你会想到, 使用 goroutine 来去除消费时需要等待 mongo 交互的等待时间, 将代码修改为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport ( \"context\" \"fmt\" \"go.mongodb.org/mongo-driver/bson\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\")var mongoClient *mongo.Clientfunc InitMDB() error { // Set client options clientOptions := options.Client().ApplyURI(\"mongodb://user:pwd@127.0.0.1:15000/test?replicaSet=replica\") // Connect to MongoDB client, err := mongo.Connect(context.TODO(), clientOptions) if err != nil { fmt.Println(err) return err } // Check the connection err = client.Ping(context.TODO(), nil) if err != nil { fmt.Println(err) return err } mongoClient = client return nil}func GetMDBCollection(dataBase, collection string) *mongo.Collection { return mongoClient.Database(dataBase).Collection(collection)}type Task struct { ID primitive.ObjectID Age int}var TaskChan chan Taskfunc Demo() { for t := range TaskChan { // 监听 chan, 有任务就处理 // 每次获取到任务则启动一个 goroutine 进行入库操作 go func(t Task) { f := bson.M{ \"_id\": t.ID, } u := bson.M{ \"$set\": bson.M{ \"age\": t.Age, }, } c := GetMDBCollection(\"test\", \"demo\") c.UpdateOne(context.TODO(), f, u) // c 是 mongo 连接 }(t) }}func main() { InitMDB() TaskChan = make(chan Task, 1) Demo()} 通过启动协程的方式, 减少 mongo 等待时间, 这样虽然能很快的获取任务, 但是对于 mongo 的 c 数量, 并不能进行控制, 可能因为数据库连接数过多导致更新失败 使用 mongo bulk 其实在 mongo 中, 已经提供了一次交互批量执行命令的功能, 就是 mongo bulk Bulk() — MongoDB Manual 在官方文档中, 已经在一开始注明了mongo 在3.2版本之后新增了封装的bulkWrite() Starting in version 3.2, MongoDB also provides the&nbsp;db.collection.bulkWrite()&nbsp;method for performing bulk write operations. bulkWrite()相比于很早的bulk(), 有更高的封装, 比如对于一次执行过多的操作, 会自己进行切割分为几次执行, 因此, 更推荐使用bulkWrite(), 我们下面的 Demo, 也全部使用bulkWrite()进行演示 bulkWrite db.collection.bulkWrite() — MongoDB Manual 我们将代码修改如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package mainimport ( \"context\" \"fmt\" \"go.mongodb.org/mongo-driver/bson\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\")var mongoClient *mongo.Clientfunc InitMDB() error { // Set client options clientOptions := options.Client().ApplyURI(\"mongodb://user:pwd@127.0.0.1:15000/test?replicaSet=replica\") // Connect to MongoDB client, err := mongo.Connect(context.TODO(), clientOptions) if err != nil { fmt.Println(err) return err } // Check the connection err = client.Ping(context.TODO(), nil) if err != nil { fmt.Println(err) return err } mongoClient = client return nil}func GetMDBCollection(dataBase, collection string) *mongo.Collection { return mongoClient.Database(dataBase).Collection(collection)}type Task struct { ID primitive.ObjectID Age int}var TaskChan chan Taskconst maxWrite = 3 // 最大的更新长度func Demo() { w := []mongo.WriteModel{} opt := options.BulkWriteOptions{} opt.SetOrdered(true) // 设置执行为顺序的 for t := range TaskChan { // 监听 chan, 有任务就处理 // 如果长度未达到规定的最大长度, 添加到 w 后等待下一次循环 // 长度达到最大长度时, 调用 mongo 执行语句 // NewUpdateOneModel: 更新一个文档 // SetFilter: 查找 // SetUpdate: 更新 // SetUpsert: 设置有则更新, 没有则插入, 设置为 false 则代表没有就不做操作 w = append(w, mongo.NewUpdateOneModel().SetFilter(bson.M{\"_id\": t.ID}).SetUpdate(bson.M{\"$set\": bson.M{\"age\": t.Age}}).SetUpsert(true)) if len(w) == maxWrite { // 使用 bulkWrite 更新多条语句 c := GetMDBCollection(\"teinfra_hs_log\", \"app\") r, err := c.BulkWrite(context.TODO(), w, &amp;opt) if err != nil { fmt.Println(err) } fmt.Println(r.UpsertedIDs) // 返回操作的 ID: map[0:ObjectID(\"625ad4eaee42d75d76203685\") 1:ObjectID(\"625ad4eaee42d75d76203686\") 2:ObjectID(\"625ad4eaee42d75d76203687\")] w = []mongo.WriteModel{} // 重新将 w 设置为空 } }}func set() { ts := []Task{ {ID: primitive.NewObjectID(), Age: 10}, {ID: primitive.NewObjectID(), Age: 11}, {ID: primitive.NewObjectID(), Age: 12}, } for _, v := range ts { TaskChan &lt;- v }}func main() { InitMDB() TaskChan = make(chan Task, 1) go set() Demo()} 以上是一次执行多次更新的 Demo 代码 而 bulkWrite() 不止只有 NewUpdateOneModel, 还有其他的诸如NewDeleteManyModel, NewReplaceOneModel, NewInsertOneModel 等等方法, 具体可以查看文档 db.collection.bulkWrite() — MongoDB Manual 和 mongo package - go.mongodb.org/mongo-driver/mongo - pkg.go.dev 但是细心的你可能很快会发现问题, 如果我们将最终发送的长度指标设置的很大, 而没有达到最大长度时就不会将数据发送到数据库, 那么如果突然某一时刻没有新的 task 了, 而存上的 task 因为长度不够没有发出去, 那么这些数据就很长时间没有落到数据库, 导致问题出现 于是我们可以考虑加入一个超时时间, 当时间到达超时时间或者达到指定长度, 都会发送到 mongo, 这样就解决了问题 bulkWrite 发送的触发机制 通过time.Tick来创建定时器, 通过定时器来进行隔一段时间发送一次的操作 然后通过判断切片长度来进行发送操作, 因为两个都不是使用 goroutine , 所以不会出现切片的资源竞争问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package mainimport ( \"context\" \"fmt\" \"time\" \"go.mongodb.org/mongo-driver/bson\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\")var mongoClient *mongo.Clientfunc InitMDB() error { // Set client options clientOptions := options.Client().ApplyURI(\"mongodb://user:pwd@127.0.0.1:15000/test?replicaSet=replica\") // Connect to MongoDB client, err := mongo.Connect(context.TODO(), clientOptions) if err != nil { fmt.Println(err) return err } // Check the connection err = client.Ping(context.TODO(), nil) if err != nil { fmt.Println(err) return err } mongoClient = client return nil}func GetMDBCollection(dataBase, collection string) *mongo.Collection { return mongoClient.Database(dataBase).Collection(collection)}type Task struct { ID primitive.ObjectID Age int}var TaskChan chan Taskconst maxWrite = 1000 // 最大的更新长度const maxWiteTime = time.Millisecond * 300 // 如果最近300ms没有更新且有需要更新的数据则更新一次func bulk(writes []mongo.WriteModel, opt options.BulkWriteOptions) { // 使用 bulkWrite 更新多条语句 c := GetMDBCollection(\"teinfra_hs_log\", \"app\") r, err := c.BulkWrite(context.TODO(), writes, &amp;opt) if err != nil { fmt.Println(err) } fmt.Println(r.UpsertedIDs) // 返回操作的 ID: map[0:ObjectID(\"625ad4eaee42d75d76203685\") 1:ObjectID(\"625ad4eaee42d75d76203686\") 2:ObjectID(\"625ad4eaee42d75d76203687\")]}func Demo() { w := []mongo.WriteModel{} opt := options.BulkWriteOptions{} opt.SetOrdered(true) // 设置执行为顺序的 ticket := time.NewTicker(maxWiteTime) // 设置定时器, 每 maxWiteTime 触发一次 chan for { select { case t, ok := &lt;-TaskChan: if !ok { fmt.Println(\"down\") ticket.Stop() // 关闭定时器防止内存泄露 return } // 如果长度未达到规定的最大长度, 添加到 w 后等待下一次循环 // 长度达到最大长度时, 调用 mongo 执行语句 // NewUpdateOneModel: 更新一个文档 // SetFilter: 查找 // SetUpdate: 更新 // SetUpsert: 设置有则更新, 没有则插入, 设置为 false 则代表没有就不做操作 w = append(w, mongo.NewUpdateOneModel().SetFilter(bson.M{\"_id\": t.ID}).SetUpdate(bson.M{\"$set\": bson.M{\"age\": t.Age}}).SetUpsert(true)) if len(w) == maxWrite { bulk(w, opt) w = []mongo.WriteModel{} } case &lt;-ticket.C: // 300ms 触发一次 if len(w) != 0 { // 如果 w 有值, 则提交给 mongo bulk(w, opt) w = []mongo.WriteModel{} } } }}func set() { ts := []Task{ {ID: primitive.NewObjectID(), Age: 10}, {ID: primitive.NewObjectID(), Age: 11}, {ID: primitive.NewObjectID(), Age: 12}, } for _, v := range ts { TaskChan &lt;- v }}func main() { InitMDB() TaskChan = make(chan Task, 1) go set() Demo()} 这样就可以正常的运行了 QA 应该使用 bulkWrite 而不是 bulk bulkWrite 更推荐使用, builWrite 相比于 bulk+run 的方式, 更加上层, 比如针对一次 操作的组数量超过 maxWriteBatchSize 的时候, run 会直接报错, 而 Write 会自己切分 mgo 不支持 bulkWrite, 结合上面的项目更新状况, 新的项目应当使用 mongo package - go.mongodb.org/mongo-driver/mongo - pkg.go.dev 有序和无序 db.collection.bulkWrite() — MongoDB Manual 有序时, mongo 会按照列表顺序, 一步一步执行代码, 如果某个语句出错, 剩下的语句不会执行, 直接停止 无序时, mongo 会自己进行并发执行, 不保证执行顺序, 其中某几个错误不会造成其他的执行停止 有序时速度更慢, 但是对数据的处理可能更加符合开发者预期, 如果你在一个 bulk 中对某个文档进行多次修改, 如果使用无序, 并不能保证最后的结果符合列表中的顺序,是否使用顺序执行, 要根据具体业务分析处理 不要在 bulkWrite 中进行创建表操作 不要在 bulk 中对不存在的表进行操作, 尽管在有些mongo版本中, 她不会抛出异常 错误返回 如果在 bulk 一次运行中, 返回的错误信息大于1M, 则 mongo 会将其余的错误信息全部设置为空返回, 所以根据之前的列表上限来讲, 可能将每次执行的 list 长度设置为1-3k 比较合适","link":"/2022/04/14/mongo_bulk/"},{"title":"mongo 初探触发器","text":"前言 mongo 作为出名的 nosql 数据库, 随着版本的迭代, 被越来越多的开发者所接受, DB-Engines Ranking - popularity ranking of database management systems 而我们今天来初探一下 mongo 的触发器功能, 并编写一个 DEMO 来实现 mongo 指定表的数据变更记录存储 触发器与 oplog 顾名思义, 触发器就是注册事件通知到 mongodb 中, 当指定的情况发生时, mongodb 会自动触发开发者注册的代码, 进行若干逻辑处理. mongo 的触发器使用的是 oplog 的方式, oplog 是 mongo 中为了实现集群中的数据同步出现的概念, 与 mysql 类似, mongo 的多节点之间的数据同步通过操作 oplog 同步来完成: Replica Set Data Synchronization — MongoDB Manual 而触发器就注册在 oplog 的监听这里, 实际上触发器监听的是 oplog 的释出节点, 因此, 需要明确的是, 在触发器被触发时, 这个变更的操作已经落地到了数据库中, 而触发器事件并不会告知你之前的数据: Getting the previous data in a database trigger - MongoDB Realm / Functions &amp; Triggers - MongoDB Developer Community Forums. 同样, 因为 oplog 是为了集群模式中进行数据同步出现的, 因此触发器的注册必须前提是该 mongodb 是集群分片模式, 不过, mongodb 支持在单机之上设置该模式, 具体可查看: Using Change Streams in a standalone database - Ops and Admin / Replication - MongoDB Developer Community Forums 是否应该使用触发器 只有当你确定需要使用触发器的时候, 才应该考虑使用触发器, 只有在非常特定的情况下, 使用触发器才合适. 触发器是由 mongo 本身进行调用, 但是很多业务可能只关注业务本身, 没有必要将逻辑放置在 mongo 调用部分 前面说到, 触发器在触发时, 新的数据已经落地了, 如果你需要记录老的数据, 需要从别的方式入手, 这样使用触发器的理由是否足够大? 如果承载触发器逻辑的代码程序本身是分布式的, 多个, 那么每个记录会触发多次处理逻辑, 是否已经思考过这种情况可能出现的问题和解决方案? 触发器的支持版本 分片模式的 mongodb mongodb 版本 &gt;= 3.6 模拟需求 假设需求如下: 监听指定表的数据 可设置字段白名单, 白名单内的字段发生变动才记录 记录老的数据和新的数据 记录 插入/更新/删除 记录由谁进行改动 区分代码自动修改与管理员手动修改 设计记录表结构 为满足需求, 设计操作日志记录结构如下 123456789101112type ChangeLog struct { ID primitive.ObjectID `bson:\"_id\"` ChangeID primitive.ObjectID `bson:\"change_id\"` // 操作的 document _id DB string `bson:\"db\"` Coll string `bson:\"coll\"` UserID *primitive.ObjectID `bson:\"uesr_id\"` // 当程序操作, 此字段为空 CreatedAt time.Time `bson:\"created_at\"` Type string `bson:\"type\"` // 操作类型 Fileds string `bson:\"fileds\"` // 字段 Old string `bson:\"old\"` // 老的值 New string `bson:\"new\"` // 新的值} 设计监听的表结构 为满足记录字段由谁修改, 需要在需要监听的表新增字段updated_by, 当用户手动修改时, 务必将该字段设置为更改人的_id 当程序自动更改时, 务必将该字段设置为nil 例如表 demo 的结构如下 1234567type Demo struct { ID bson.ObjectId `bson:\"_id\"` IP string `bson:\"ip\"` User string `bson:\"user\"` Time time.Time `bson:\"time\"` UpdatedBy *bson.ObjectId `bson:\"updated_by\"` // 务必为地址} 其中, 我们对字段ip和user进行监听 触发器注册 本篇代码依旧使用 mongo 自己维护的 go 包 mongodb/mongo-go-driver: The Go driver for MongoDB (github.com) 而不是 mgo, 具体原因查看我之前的 mongo bulk 部分, 另外, 实际使用发现 mgo 对触发器支持并不理想, 并且预留的 example 并不准确, 这与 mgo 早已经停止更新有关. 直接放代码: 123456789101112131415161718192021222324func SetAndListenTrigger(db, table string, fileds []string) { // conn := GetMDB().Database(db) // 这是监听整个数据库, 可通过回调的字段判断哪张表和字段变动 conn := GetMDBCollection(db, table) // 监听某张表 s, err := conn.Watch(context.TODO(), mongo.Pipeline{}, options.ChangeStream().SetFullDocument(options.UpdateLookup)) // 设置监听所有事件, 如需修改可参照 https://www.mongodb.com/docs/manual/changeStreams/ // UpdateLookup if err != nil { log.Fatalln(err) } for { // for 监听每一个事件 if ok := s.Next(context.TODO()); !ok { log.Println(err) continue } fmt.Println(s.Current) // 这里是具体的事件内容 changeDoc := ChangeDoc{} if err := s.Decode(&amp;changeDoc); err != nil { // 解析 body log.Println(err) continue } changeDoc.Parse(fileds) // 交给 parse 处理 }} 主要使用 Watch 设置触发器, 当获取到具体的消息后, 解析数据 事件结构体 事件结构体可参照 Change Events — MongoDB Manual 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type Truncated struct { Field string `bson:\"field\"` NewSize int `bson:\"newSize\"`}type Update struct { Updated map[string]interface{} `bson:\"updatedFields\"` // 更新字段 Removed []string `bson:\"removedFields\"` // 删除字段 TruncatedArrays []Truncated `bson:\"truncatedArrays\"`}type Source struct { Coll string `bson:\"coll\"` // 来源表 DB string `bson:\"db\"` // 来源库}type OpID struct { Data string `bson:\"_data\"`}type Goal struct { Coll string `bson:\"coll\"` DB string `bson:\"db\"`}type SID struct { ID string `bson:\"id\"` UID string `bson:\"uid\"`}type Key struct { ID primitive.ObjectID `bson:\"_id\"`}// 格式参照 https://www.mongodb.com/docs/manual/reference/change-events/type ChangeDoc struct { ID OpID `bson:\"_id\"` OperationType string `bson:\"operationType\"` FullDocument map[string]interface{} `bson:\"fullDocument\"` NS Source `bson:\"ns\"` To Goal `bson:\"to\"` DocumentKey Key `bson:\"documentKey\"` UpdateDescription Update `bson:\"updateDescription\"` ClusterTime time.Time `bson:\"clusterTime\"` TxnNumber int `bson:\"txnNumber\"` LsID SID `bson:\"lsid\"`} DEMO 至此, 我们大致将代码流程整理完成, 先注册触发器, 然后对回调信息进行解析, 通过获取updated_by来判断是否是手动更新, 通过查询操作日志的该 ID 该 字段的最后一次更新记录来确认最后一次更新的数据, 来当做老的数据 demo 代码完全版如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376package mainimport ( \"context\" \"fmt\" \"log\" \"os\" \"os/signal\" \"time\" \"go.mongodb.org/mongo-driver/bson\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\")/*mongo 连接部分*/var mongoClient *mongo.Clientvar MongoAddress = \"mongodb://teinfra_hs_log:xxx@127.0.0.1:8000,1127.0.0.2:8000/teinfra_hs_log?replicaSet=replica\"func InitMDB() error { // Set client options clientOptions := options.Client().ApplyURI(MongoAddress) // Connect to MongoDB client, err := mongo.Connect(context.TODO(), clientOptions) if err != nil { log.Fatalln(err) return err } // Check the connection err = client.Ping(context.TODO(), nil) if err != nil { log.Fatalln(err) return err } mongoClient = client return nil}func GetMDB() *mongo.Client { return mongoClient}func GetMDBCollection(dataBase, collection string) *mongo.Collection { return mongoClient.Database(dataBase).Collection(collection)}/*trigger and parse 部分*/var ( UPDATE = \"update\" DELETE = \"delete\" INSERT = \"insert\")type Truncated struct { Field string `bson:\"field\"` NewSize int `bson:\"newSize\"`}type Update struct { Updated map[string]interface{} `bson:\"updatedFields\"` // 更新字段 Removed []string `bson:\"removedFields\"` // 删除字段 TruncatedArrays []Truncated `bson:\"truncatedArrays\"`}type Source struct { Coll string `bson:\"coll\"` // 来源表 DB string `bson:\"db\"` // 来源库}type OpID struct { Data string `bson:\"_data\"`}type Goal struct { Coll string `bson:\"coll\"` DB string `bson:\"db\"`}type SID struct { ID string `bson:\"id\"` UID string `bson:\"uid\"`}type Key struct { ID primitive.ObjectID `bson:\"_id\"`}// 格式参照 https://www.mongodb.com/docs/manual/reference/change-events/type ChangeDoc struct { ID OpID `bson:\"_id\"` OperationType string `bson:\"operationType\"` FullDocument map[string]interface{} `bson:\"fullDocument\"` NS Source `bson:\"ns\"` To Goal `bson:\"to\"` DocumentKey Key `bson:\"documentKey\"` UpdateDescription Update `bson:\"updateDescription\"` ClusterTime time.Time `bson:\"clusterTime\"` TxnNumber int `bson:\"txnNumber\"` LsID SID `bson:\"lsid\"`}func ValueParser(row interface{}) string { // 根据类型断言输出合适的 string 供存储 // TODO 根据更多的情况进行补充 switch row := row.(type) { case nil: return \"\" case int: return fmt.Sprintf(\"%d\", row) case string: return row case bool: return fmt.Sprintf(\"%v\", row) case primitive.ObjectID: return row.Hex() case time.Time: return row.String() default: log.Printf(\"unsupport row: %v\\n\", row) return fmt.Sprintf(\"%v\", row) }}// 解析新增参数func (c *ChangeDoc) InsertParse(fileds []string) { // 获取操作人 userID := func() *primitive.ObjectID { i, ok := c.FullDocument[\"updated_by\"] // 新增时, 字段都会在 full 里 if !ok { return nil } o, ok := i.(primitive.ObjectID) // 类型断言 if !ok { log.Printf(\"id validate err: %v\", i) return nil } return &amp;o }() for _, f := range fileds { // 只关注需要关注的字段 ff, ok := c.FullDocument[f] if !ok { log.Printf(\"not find filed: %s\\n\", f) continue } l := ChangeLog{ ID: primitive.NewObjectID(), ChangeID: c.DocumentKey.ID, DB: c.NS.DB, Coll: c.NS.Coll, Type: INSERT, CreatedAt: time.Now(), Fileds: f, UserID: userID, } l.New = ValueParser(ff) fmt.Printf(\"%+v\\n\", l) // 新增时, old 字段为空 ChangeChan &lt;- l }}// 解析删除参数func (c *ChangeDoc) DeleteParse(fileds []string) { // 真删除时, 无法携带更多信息 // 每个关注的字段都是删除, 因此保存多条记录 for _, f := range fileds { l := ChangeLog{ ID: primitive.NewObjectID(), ChangeID: c.DocumentKey.ID, DB: c.NS.DB, Coll: c.NS.Coll, Type: DELETE, Fileds: f, New: \"\", CreatedAt: time.Now(), } // 从记录表中获取最新的字段值作为 old old, err := GetFiledsLastValue(l.DB, l.Coll, l.Fileds, l.ChangeID) if err != nil { log.Println(err) old = \"\" } l.Old = old ChangeChan &lt;- l }}// 更新参数func (c *ChangeDoc) UpdateParse(fileds []string) { userID := func() *primitive.ObjectID { i, ok := c.FullDocument[\"updated_by\"] // 防止 mongodb 对相同value多次更新优化为不更新, 从 full 里拿 if !ok { log.Println(\"not find updated_by\") return nil } o, ok := i.(primitive.ObjectID) if !ok { log.Printf(\"id validate err: %v\\n\", i) return nil } return &amp;o }() for _, f := range fileds { // 只关注需要关注的字段 ff, ok := c.UpdateDescription.Updated[f] // 判断 updated里是否有 key if !ok { log.Printf(\"not find filed: %s\\n\", f) continue } l := ChangeLog{ ID: primitive.NewObjectID(), ChangeID: c.DocumentKey.ID, DB: c.NS.DB, Coll: c.NS.Coll, Type: UPDATE, CreatedAt: time.Now(), Fileds: f, UserID: userID, } l.New = ValueParser(ff) old, err := GetFiledsLastValue(l.DB, l.Coll, l.Fileds, l.ChangeID) if err != nil { log.Println(err) old = \"\" } l.Old = old fmt.Printf(\"%+v\\n\", l) // 新增时, old 字段为空 ChangeChan &lt;- l } for _, f := range fileds { // 只关注需要关注的字段 // 有可能是将某个字段删除了 // 删除则没有新的 value for _, rmf := range c.UpdateDescription.Removed { if rmf == f { l := ChangeLog{ ID: primitive.NewObjectID(), ChangeID: c.DocumentKey.ID, DB: c.NS.DB, Coll: c.NS.Coll, Type: DELETE, // 在更新时删除某个字段, 作为删除 CreatedAt: time.Now(), Fileds: f, UserID: userID, } old, err := GetFiledsLastValue(l.DB, l.Coll, l.Fileds, l.ChangeID) if err != nil { log.Println(err) old = \"\" } l.Old = old fmt.Printf(\"%+v\\n\", l) // 新增时, old 字段为空 ChangeChan &lt;- l } } }}// 解析 oplog 数据func (c *ChangeDoc) Parse(fileds []string) { // 格式参照 https://www.mongodb.com/docs/manual/reference/change-events/ switch c.OperationType { case \"insert\": c.InsertParse(fileds) case \"update\": c.UpdateParse(fileds) case \"delete\": c.DeleteParse(fileds) default: // TODO }}/*调度部分*/var ChangeLogTable = \"change_log\"var Database = \"teinfra_hs_log\"var ChangeChan chan ChangeLogtype ChangeLog struct { ID primitive.ObjectID `bson:\"_id\"` ChangeID primitive.ObjectID `bson:\"change_id\"` // 操作的 document _id DB string `bson:\"db\"` Coll string `bson:\"coll\"` UserID *primitive.ObjectID `bson:\"uesr_id\"` // 当程序操作, 此字段为空 CreatedAt time.Time `bson:\"created_at\"` Type string `bson:\"type\"` // 操作类型 Fileds string `bson:\"fileds\"` // 字段 Old string `bson:\"old\"` // 老的值 New string `bson:\"new\"` // 新的值}func GetFiledsLastValue(db, coll, fileds string, changeID primitive.ObjectID) (string, error) { // 连接到当前表 conn := GetMDBCollection(Database, ChangeLogTable) f := bson.M{ \"db\": db, \"coll\": coll, \"fileds\": fileds, \"change_id\": changeID, } l := ChangeLog{} if err := conn.FindOne(context.TODO(), f, options.MergeFindOneOptions().SetSort(bson.M{\"_id\": -1})).Decode(&amp;l); err != nil { log.Println(err) return \"\", err } return l.New, nil}func Listen() { ChangeChan = make(chan ChangeLog) for v := range ChangeChan { conn := GetMDBCollection(Database, ChangeLogTable) if _, err := conn.InsertOne(context.TODO(), v); err != nil { log.Println(err) } }}var taggerFileds = []string{\"ip\", \"user\"} // 感兴趣的字段, 不在list 中的字段发生变更时不记录日志var taggerTable = \"demo\" // 感兴趣的表func SetAndListenTrigger(db, table string, fileds []string) { for { // 防止网络波动导致的 timeout, 如果出现问题, 重新获取conn监听 // conn := GetMDB().Database(db) // 这是监听整个数据库, 可通过回调的字段判断哪张表和字段变动 conn := GetMDBCollection(db, table) // 监听某张表 // options.UpdateLookup 作用是传送的数据加上了本document当前最新的所有数据, 目的是为了解决用户 a 连续两次更新同一条数据, 第二次更新 mongodb 不会将 updated_by 带上的问题 // options.UpdateLookup 返回的是已经更新后的新数据, 并不是老数据 s, err := conn.Watch(context.TODO(), mongo.Pipeline{}, options.ChangeStream().SetFullDocument(options.UpdateLookup)) // 设置监听所有事件, 如需修改可参照 https://www.mongodb.com/docs/manual/changeStreams/ // UpdateLookup if err != nil { // 网络断开, 导致无法连接, 1s 后重试 log.Println(err) time.Sleep(time.Second * 1) continue } for { // for 监听每一个事件 if ok := s.Next(context.TODO()); !ok { log.Println(err) // 重新监听 break } fmt.Println(s.Current) // 这里是具体的事件内容 changeDoc := ChangeDoc{} if err := s.Decode(&amp;changeDoc); err != nil { // 解析 body log.Println(err) // 重新监听 break } changeDoc.Parse(fileds) // 交给 parse 处理 } }}func main() { InitMDB() go Listen() time.Sleep(time.Second * 5) go SetAndListenTrigger(Database, taggerTable, taggerFileds) _, cancel := context.WithCancel(context.Background()) defer cancel() // 关闭管道 cs := make(chan os.Signal, 1) signal.Notify(cs, os.Interrupt) &lt;-cs}","link":"/2022/05/23/mongo_trigger/"},{"title":"MySQL 常问知识点(简略)","text":"前言 稍微整理一下吧, 因为平时关注这方面不多, 所以不会很深入 事务隔离级别 事务中可能遇到的问题 脏读 同一时间有两个事务 A 和 B, A 对某条数据进行修改或增加, 在 B 中也体现出来, 但是 A 可能回滚, 导致 B 获取的数据可能是脏的 可重复读 有事务 A, 在 A 开始后, 数据库中的某些数据发送变更, 但是在 A 中读取相关数据永远保持在 A 刚启动的时候不会自己更改, 通常针对数据的更新 不可重复读 有事务 A, 在 A 开始后, 数据库中的某些数据发送变更, 而 A 事务中查询到的相关数据也会随之更改, 通常针对数据的更新 幻读 事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。 事务隔离级别 读未提交 不加锁, 速度快, 但是不加锁会导致 脏读/不可重复读/幻读 的问题出现 读提交 一个事务只能督导其他事务已经提交过的数据 可能出现 不可重复读/幻读 的问题 可重复读(默认) 可重复读是 MySQL 的默认事务隔离级别 在事务启动之后, 对数据的所有改动都不会体现到事务中, 因此对数据的新增也不会出现在其中 可重复读可能出现 幻读 的问题 串行化 是最高的隔离级别, 会在事务过程中涉及到的数据都加上行锁, 多事务串行执行, 效率很堵但是安全, 同时不存在数据的不一致问题 InnoDB 和 Myisam 的区别 InnoDB 支持事务, Myisam 不支持 InnoDB 支持行级锁, Myisam 只支持表级 InnoDB 支持外键, Myisam 不支持 InnoDB 是索引组织表, Myisam 是堆表 默认为 InnoDB 慢查询 时间 10s, 但是使用 GORM 这种当大于200ms 就会有调试日志输出 查找问题 Explain: 可以输出 MySQL 内部是如何使用索引来处理查询语句的, 可以作为找慢查询的原因时使用 视图: 创建视图来查看 解决方法 数据量过大考虑分表 查看是否查询了额外的数据, 对语句进行分析和重写 查看是否命中了索引, 优化表结构 如果每次都是重复的查询数据, 考虑加入缓存 不需要查询出的列数据, 进行 sql 优化 查询不需要的数据, 使用LIMIT进行跳过 drop/delete/truncate 的区别 drop 直接删除表 truncate 清空表数据, 当再次新建时id 从1开始 delete 删除表里的数据, 可以加where来进行筛选 连接种类 全连接: join/inner join 左连接: left join 右连接: right join 交叉连接: cross join 三范式 1NF 作为关系型数据库, 必须要有主键, 每一个字段必须保持原子性, 不能再继续分割 2NF 作为关系型数据库, 所有非主键字段完全的依赖他的主键 3NF 所有的非主键字段和他的主键字段之间不能产生传递依赖, 必须是直接依赖关系, 传递依赖可以再启用一张表来做关联 数据库优化方法 创建高性能索引 根据业务来设计符合要求的索引 优化查询性能 设计表时要充分考虑表结构和字段 查询时尽量命中索引 优化服务器设置 适当的修改数据库配置 负载均衡 存储过程和触发器 存储过程 将重复度高的 sql 语句预先存储到数据库中, 调用时通过填充数据来执行 sql, 以提高效率 触发器 触发器顾名思义, 就是在数据库中设置某个条件时自动触发某些 sql, 因为会导致效率变慢, 尤其是多条命中时, 所以一般不使用 锁与死锁 本数据库有三种锁(InnoDB) 表级锁 表级锁的使用很少, 因为他会将整个表锁住, 效率低, 同时因为将整个表锁住, 同一时间也就不会有第二个事务进行修改操作, 避免出现死锁问题 行级锁 数据库本身并不支持行级锁, InnoDB 是通过引擎层自己实现的, 行级锁的效率更高, 但是可能会出现死锁的情况, 在 InnoDB 中, 行锁在需要对某条数据进行修改时加上, 在事务结束时才会释放掉, 而如果有两个事务以两个顺序对多个数据进行加锁, 就会导致死锁, 例如 事务1 事务2 update t set k=k+1 where id = 1 (加锁行1) update t set k=k+1 where id = 2 (加锁行2) update t set k=k+1 where id = 2 (等待行锁2释放) update t set k=k+1 where id = 1 (等待行锁1释放) 我们在对数据库操作时, 应该尽可能的考虑到锁冲突问题, 遇到事务必须慎重, 如果有可能加行锁的操作, 可以考虑以下几种方式规避 尽量的将加行锁操作放到事务后面 对于事务中对多个表进行处理时, 约定好使用一致的处理顺序 以批方式处理多个数据时, 先对数据进行排序 可以控制事务的并发数量 将锁提升为排他锁, 使用 for update 语句 将锁提升为表锁, 例如在更新时更新条件没有索引会自动加表锁 页面锁 存储引擎为 BerkeleyDB 才会出现, 没有使用过 索引 索引并不是越多越好 索引优点: 加快查询速度(命中索引的前提下) 索引缺点: 索引需要占据一定的空间和资源, 同时索引会加重插入/删除/修改数据的负担 索引可以增加数据的查找速度, 索引是在引擎层进行实现的, 本数据库提供四种索引: B-Tree: 最常见的索引类型, 大部分引擎都支持 HASH: Memory 支持, 使用场景简单 R-Tree: 空间索引, MyISAM 独有, 常见用于地理空间数据类型 Full-text: 全文索引, MyISAM 独有 对于引擎对索引类型的支持如下 索引 MyISAM InnoDB Memory B-Tree Y Y Y HASH N N Y R-Tree Y N N Full-Text N Y(5.6+) N 索引类型 普通索引 最基本的索引类型, 没有唯一性之类的限制 UNIQUE(唯一索引) 唯一的, 不允许重复的索引 复合索引 多个列当做一个索引, 用于组合搜索, 效率比索引合并快 主键(特殊) 唯一的, 每个表只能有一列主键 单列索引和联合索引 单列索引 指的就是为单独的某个列设置索引 联合索引 将多个列合到一起作为一个索引, 创建联合索引等于创建了从左到右的多个索引. 例如: 创建联合索引a+b+c 等于创建了三个索引, 分别是 单列索引 a, 联合索引a+b, 联合索引 a+b+c 索引合并 当查询语句的WHERE是AND的时候, 如果有多个索引, 会自动查找一个最佳的索引使用 而当查询语句通过OR连接时, MySQL会使用索引合并技术, 将命中的几个索引的范围扫描合并成一个新的索引(只限于单表), 如果数据量不大, 不会将索引合并, 因为会影响一部分效率 什么时候需要索引 频繁的作为查询条件的字段应该创建索引 唯一性很差的字段不适合作为单独索引, 即使他很频繁的作为查询条件(例如用户表中的性别字段这种重复性很高的) 更新非常频繁的字段不适合创建索引 不会出现在WHERE中的字段不应该创建索引 数据量比较大, 比如表中的数据量大于 1w 条 索引选择性高(不重复的索引值/表记录数) 选择索引 在WHERE子句中出现的列, 在join子句中出现的列可以设置索引 索引列的基数越大, 效果越好 如果一个列长度为200, 而前10个字符是多数唯一的, 可以考虑对这个列的前10个字符做短索引, 节省索引空间, 也可以提高查询速度 牢记索引的最左前缀原则(详见下条) 为什么 MySQL 索引使用 B+树 B-tree B 树不管是叶子结点还是非叶子节点, 都会保存数据, 会导致在非叶子节点中可以保存的指针数量变少了, 指针少的时候要保存大量的数据, 增加树的高度, 导致 IO 操作变多了, 降低查询性能. Hash Hash 没有顺序, 查询的 IO 复杂度高 二叉树 二叉树的高度不均匀, 不能自平衡, 查找效率跟数据相关, 数据越大树越高, IO 的代价就很高 红黑树 数据量越大树的高度越高, IO 的代价很高 平衡二叉树 平衡二叉树的深度很大, 因为平衡二叉树一个节点最多两个子节点, 导致同样的数据量, 平衡二叉树的深度比 B+tree 的要深很多, 导致查询会变慢. 最左前缀 MySQL 一条查询只能使用一个索引, 当出现多个索引时, 会使用范围最小的那个索引 InnoDB使用 B+ 树进行数据存储, 所以要想命中索引, 必须按照联合索引当初建立时的顺序来, 不然无法命中索引, 另外, 范围查询(&lt;, &gt;)也不命中索引 比如说有表 user, 下面有字段 name 是索引 一条语句 SELECT * FROM user WHERE name='ak' AND age=15 分两步 从表中寻找 name 为 ak 的数据 再从结果中寻找 age 为 15的数据 因为name为索引, 所以步骤1很快速完成, 但是步骤2就没有索引, 可以优化 如果这一条语句是很频繁的查询, 可以将name和age合并使用联合索引, 提高这个语句的查询效率 于是我们将索引修改为name 和 age, ALTER TABLE user ADD INDEX name_age (name, age) 因为你在设置联合索引时, 总归有个先后, 例如本例就是name+age, 而MySQL的最左查询会从最左开始解析, 那么过程如下 重新执行语句 SELECT * FROM user WHERE name='ak' AND age=15 这样就会将联合索引生效, 提高效率, 他的执行如下 找到name='ak',命中了name和name+age 找到age=15, 命中了name+age索引 但是如果我们更改WHERE的顺序为 SELECT * FROM user WHERE age=15 AND name='ak' 则无法命中索引, 这是为什么呢? 找到age=15, 发现索引只有name和name+age, 因为没有以 age开头的, 所以本条没有命中索引 找到name='ak' 没有索引 所以就没有命中索引 数据库中存在索引但是没有使用 IN IN会扫描全表, 慎重使用 NOT IN 与IN一样会扫描全表, 考虑使用 not exists或者其他方式规避 &lt;&gt; 不等于符号, 考虑修改语句, 比如a&lt;&gt;0修改为a&gt;0 or a&lt;0 IS NULL和IS NOT NULL 判断字段是否为空, 一般不会应用索引, b 数索引不索引空值, 考虑修改语句, 比如a IS NOT NULL修改为a&gt;0 命中的数据大于总数50% 命中索引但是命中的数据数量超过了表内数据总数量的50%, 也会直接全表扫描, 因为此时全表扫描比索引快(大概率是索引的设计有问题) LIKE LIKE操作符可以匹配通配符查询, 使用%可以查询几乎任意范围的匹配, 注意, 以%开头则不会引用索引, 比如%TEXT%不会引用索引, 而TEXT%可以引用范围索引 UNION UNION用来将多个SELECT查询出的结果集进行合并. 因为是将多个结果进行合并, 也不会走索引, 但是因为其运行时是先取出若干个结果, 再去重, 因此可能会占用大量的资源, 不推荐使用 怎么判断是否命中索引 在 sql 前加EXPLAIN, 比如 EXPLAIN SELECT * FROM user WHERE age=15 AND name='ak' 然后查看输出的字段数据来判断 分库分表 什么是分库分表 分库 从单个数据库拆分成多个数据库, 将数据分散在多个数据库中 分表 从单张表拆分成多张表, 将数据散落在多张表中 为什么要分库分表 提升性能, 增加可用性 分库分表的前提是负载已经大到基本的数据库结构优化和缓存等机制都使用了还是有效率问题 由于分库分表会增加逻辑复杂性, 因此不到万不得已不推荐使用 提升性能 数据量越来越大, 数据库的查询 QPS 就越来越高, 数据库的压力和读写需要的时间也会越来越多, 业务效率的瓶颈就会变成数据库这里, 因此就需要对数据库进行优化 如果数据库的 QPS 过高了, 就需要考虑进行拆库, 通过分库来分担单个数据库的连接压力. 一般的, 单库的连接数最好不要超过1000 如果单表的数据超过了一定量级, 对这个表进行操作, 速度就会变慢(阿里的&lt;&lt;JAVA 开发手册&gt;&gt;提到每张表的数据不要超过500万行或者容量超过2G). 此时需要对表按照某个规则进行切分, 分为多个表, 来减少每个表的数据量, 恢复性能. 提高可用性 鸡蛋不能放在一个篮子里, 单个数据库如果发生了意外, 很有可能会丢失所有数据, 因此, 除了考虑使用 主从 等多节点部署之外, 也可以考虑拆分数据来解决问题, 比如我们的数据库宕机了, 那么: 单库部署的情况下, 数据库宕机, 会影响100%的数据, 而且数据恢复的耗时可能也很久 如果我们拆分成2个库, 部署在不同的机器, 如果其中一个宕机, 故障影响就是50%, 还有50%的数据可以继续提供服务, 同时恢复耗时受数据量影响也会缩短 需要注意, 拆库并不是无限制的, 这是牺牲了资源来提升性能和可用性, 要取舍, 毕竟资源总是有限的 怎样分库分表 三种切分方案 从上一节总结, 切分方案分为三类 切分方案 解决的问题 只分库 库读写 QPS 过高, 连接数不足了 只分表 单表数据量过大, 性能瓶颈 分库+分表 连接数不足+数据量过大 选择切分方案 关于系统架构, 都有一个共识就是避免过度设计, 只有确定业务量数据巨量, 或者真的遇到了瓶颈, 再考虑数据切分 分表: 可以根据 500w 行的标准按照逻辑分割进行拆分, 例如, 业务每个月插入的数据为400w 行, 就应该按照每月来进行拆分 分库: 可以按照每库1000个数据库连接按照逻辑进行拆分 如何切分 水平切分: 按照业务维度进行横向的切分, 也就是按行切分, 例如将用户表按照用户等级进行拆分, 将订单表按照创建月份进行拆分等等 垂直切分: 按照字段进行切分, 比如说订单表可能存在订单信息, 卖家买家信息, 支付信息, 可以通过字段拆分成三张表, 订单/买家/卖家 来减少容量 读写分离 读写分离也是为了提高速度和可用性 主从复制 搭建在多台服务器上的数据库系统, 将其中一台当做主数据库, 其他为从数据库, 实现主从同步. 其中主数据库负责进行写操作, 从数据库负责读操作, 这就将请求分流为多个部分, 来增加访问速度, 同时其中一台崩溃也避免了数据发生丢失 这里也说了, 读取是从服务器, 写入是主服务器, 那么他们是不同的物理服务器, 怎么实现的数据一致呢? 我们将主服务器命名为 A, 从服务器有一个为 B, 当用户在A插入数据时, 流程如下: 修改A本地的数据 将修改记录写入A的日志系统 发送给B B写入B的日志系统 B从B的日志系统中读取记录, 修改自己的数据 主从同步复制有三种方式: 同步复制: 用户写入A, A监控到从数据库B也修改完成后才返回成功 异步复制(默认): 只要A自己成功就返回成功 半同步复制: A自己和若干个从服务器中有一个成功就返回成功 读写分离 开源方案 读写分离有几个开源方案, 目前还活着的就是 mariadb-corporation/MaxScale：一个智能数据库代理。 (github.com), 虽然是 MariaDB出的, 但是也兼容 MySQL 当配置完成后, 所有数据库连接都设定为 MaxScale 的连接, MaxScale自己进行管理和分配即可, 还有 web 页面可以查看信息, 而且对于调用者来讲是无痛的, 开发者不需要关注里面的实现逻辑, 跟普通调用单机一样 自己控制 当然你也可以使用直连主从, 通过逻辑来进行读写分配, 只是比较 low, 优点是部署方便 什么是 MySQL 的 XA 事务 在分布式事务处理中, 遇到一个事务跨越了多张表, 就需要使用XA事务来完成整个事务的正确提交和回滚, 保证全局事务的一致性. 需要提前说明的是, 对于分布式数据库架构来讲, 都会有一个总控, 来接收用户的操作, 并通过一定的规则将其分配到具体的某个节点中 XA 事务的过程 例如, 事务的整体 SQL 如下 1234begin;insert into `user` values(\"user1\", 18);update `user` set `age`=19 WHERE `name` = \"user101\";commit; 根据步骤来解答 总控收到begin, 知道要开始事务 总控收到insert语句, 解析语句, 根据name的值, 计算出应该是分配到哪个节点中, 这里假设是节点1 总控向节点1发送语句xa start xid1开启一个xa事务, 这里的xid是总控生成的一个全局事务 id, 同时也将insert 语句发送到节点1 总控收到 update 语句, 同样的, 先根据name计算出数据保存的节点, 这里假设是节点2 此时总控会先发送xa start xid1, 因为都是属于一个事务. 所以这里使用相同的xid, 同时会向节点2发送 原来的 insert 和新的 update 两个语句. (这里为什么将不属于他节点的 insert 发送过去, 之后会说) 总控接受到了commit, 标识这个事务已经结束了, 准备提交 总控向节点1和节点2发送xa end xid1; xa prepare xid1语句, 告诉节点准备提交, 如果数据正常的走完, 那么节点会回复成功, 如果任何一个节点返回失败, 则向节点1和节点2发送xa rollbak xid1 进行事务的回滚 如果都返回成功, 总控会想节点1和节点2发送xa commit xid1 最终提交事务 MySQL5.6上 XA 事务的冲突问题 试想一下这样的场景 总控已经向节点1和节点2发送完了xa prepare xid1, 并且得到了成功的回复 总控向节点1发送xa commit xid1 , 并且成功了 总控向节点2发送xa commit xid1, 此时因为网络问题, 节点2出现了问题丢失了与总控的通讯 当网络恢复时, 或者节点2上线了, 此时 xa 的事务已经回滚了, 当总控 commit 时, 数据库实例已经找不到xid1这个事务 这里的问题是, xa prepare 没有严格的持久化, 当连接断开时, 这些事务会被回滚, 造成了数据丢失 MySQL5.7 的 XA 可靠性改进 MySQL5.7解决了这个问题, 在连接断开时这些数据会持久化保存下来 SQL 的四种语言 DDL 数据库定义语言 CREATE(创建) ALTER(修改) DROP(删除) TRUNCATE(清除) COMMENT(注释) RENAME(重命名) DML 数据操纵语言 SELECT(查询) INSERT(新增) UPDATE(更新) DELETE(删除) MERGE(合并) CALL(存储过程调用) EXPLAIN PLAN(性能分析) LOCK TABLE(锁表) DCL 数据库控制语言 GRANT(授权) REVOKE(取消授权) TCL 事务控制语言 SAVEPOINT(设置保存点) ROLLBACK(回滚) SET TRANSACTION(设置实务) MySQL 建表的约束条件 主键约束: 唯一, 非空 唯一约束: 唯一, 可空, 但是只能有一个空 检查约束: 列数据的 范围/格式 进行限制 默认约束: 列数据的默认值 外键约束: 两表间的关系连接 MySQL 执行查询的过程 客户端通过 TCP 连接发送查询请求到 MySQL 的连接器, 连接器进行权限验证和资源分配 查询是否存在缓存, 如果命中了缓存, 直接返回结果 分析和校验语法是否正确 优化语句, 处理是否使用索引, 生成执行计划 将执行计划提交给执行器, 将数据保存到结果集中, 同时将数据缓存在缓存中, 将结果返回给客户端 varchar和char区别 效率上char&gt;varchar 如果确定某个字段的值长度, 可以使用char, 否则使用varchar, 例如md5这种明确知道长度的就是char更好 char 定长字段, 在数据库设定时就确定了值的大小, varchar 不定长字段, 申请了最大长度, 而实际上占用的长度可能比最大长度小, 视值的真正长度而定, 实际占用的长度为(值长度+1, 最后1个字符表示本值长度) 存储过程的优缺点 存储过程经过预编译成了代码块, 执行效率比较高, 调用也比较方便 但是因为国内互联网的环境一般是寻求很快的迭代, 项目的生命周期往往较短, 人员的流动也比较大, 对于存储过程的管理繁琐且复杂, 复用性也没用把代码写在服务层那么好, 所以阿里的&lt;&lt;Java 开发手册&gt;&gt;也禁止使用存储过程. MySQL 的事务日志 Innodb 的事务日志包含两部分, redo log和undo log redo log redo log是为了事务的持久化而出现的 log, 当事务执行过程中, 将执行的任务写入redo中, 当有故障发生时, MySQL 重启后, 根据redo中的数据进行重做, 防止事务出现问题 undo log undo是为了将记录回滚到某个版本, 事务在未提交之前, 保存了未提交之前的版本数据, 方便事务回滚时对数据进行回复 MySQL 的 binlog binlog存储了所有数据库的结构变更和表内的数据变更的二进制日志. 记住是变更, 对数据的查询并不会记录在其中. 数据库的所有记录可以查看数据库的通用日志 事务中可以混合使用存储引擎吗 最好不要, 可以正常提交, 但是因为事务是由引擎实现的, 在回滚时可能因为数据不一致问题无法回滚 数据量很大的表如何优化查询速度 考虑分表 优化索引 使用redis进行数据缓存 使用 MySQL 缓存 主从复制, 读写分离 从业务上限制查询的范围 从业务上规定查询必须指定条件 数据量很大的表针对很大的分页处理 例如, 有表user, 每页10条数据, 用户查询到了第100000页, sql 语句类似于 1SELECT * FROM `user` WHERE age&gt;18 LIMIT 1000000, 10 因为 MySQL 分页查询不是跳过前1000000条数据, 而是读取到1000010 条数据, 所以导致这个查询非常的慢 可以将 sql 修改为 1SELECT * FROM `user` WHERE id in (SELECT id FROM `user` WHERE age&gt;18 LIMIT 1000000, 10) 这样虽然也查询到了1000010条数据, 但是因为索引覆盖了查询, 导致速度提升 或者说在业务中对超大的分页进行处理, 比如推测用户的需求是可能会点击下一页, 将下一页数据提前查询并存储到缓存中等 关联查询的优化 确定ON和USING子语句中是否含有索引 确保GROUP BY 和 ORDER BY 只有一个表中的列, 不然不会使用索引 数据库结构优化 如果表中有很多列, 考虑将表切分 对于经常联合查询的表, 考虑使用中间表来连接提高查询效率(将原来的联合查询修改为对中间表的查询) 合理的加入冗余字段(慎重) 回表 回表查询指的是, 需要扫描两次索引树, 效率比扫描一次索引树更低 如果查询条件为普通索引(辅助索引), 则需要先查找一遍辅助索引树, 得到对应的簇集索引键(主键), 再去簇集索引树中查找对应记录, 发生回表 普通索引指的是非主键索引","link":"/2022/01/21/mysql_interview/"},{"title":"&lt;&lt;玩转 vue3&gt;&gt;笔记(1)","text":"前言 学习前端势在必行, 这里是一个初学者(只写过 JS+BootStrap)学习 vue3 的学习笔记, 课程在 玩转 Vue 3 全家桶 (geekbang.org) 为什么是 vue3 前端发展历程 纯静态网页: 纯静态, 手动更新页面 模板语言网页: 直接嵌入后端数据, 数据更新需要重新刷新页面 ajax: 前端异步获取数据并动态刷新 jquery+bootStrap: 通过 jquery 操作 dom, bootStrap 做基本的响应式和栅格处理 angularJs+nodeJs: MVVM 模式, 前端可以入侵到后端, 数据驱动页面, 数据变化则页面自动变化, 而不需要操作 dom, 开发者只需要关注数据的变化, 对 dom 的修改由框架完成 百花齐放: angularJs/vue/react… 三大框架 angularJs vue react 实现原理 angular : 脏检查, 每次交互都检查数据是否变化, 从而更新 dom vue: 响应式, 对于每个需要变化的数据都建立一个 watcher 监听数据的属性, 有变化时才通知修改对应的 dom react: 虚拟 dom, 通过 js 来生成虚拟的 dom, diff 检测数据更新直接更改虚拟 dom, 更快速 vue 和 angular 区别 angular 通过 diff 来自己进行数据变化的感知, vue 框架本身在数据变化时会主动通知 vue 和 react 区别 vue为了实现数据感知, 需要在框架内生成若干 watcher, 数量多就影响性能. react 生成虚拟 dom, 每次需要对虚拟 dom 进行 diff 来得知数据变化, 当虚拟 dom 很大则影响性能 react 使用将虚拟 dom 分片的方式将 dom 切片, 在浏览器空闲时再进行 diff, 每次计算一片, 当浏览器需要计算时下次让给浏览器, 解决卡顿 vue2 引入了虚拟 dom, 取 react 之长, 对于组件之间的变化, 才通过 watcher 通知, 对于组件内的变化, 通过虚拟 dom 来更新, 组件数量不会很多, 解决了 watcher 多导致的性能问题, 同时, 每个组件都单独的虚拟 dom, 也避免虚拟 dom 大导致的性能问题 react 将 jsx 编译成 js 执行, 所以语法都是 js 本身的语法和特征 vue 是自己的语法, vue 通过语法检测数据是否是需要监听的, 在 vue3中做到了极致, vue3对代码进行精准的分类, 只有需要监听的数据更改才进行虚拟 dom 的修改, 不需要监听的数据, 越过了虚拟 dom 检测, 速度更快 小知识 Q: vue 在引入虚拟 dom 后, 需不需要 react 的分片来提高性能? A: 不需要, vue 的虚拟 dom 是组件级别, 所以虚拟 dom 不大, 进行 diff 不会有性能问题 清单应用 编写一个清单应用, 类似于各种 TODO 程序, 用户在输入框中写要做的事情, 回车会加入到下面的若干 TODO 列表中, 同时列表某一条可以点击完成, 呈现出不同的效果 思想的转变 接触过传统的 JS+BootStrop 的开发者来讲, 可能对于这种需求, 思路是找到输入框并进行监听, 当用户输入后, 先在 dom 中找到对应元素, 然后进行修改dom, 这种思路需要转变 对于 MVVM 方式的框架来讲, 我们只需要关注数据是怎么变化, 而不是 dom 怎么操作 列表的加载 我们先进行数据的展示, 之前说过, 我们只关注数据, 在 vue 中, 我们可以在 dom 中使用 {{}} 来进行已定义的数据展示, 使用 v-for可以循环列表类型的数据 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;!-- v-for 循环 todos, 每个值叫 todo, li 的值为每个 todo --&gt; &lt;li v-for=\"todo in todos\"&gt; {{todo}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 建立变量 App const App = { // data() 返回监听的变量 data() { return { todos: [\"吃饭\", \"睡觉\"], } }, } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;/html&gt; 数据的追加 MVVM 中, 数据的修改, 框架会自己监听并重新渲染 dom 使用@keydown.enter监听键盘回车事件, 执行方法addTodo 在这里, 你会发现, 当数据 todos 进行变化后, 相对应的 dom 会自己发生变化, 这就是 MVVM 的奇妙之处, 数据驱动页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 监听变量 title 的值--&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;!-- v-model 将 input 值绑定到变量 title --&gt; &lt;!-- @keydown.enter 在回车键时触发方法 addTodo --&gt; &lt;input type=\"text\" v-model=\"title\" @keydown.enter=\"addTodo\"&gt; &lt;ul&gt; &lt;!-- v-for 循环 todos, 每个值叫 todo, li 的值为每个 todo --&gt; &lt;li v-for=\"todo in todos\"&gt; {{todo}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 建立变量 App const App = { // data() 返回监听的变量 data() { return { title: \"\", todos: [\"吃饭\", \"睡觉\"], } }, // methods 设置方法 methods: { // 设置 addTodo 方法 addTodo() { // this 指的是自己, 也就是 App // 如果 title 为空, 不添加, 目的是防止无输入直接回车 if (this.title === \"\"){ return } this.todos.push(this.title) // 给 todos 列表新增一个值为用户输入的 title 值 this.title = \"\" // 将 title 设置为空 } } } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;/html&gt; 添加完成按钮和效果 TODO 都是可以进行选中完成的, 我们也要实现, 为了给每个 todo 添加是否完成的标识, 我们将 todo 的类型从字符串变成对象 还是那句话, 数据驱动页面, 当我们的 checkbox 的 checked 属性发生变化时, 也会重新渲染对应的 dom, 导致 class 也动态的增减 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 监听变量 title 的值--&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;!-- v-model 将 input 值绑定到变量 title --&gt; &lt;!-- @keydown.enter 在回车键时触发方法 addTodo --&gt; &lt;input type=\"text\" v-model=\"title\" @keydown.enter=\"addTodo\"&gt; &lt;ul&gt; &lt;!-- v-for 循环 todos, 每个值叫 todo, li 的值为每个 todo --&gt; &lt;li v-for=\"todo in todos\"&gt; &lt;!-- 当 type 为 checkbox 时, v-mode 绑定的变量如果是数组时, 作为 checkbox 的 value 使用, 当为 bool 时, 作为 checkbox 的 checked 值使用 --&gt; &lt;!-- 使用 todo.done 属性标识是否选中 --&gt; &lt;input type=\"checkbox\" v-model=\"todo.done\"&gt; &lt;!-- vue 中, : 用来传递数据, 这里的意思是, 如果 todo.done 为真, 则将 css done 传递给 class --&gt; &lt;span :class=\"{done:todo.done}\"&gt;{{todo.text}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 建立变量 App const App = { // data() 返回监听的变量 data() { return { title: \"\", todos: [ { done: false, text: \"吃饭\" }, { done: true, text: \"睡觉\" } ], } }, // methods 设置方法 methods: { // 设置 addTodo 方法 addTodo() { // this 指的是自己, 也就是 App // 如果 title 为空, 不添加, 目的是防止无输入直接回车 if (this.title === \"\") { return } this.todos.push({ done: false, text: this.title }) // 给 todos 列表新增一个值为用户输入的 title 值 this.title = \"\" // 将 title 设置为空 } } } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;style&gt; /* 颜色变灰, 中间加划线 */ .done { color: gray; text-decoration: line-through; }&lt;/style&gt;&lt;/html&gt; 添加统计 在页面添加未完成的数量和全部数量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 监听变量 title 的值--&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;!-- v-model 将 input 值绑定到变量 title --&gt; &lt;!-- @keydown.enter 在回车键时触发方法 addTodo --&gt; &lt;input type=\"text\" v-model=\"title\" @keydown.enter=\"addTodo\"&gt; &lt;ul&gt; &lt;!-- v-for 循环 todos, 每个值叫 todo, li 的值为每个 todo --&gt; &lt;li v-for=\"todo in todos\"&gt; &lt;!-- 当 type 为 checkbox 时, v-mode 绑定的变量如果是数组时, 作为 checkbox 的 value 使用, 当为 bool 时, 作为 checkbox 的 checked 值使用 --&gt; &lt;!-- 使用 todo.done 属性标识是否选中 --&gt; &lt;input type=\"checkbox\" v-model=\"todo.done\"&gt; &lt;!-- vue 中, : 用来传递数据, 这里的意思是, 如果 todo.done 为真, 则将 css done 传递给 class --&gt; &lt;span :class=\"{done:todo.done}\"&gt;{{todo.text}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 在 html 中写代码的方式虽然可行, 但是不推荐!, 并且性能不好! --&gt; &lt;div&gt; &lt;!-- .filter 对 todos 进行筛选, () 内是筛选规则, v 是每个 todo, 如果为 true 则此 v 筛选通过 --&gt; &lt;!-- 这里统计未完成数量, 因此对 v.done 进行反转, 如果 done 为 true, 反转为 false, 筛选失败, 反之成功 --&gt; {{todos.filter(v=&gt;!v.done).length}} / &lt;!-- .length 计算列表长度 --&gt; {{todos.length}} &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 建立变量 App const App = { // data() 返回监听的变量 data() { return { title: \"\", todos: [ { done: false, text: \"吃饭\" }, { done: true, text: \"睡觉\" } ], } }, // methods 设置方法 methods: { // 设置 addTodo 方法 addTodo() { // this 指的是自己, 也就是 App // 如果 title 为空, 不添加, 目的是防止无输入直接回车 if (this.title === \"\") { return } this.todos.push({ done: false, text: this.title }) // 给 todos 列表新增一个值为用户输入的 title 值 this.title = \"\" // 将 title 设置为空 } } } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;style&gt; /* 颜色变灰, 中间加划线 */ .done { color: gray; text-decoration: line-through; }&lt;/style&gt;&lt;/html&gt; 如同注释所说, 虽然在html 中编写代码的方式可以实现, 但是并不推荐, 有如下问题: 把 JS 代码放置进了 body 中, 不美观 使用 vue 的计算属性功能, 会将结果进行缓存优化(当这个属性在多地方使用时, 只计算一次), 避免每次的重复计算导致性能问题 下面, 我们使用计算属性功能来完成统计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 监听变量 title 的值--&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;!-- v-model 将 input 值绑定到变量 title --&gt; &lt;!-- @keydown.enter 在回车键时触发方法 addTodo --&gt; &lt;input type=\"text\" v-model=\"title\" @keydown.enter=\"addTodo\"&gt; &lt;ul&gt; &lt;!-- v-for 循环 todos, 每个值叫 todo, li 的值为每个 todo --&gt; &lt;li v-for=\"todo in todos\"&gt; &lt;!-- 当 type 为 checkbox 时, v-mode 绑定的变量如果是数组时, 作为 checkbox 的 value 使用, 当为 bool 时, 作为 checkbox 的 checked 值使用 --&gt; &lt;!-- 使用 todo.done 属性标识是否选中 --&gt; &lt;input type=\"checkbox\" v-model=\"todo.done\"&gt; &lt;!-- vue 中, : 用来传递数据, 这里的意思是, 如果 todo.done 为真, 则将 css done 传递给 class --&gt; &lt;span :class=\"{done:todo.done}\"&gt;{{todo.text}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;!-- 直接调用计算属性 --&gt; {{active}}/{{all}} &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 建立变量 App const App = { // data() 返回监听的变量 data() { return { title: \"\", todos: [ { done: false, text: \"吃饭\" }, { done: true, text: \"睡觉\" } ], } }, // methods 设置方法 methods: { // 设置 addTodo 方法 addTodo() { // this 指的是自己, 也就是 App // 如果 title 为空, 不添加, 目的是防止无输入直接回车 if (this.title === \"\") { return } this.todos.push({ done: false, text: this.title }) // 给 todos 列表新增一个值为用户输入的 title 值 this.title = \"\" // 将 title 设置为空 } }, // computed 设置 vue 的计算属性 computed: { // active 属性, 返回 done 为 false 的长度 active() { return this.todos.filter(v =&gt; !v.done).length }, // all 属性, 返回总长度 all() { return this.todos.length } } } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;style&gt; /* 颜色变灰, 中间加划线 */ .done { color: gray; text-decoration: line-through; }&lt;/style&gt;&lt;/html&gt; 全选 我们需要加入一个全选框, 当点击全选时, 所有todo 都选中, 并且, 当手动将所有 todo 选中时, 全选框默认变为勾选状态 计算属性, 不止可以用来做数据统计, 也可以修改对应的数据, 例如 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 监听变量 title 的值--&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;!-- v-model 将 input 值绑定到变量 title --&gt; &lt;!-- @keydown.enter 在回车键时触发方法 addTodo --&gt; &lt;input type=\"text\" v-model=\"title\" @keydown.enter=\"addTodo\"&gt; &lt;div&gt; &lt;!-- checkbox 绑定 allDone 计算属性, 生成时调用 get 方法, 返回 bool, 作为 checkbox 的 checked 使用 --&gt; &lt;!-- 当点击 checkbox 时, 计算属性发生变化, 将 checked 作为参数调用 allDone 的 set 方法 --&gt; 全选&lt;input type=\"checkbox\" v-model=\"allDone\"&gt; &lt;span&gt;{{active}}/{{all}}&lt;/span&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- v-for 循环 todos, 每个值叫 todo, li 的值为每个 todo --&gt; &lt;li v-for=\"todo in todos\"&gt; &lt;!-- 当 type 为 checkbox 时, v-mode 绑定的变量如果是数组时, 作为 checkbox 的 value 使用, 当为 bool 时, 作为 checkbox 的 checked 值使用 --&gt; &lt;!-- 使用 todo.done 属性标识是否选中 --&gt; &lt;input type=\"checkbox\" v-model=\"todo.done\"&gt; &lt;!-- vue 中, : 用来传递数据, 这里的意思是, 如果 todo.done 为真, 则将 css done 传递给 class --&gt; &lt;span :class=\"{done:todo.done}\"&gt;{{todo.text}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;!-- 直接调用计算属性 --&gt; {{active}}/{{all}} &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 建立变量 App const App = { // data() 返回监听的变量 data() { return { title: \"\", todos: [ { done: false, text: \"吃饭\" }, { done: true, text: \"睡觉\" } ], } }, // methods 设置方法 methods: { // 设置 addTodo 方法 addTodo() { // this 指的是自己, 也就是 App // 如果 title 为空, 不添加, 目的是防止无输入直接回车 if (this.title === \"\") { return } this.todos.push({ done: false, text: this.title }) // 给 todos 列表新增一个值为用户输入的 title 值 this.title = \"\" // 将 title 设置为空 } }, // computed 设置 vue 的计算属性 computed: { // active 属性, 返回 done 为 false 的长度 active() { return this.todos.filter(v =&gt; !v.done).length }, // all 属性, 返回总长度 all() { return this.todos.length }, // 计算属性为对象时, 可以通过定义 get 和 set 方法来修改属性 allDone: { // get 在获取计算属性时触发 get() { // 调用 this.active 计算属性, active 返回的是 done 为 false 的长度, 这里与0进行比较, 为0代表全部勾选, 返回 true return this.active === 0 }, // set 在计算属性发生变化时触发 set(val) { console.log(val) // forEach 是循环 // 循环 todos , 将每个 done 设置为 val this.todos.forEach(todo =&gt; { todo.done = val }); } } } } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;style&gt; /* 颜色变灰, 中间加划线 */ .done { color: gray; text-decoration: line-through; }&lt;/style&gt;&lt;/html&gt; 清空按钮 快完成了, 我们添加一个清空按钮在输入框之后, 要求点击清空则将所有已完成条目删除, 而当没有已完成条目时, 按钮不展示 使用 v-if 来进行条件筛选渲染 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 监听变量 title 的值--&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;!-- v-model 将 input 值绑定到变量 title --&gt; &lt;!-- @keydown.enter 在回车键时触发方法 addTodo --&gt; &lt;input type=\"text\" v-model=\"title\" @keydown.enter=\"addTodo\"&gt; &lt;!-- v-if 作为条件筛选, 当值为 true 才显示该 dom --&gt; &lt;!-- @click 在鼠标点击时触发, 这里调用 clear 方法 --&gt; &lt;button v-if=\"active&lt;all\" @click=\"clear\"&gt;清理&lt;/button&gt; &lt;div&gt; &lt;!-- checkbox 绑定 allDone 计算属性, 生成时调用 get 方法, 返回 bool, 作为 checkbox 的 checked 使用 --&gt; &lt;!-- 当点击 checkbox 时, 计算属性发生变化, 将 checked 作为参数调用 allDone 的 set 方法 --&gt; 全选&lt;input type=\"checkbox\" v-model=\"allDone\"&gt; &lt;span&gt;{{active}}/{{all}}&lt;/span&gt; &lt;/div&gt; &lt;ul&gt; &lt;!-- v-for 循环 todos, 每个值叫 todo, li 的值为每个 todo --&gt; &lt;li v-for=\"todo in todos\"&gt; &lt;!-- 当 type 为 checkbox 时, v-mode 绑定的变量如果是数组时, 作为 checkbox 的 value 使用, 当为 bool 时, 作为 checkbox 的 checked 值使用 --&gt; &lt;!-- 使用 todo.done 属性标识是否选中 --&gt; &lt;input type=\"checkbox\" v-model=\"todo.done\"&gt; &lt;!-- vue 中, : 用来传递数据, 这里的意思是, 如果 todo.done 为真, 则将 css done 传递给 class --&gt; &lt;span :class=\"{done:todo.done}\"&gt;{{todo.text}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;!-- 直接调用计算属性 --&gt; {{active}}/{{all}} &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 建立变量 App const App = { // data() 返回监听的变量 data() { return { title: \"\", todos: [ { done: false, text: \"吃饭\" }, { done: true, text: \"睡觉\" } ], } }, // methods 设置方法 methods: { // 设置 addTodo 方法 addTodo() { // this 指的是自己, 也就是 App // 如果 title 为空, 不添加, 目的是防止无输入直接回车 if (this.title === \"\") { return } this.todos.push({ done: false, text: this.title }) // 给 todos 列表新增一个值为用户输入的 title 值 this.title = \"\" // 将 title 设置为空 }, clear() { // 将 todos 赋值为老的 todos 中 done 为 false 的部分 // 去除了已经完成的条目 this.todos = this.todos.filter(v =&gt; !v.done) } }, // computed 设置 vue 的计算属性 computed: { // active 属性, 返回 done 为 false 的长度 active() { return this.todos.filter(v =&gt; !v.done).length }, // all 属性, 返回总长度 all() { return this.todos.length }, // 计算属性为对象时, 可以通过定义 get 和 set 方法来修改属性 allDone: { // get 在获取计算属性时触发 get() { // 调用 this.active 计算属性, active 返回的是 done 为 false 的长度, 这里与0进行比较, 为0代表全部勾选, 返回 true return this.active === 0 }, // set 在计算属性发生变化时触发 set(val) { console.log(val) // forEach 是循环 // 循环 todos , 将每个 done 设置为 val this.todos.forEach(todo =&gt; { todo.done = val }); } } } } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;style&gt; /* 颜色变灰, 中间加划线 */ .done { color: gray; text-decoration: line-through; }&lt;/style&gt;&lt;/html&gt; 添加空置提示 最后一步!, 我们为这个清单应用添加最后一个功能: 当清单为空时, 展示目前没有数据 我们这里搭配使用 v-if 与 v-else, 来做分支处理, 当然还可以搭配 v-else-if 针对多分支处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 监听变量 title 的值--&gt; &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;!-- v-model 将 input 值绑定到变量 title --&gt; &lt;!-- @keydown.enter 在回车键时触发方法 addTodo --&gt; &lt;input type=\"text\" v-model=\"title\" @keydown.enter=\"addTodo\"&gt; &lt;!-- v-if 作为条件筛选, 当值为 true 才显示该 dom --&gt; &lt;!-- @click 在鼠标点击时触发, 这里调用 clear 方法 --&gt; &lt;button v-if=\"active&lt;all\" @click=\"clear\"&gt;清理&lt;/button&gt; &lt;div&gt; &lt;!-- checkbox 绑定 allDone 计算属性, 生成时调用 get 方法, 返回 bool, 作为 checkbox 的 checked 使用 --&gt; &lt;!-- 当点击 checkbox 时, 计算属性发生变化, 将 checked 作为参数调用 allDone 的 set 方法 --&gt; 全选&lt;input type=\"checkbox\" v-model=\"allDone\"&gt; &lt;span&gt;{{active}}/{{all}}&lt;/span&gt; &lt;/div&gt; &lt;!-- 如果长度不为0代表目前有数据, 展示数据 --&gt; &lt;ul v-if=\"all!==0\"&gt; &lt;!-- v-for 循环 todos, 每个值叫 todo, li 的值为每个 todo --&gt; &lt;li v-for=\"todo in todos\"&gt; &lt;!-- 当 type 为 checkbox 时, v-mode 绑定的变量如果是数组时, 作为 checkbox 的 value 使用, 当为 bool 时, 作为 checkbox 的 checked 值使用 --&gt; &lt;!-- 使用 todo.done 属性标识是否选中 --&gt; &lt;input type=\"checkbox\" v-model=\"todo.done\"&gt; &lt;!-- vue 中, : 用来传递数据, 这里的意思是, 如果 todo.done 为真, 则将 css done 传递给 class --&gt; &lt;span :class=\"{done:todo.done}\"&gt;{{todo.text}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- v-else 必须紧跟在 v-if 的 dom 之后, 当 if 不通过执行渲染 else 内容 --&gt; &lt;div v-else&gt; 暂无数据 &lt;/div&gt; &lt;div&gt; &lt;!-- 直接调用计算属性 --&gt; {{active}}/{{all}} &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 建立变量 App const App = { // data() 返回监听的变量 data() { return { title: \"\", todos: [ { done: false, text: \"吃饭\" }, { done: true, text: \"睡觉\" } ], } }, // methods 设置方法 methods: { // 设置 addTodo 方法 addTodo() { // this 指的是自己, 也就是 App // 如果 title 为空, 不添加, 目的是防止无输入直接回车 if (this.title === \"\") { return } this.todos.push({ done: false, text: this.title }) // 给 todos 列表新增一个值为用户输入的 title 值 this.title = \"\" // 将 title 设置为空 }, clear() { // 将 todos 赋值为老的 todos 中 done 为 false 的部分 // 去除了已经完成的条目 this.todos = this.todos.filter(v =&gt; !v.done) } }, // computed 设置 vue 的计算属性 computed: { // active 属性, 返回 done 为 false 的长度 active() { return this.todos.filter(v =&gt; !v.done).length }, // all 属性, 返回总长度 all() { return this.todos.length }, // 计算属性为对象时, 可以通过定义 get 和 set 方法来修改属性 allDone: { // get 在获取计算属性时触发 get() { // 调用 this.active 计算属性, active 返回的是 done 为 false 的长度, 这里与0进行比较, 为0代表全部勾选, 返回 true return this.active === 0 }, // set 在计算属性发生变化时触发 set(val) { console.log(val) // forEach 是循环 // 循环 todos , 将每个 done 设置为 val this.todos.forEach(todo =&gt; { todo.done = val }); } } } } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;style&gt; /* 颜色变灰, 中间加划线 */ .done { color: gray; text-decoration: line-through; }&lt;/style&gt;&lt;/html&gt; 初探 vue3 新特性 相比于 vue2, vue3 的优势是什么? vue2 的历史遗留问题 vue2 使用 Flow.js 作为类型校验, 但是Flow.js已经停止维护, 整个社区都在使用TypeScript 来构建基础库, vue 也需要这样 vue2 内部运行时, 直接执行浏览器的 API, 这样在跨端时, 就需要适配多端,的否则会出现问题 vue2 并不是真正意义上的代理(响应式), 而是基于 Object.defineProperty()实现的, 这是对某个属性进行拦截, 有一些缺陷, 比如无法监听删除(vue 使用 $delete 辅助才能达到效果) vue2 使用 OptionApi, 在代码比较多时, 对于功能的修改, 需要兼顾data, methods代码块, 比较麻烦 vue3的新特性 RFC 机制 这与代码无关, 这是 vue 团队的开发工作方式, 对于新的功能和语法, 先放置在 github 征求意见, 任何人都可以讨论和尝试实现 响应式系统 之前说过, vue2使用Object.defineProperty()实现响应式, 而开发者必须将defineProperty监听的数据明确的写在代码中, 这是因为, defineProperty 对于不存在的属性无法拦截, 因此必须在data中声明监听变量 而 vue3 可以使用 proxy , 他的代码类似于 1234new Proxy(obj, { get(){}, set(){}}) proxy对 obj 是什么属性不做关心, 统一拦截, 还可以监听更多的格式数据, 例如Set/Map等 需要注意的是, Proxy不支持 IE11 以下的浏览器 Proxy是浏览器的新特性, 这代表着, 框架随着更新会和浏览器相辅相成, 一起为前端提供更多可能. 自定义渲染 vue2 内部的模块都是揉和在一起的, 导致扩展比较困难, 而 vue3 使用流行的 monorepo 的拆包管理方式, 将模块剥离, 进行解耦. 全部模块使用 TS 进行重构 TS(TypeScript)带来了系统类型, 能让代码的提示更为智能, 同时提高代码的健壮性 这里博主也推荐大家有空学习一下 TS, 类型注解可以让代码的编写更为得心应手. 并且 TypeScript 也是目前前端流行的技术, 很多框架都已经使用 TS 来进行底层的编写 Compostion API Composition API 作者将他称之为组合 API, 从 DEMO 来了解他们的不同 比如我们使用 vue2 来编写一个累加器, 并且有一个计算属性显示累加器 x2的结果 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 点击触发 add 函数 count*2, double 计算*2结果 --&gt; &lt;h1 @click=\"add\"&gt;{{count}} x 2 = {{double}}&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 建立变量 App const App = { data(){ return{ count: 1 } }, methods: { add(){ this.count += 1 } }, computed:{ double(){ return this.count * 2 } } } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;/html&gt; 而在 vue3 里, 我们可以使用 setup 来写 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 点击触发 add 函数 count*2, double 计算*2结果 --&gt; &lt;h1 @click=\"add\"&gt;{{state.count}} x 2 = {{double}}&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 导入所需的模块 const {reactive, computed} = Vue // 建立变量 App let App = { // setup 这里返回 App 的一些方法和变量等 setup(){ // 新建 state 对象 const state = reactive({ count: 1 // count 属性 }) // 新建 add 方法 function add(){ // count 属性+1 state.count += 1 } // 创建 double 的计算属性 const double = computed(()=&gt;state.count * 2) return {state, add, double} // 返回到外层 } } // 创建 App, 绑定到 id app Vue.createApp(App).mount(\"#app\")&lt;/script&gt;&lt;/html&gt; 使用新版的组合 api 之后, 表面看代码反而繁琐了, 但是之前的 OptionsAPI 有几个严重的问题: 所有的数据都挂载在 this 里, 因此对于类型推倒很不友好, 并且在清理和代码分块时很难受 新增功能都要修改 data, method 块, 维护困难 代码难以复用, 因为代码都糅杂在一起, 还可能会出现命名冲突 而使用组合 API 之后, 好处多多: api 都是通过 import 引入, 不需要的模块无需引入 将某块功能所有的 methods/data 封装在一个独立的函数中, 复用很容易, 也没有冲突问题 组合 api 新增的 return 等语句, 在实际项目中可清除 新增组件 vue3新增了若干组件, 比如: Fragment: 不再要求有一个唯一的根节点, 清理无用的 div 标签 Teleport: 允许组件渲染在别的元素内, 在开发弹窗组件时特别有用 Suspense: 异步请求组件 Vite Vite 跟 vue3 并不是绑定关系, 和 vue 也不是强制绑定, Vite 的竞品是 Webpack, 主要提升开发的体验 传统的 webpack, 在打包时, 是将所有的代码和页面打包完成再启动, 可能需要几分钟, 而 Vite 是阶梯式打包, 按需加载, 这样大大提升了开发体验 vue2 如何升级到 vue3 原作者说了很多, 大致是使用一些工具来进行升级 但是我个人认为, 如果是已经完成或者开发中的 vue2 项目, 不建议升级到 vue3, 我做过一些项目, 我认为前端组件的版本升级带来的问题很多, 尤其是不兼容问题. 所以我不建议对已有的项目进行升级 而对于新的项目, 可以使用 vue3来从头开始 搭建 vue3 项目的第一步 环境准备 你必须首先安装以下软件: NodeJs 初始化代码 找到你的工作目录, 命令行输入 1npm init @vitejs/app 初始化会让你输入项目的名字, 这里我们输入 student 12345➜ Vue npm init @vitejs/app@vitejs/create-app is deprecated, use npm init vite instead? Project name: › student 之后选择 vue 的项目 1234567? Select a framework: › - Use arrow-keys. Return to submit. vanilla❯ vue react preact lit svelte 回车后再选择 vue(javaScript) 或者 vue-ts(typeScript语言), 这里我们先选择普通的 vue, 方便学习, 之后学习了 TS 之后, 可以选择 vue-ts 123? Select a variant: › - Use arrow-keys. Return to submit.❯ vue vue-ts 之后就创建成功了项目 1234567Scaffolding project in /Users/chenming/Work/Code/Vue/student...Done. Now run: cd student npm install npm run dev 而后在当前文件夹就生成了一个新的文件夹 student 我们使用 vscode 打开 student 目录 现在目录下就会生成若干文件 1234567891011121314151617➜ student tree.├── README.md├── index.html 入口文件├── package.json├── public 资源文件夹│ └── favicon.ico├── src 源码│ ├── App.vue 组件│ ├── assets│ │ └── logo.png│ ├── components│ │ └── HelloWorld.vue│ └── main.js 入口└── vite.config.js vite 配置4 directories, 9 files 运行 此时脚手架就算搭建完成, 然后我们执行命令来安装依赖 1npm install 执行完命令后, 会在当前路径下生成新的文件夹node_modules, 里面存放下载的依赖文件, 通常, 该文件夹不应上传到代码仓库, 而是由开发者本地生成 再执行命令, 在本地启动 dev 环境 12345678910111213npm run dev&gt; student@0.0.0 dev&gt; vite vite v2.9.14 dev server running at: &gt; Local: http://localhost:3000/ &gt; Network: use `--host` to expose ready in 177ms. 而后浏览器打开网址 http://localhost:3000/, 会出现欢迎页面代表成功 同时, 我们修改文件 src/APP.vue 的内容, 会发现网页会同步刷新, 这样就给我们的开发提供了很大的便利 同时, 因为我们的开发是多页面, 同时要和后端进行交互, 因此我们还需要安装两个组件来帮助我们完成需求, 分别是vuex(管理数据)和vue-router(管理路由) 1npm install vuex@next vue-router@next","link":"/2022/07/07/play_with_vue3(1)/"},{"title":"Python -c 使用","text":"Python -c python -c 命令还是有用的哈 python的 -c 可以在命令行中调用 python 代码, 实际上 -c 就是 command 的意思 官方文档中解释为(节选自: python docs): Execute the Python code in command. command can be one or more statements separated by newlines, with significant leading whitespace as in normal module code. If this option is given, the first element of sys.argv will be \"-c\" and the current directory will be added to the start of sys.path (allowing modules in that directory to be imported as top level modules). Raises an auditing event cpython.run_command with argument command. 简单来说, 就是 python -c 可以在命令行中执行 python 代码, 跟把代码放置在 .py 文件中然后运行这个文件比无明显差别, 我们来测试一下 1python -c \"print('TTXT')\" 随后正确输出了 TTXT 需要注意的是, python -c 后必须跟一个字符串, 因此必须带上引号, 而且在要执行的代码中也不要重叠, 这样会引发错误, 这是因为 python 认不出该到哪里结尾, 例如 1python -c \"print(\"TTXT\")\" 这样就会报错, 输出 123Traceback (most recent call last): File \"&lt;string&gt;\", line 1, in &lt;module&gt;NameError: name 'TTXT' is not defined 我们一般可以使用三引号来标示需要执行的代码, 例如 1python -c '''print(\"TTXT\")''' 这样还有一个好处就是也可以执行多行的代码, 例如 1234python -c '''import arrow print(arrow.now())''' 这样也是可以的, 也可以定义并调用函数 12345python -c '''def a(): print(111)a()''' 当然也是可以导入自定义的模块或者已经安装的包的 妙用 那么 -c 有什么妙用呢? 这个要具体问题具体分析, 比如说我在开发中要使用一个第三方包 patool, 项目在 github, 这个包作用是根据格式解压压缩文件, 但是在调用时发生总是会报找不到 patoollib 模块的错误 官方给的例子如下 12import patoolibpatoolib.extract_archive(\"archive.zip\", outdir=\"/tmp\") 排查发现, 该模块的起始文件最上面写定了python的地址, 导致运行时强制指定了python路径而没有使用自己的虚拟环境, 因为 /usr/bin/python 没有安装 patool 包所以报错找不到 py文件节选 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/python# -*- coding: utf-8 -*-# Copyright (C) 2010-2015 Bastian Kleineidam## This program is free software: you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation, either version 3 of the License, or# (at your option) any later version.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.\"\"\"patool [global-options] {extract|list|create|diff|search|formats} [sub-command-options] &lt;command-args&gt;\"\"\"def main(): \"\"\"Parse options and execute commands.\"\"\" try: argparser = create_argparser() args = argparser.parse_args() if args.command is None: # Python 3.3.1 under linux allows an empty command somehow argparser.error(\"too few arguments\") # run subcommand function res = globals()[\"run_%s\" % args.command](args) except KeyboardInterrupt: log_error(\"aborted\") res = 1 except Exception: log_internal_error() res = 2 return resif __name__ == '__main__': sys.exit(main()) 似乎只能将包的源代码修改, 实际上只要把第一行删除即可, 但是考虑到Docker部署, 就没有更好的办法了吗? 使用 python -c 即可完美解决 我们使用 python -c 在命令行中使用我们指定的 python 去执行模块, 就会使py文件中指定的不生效, 所以调用改成如下即可 123code = f\"import patoolib; patoolib.extract_archive('{file}', outdir='{unfile}')\"proc = await asyncio.create_subprocess_exec(sys.executable, '-c', code)await proc.wait() 这样就可以完美的解决问题了, 不用修改原来包的代码","link":"/2021/09/04/python_-c/"},{"title":"保护你的网站用户密码","text":"最近对密码的加密比较感兴趣, 但是对于比较全面的文章, 只找到了这一章, 英文版, 我稍微翻译了一下, 这里记录一下 原文: Salted Password Hashing - Doing it Right 序言 如果你是一个web开发人员，你可能不得不建立一个用户帐户系统。用户帐户系统最重要的方面是如何保护用户密码。用户帐户数据库经常被黑客入侵，所以如果你的网站被入侵，你绝对必须采取措施保护你用户的密码。保护密码的最好方法是使用salt密码散列(salted password hashing)。本文将解释为什么它是这样做的。 关于如何正确地进行密码散列有很多相互矛盾的想法和误解，可能是因为网络上有大量的错误信息。密码散列其实是很简单的事情之一，但是很多人都会犯错。通过这一篇文章，我希望不仅解释正确的方法，而且解释为什么应该这样做。 重要警告: 如果您正在考虑编写自己的密码哈希代码, 请立即停止, 这太容易搞砸了。不，你在大学上的密码学课程并不能使你免除这个警告。这适用于每一个人, 不要编写自己的 CRYPTO(DO NOT WRITE YOUR OWN CRYPTO!), 存储密码的问题已经得到解决, 许多语言都有现成的包和模块供你使用, 他将比你自己实现的更加完美和稳定 需要说明的是,本篇文章并不是要指导你如何编写自己的存储系统，而是要解释为什么密码应该以某种方式存储。 什么是密码散列 123hash(\"hello\") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824hash(\"hbllo\") = 58756879c05c68dfac9866712fad6a93f8146f337a69afe7dd238f3364946366hash(\"waltz\") = c0e81794384491161f1777c232bc6bd9ec38f616560b120fda8e90f383853542 哈希算法是单向函数。他们把任何数量的数据转换成一个固定长度的“指纹”，不能逆转。它们还有一个特性，即如果输入发生一点点的变化，那么产生的散列就完全不同了（参见上面的示例）。这对于保护密码非常有用，因为我们希望以一种即使密码文件本身被泄露也能保护密码的形式存储密码，但同时，我们需要能够验证用户的密码是否正确。 在基于哈希的帐户系统中，帐户注册和身份验证的一般工作流程如下： 用户创建一个帐户 他们的密码被散列并存储在数据库中。任何时候都不会有写入硬盘的纯文本(未加密)密码 当用户尝试登录时，将根据其真实密码(从数据库中检索)的哈希值与他们输入的密码的哈希值进行比对 如果散列匹配，用户将被授予访问权限。如果不匹配，用户将被告知输入了无效的登录凭证 当用户每次登录时, 重复步骤3和步骤4 在第4步中，千万不要告诉用户是不是用户名或密码错了。始终显示“无效用户名或密码”这样的通用消息。这可防止攻击者在不知道其密码的情况下枚举有效用户名。 应该注意的是，用于保护密码的哈希函数与您在数据结构课程中看到的哈希函数不同。用于实现哈希表等数据结构的哈希函数被设计为快速的，而不是安全的。只能使用加密哈希函数来实现密码哈希。像SHA256、SHA512、RipeMD和WHIRLPOOL这样的散列函数都是加密散列函数。 很容易认为你所要做的就是通过一个加密散列函数来运行密码，你的用户的密码将是安全的。这与事实相去甚远。有很多方法可以很快地从普通散列中恢复密码。有几种易于实现的技术使这些“攻击”的效果大大降低。为了激发对这些技术的需求，考虑一下这个网站。在首页上，您可以提交一个要破解的哈希列表，并在不到一秒钟的时间内收到结果。显然，简单地对密码进行哈希运算并不能满足我们对安全性的需求。 如何破解哈希 字典和暴力攻击 破解散列的最简单方法是尝试猜测密码，对每个猜测进行散列，并检查猜测的散列是否等于被破解的散列。如果哈希值相等，则猜测到了密码。猜测密码最常见的两种方法是字典攻击和暴力攻击。 字典攻击使用包含单词、短语、常用密码和其他可能用作密码的字符串的文件。对文件中的每个单词进行哈希运算，并将其哈希值与密码哈希值进行比较。如果他们匹配，这个词就是密码。这些字典文件是通过从大量文本中提取单词，甚至从真实的密码数据库中提取单词来构建的。进一步的处理通常应用于字典文件，例如用“leet speak”等价词替换单词（“hello”变成“h3110”），以使它们更有效。 暴力攻击会尝试所有可能的字符组合，长度不超过给定的长度。这些攻击在计算上非常昂贵，而且通常在每个处理器时间破解哈希方面效率最低，但它们最终总会找到密码。密码应该足够长，搜索所有可能的字符串以找到它将花费太长的时间是值得的。 我们无法防止字典攻击或暴力攻击。它们可以变得不那么有效，但是没有一种方法可以完全阻止它们。如果密码散列系统是安全的，破解散列的唯一方法就是对每个散列运行字典或暴力攻击, 但是对于破解者来说要花费很大的代价和很长的时候才能破解其中一个密码. 查找表 查找表是一种非常有效的方法，可以快速地破解许多相同类型的哈希。其基本思想是在密码字典中预先计算密码的哈希值，并将其和相应的密码存储在查找表数据结构(数据库)中。使用者提交需要破解的哈希, 由数据库去查找有没有对应的密码, 一个好的查找表实现可以每秒处理数百个哈希查找，即使它们包含数十亿个哈希。 如果您想更好地了解查找表的速度，请尝试使用CrackStation的免费哈希破解程序破解以下sha256哈希(需要FQ) 123456c11083b4b0a7743af748c85d343dfee9fbb8b2576c05f3a7f0d632b0926aadfc11083b4b0a7743af748c85d343dfe9fbb8b2576c05f3a7f0d632b0926aadfc08eac03b80adc33dc7d8fbe44b7c7b05d3a2c511166bdb43fcb710b03ba919e7e4ba5cbd251c98e6cd1c23f126a3b81d8d8328abc95387229850952b3ef9f9044ba5cbd251c98e6cd1c23f126a3b81d8d8328abc95387229850952b3ef9f9045206b8b8a996cf5320cb12ca91c7b790fba9f030408efe83ebb83548dc3007bd 反向查找表 此攻击允许攻击者对多个哈希同时应用字典或暴力攻击，而无需预先计算查找表。 首先，攻击者创建一个查找表，将每个密码哈希值从受损用户帐户数据库映射到拥有该哈希值的用户列表。然后，攻击者对每个密码猜测进行哈希运算，并使用查找表获取其密码是攻击者猜测的用户列表。这种攻击特别有效，因为许多用户都有相同的密码。 这段比较晦涩, 我使用大白话来解释一下, 其实是攻击者注册一个账号到被攻击网站, 然后进入该网站的密码数据库, 查找到刚才注册的帐号的加密后的密码, 再通过数据库查找有没有和该加密密码一致的加密密码, 一致则代表某个用户使用了和你相同的密码, 即可达到破解的效果 彩虹表 彩虹表是一种时间记忆折衷技术。它们类似于查寻表，只是它们牺牲了哈希破解的速度，以使查寻表更小。因为它们更小，所以可以将更多散列的解决方案存储在相同的空间中，从而使它们更有效。彩虹表，可以快速破解任何8个字符生成的md5。 彩虹表 加盐(salt) 1234hash(\"hello\") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824hash(\"hello\" + \"QxLUF1bgIAdeQX\") = 9e209040c863f84a31e719795b2577523954739fe5ed3b58a75cff2127075ed1hash(\"hello\" + \"bv5PehSMfV11Cd\") = d1d3ec2e6f20fd420d50e2642992841d8338a314b8ea157c9e18477aaef226abhash(\"hello\" + \"YYLmfY6IehjZMQ\") = a49670c3c18b9e079b9cfaf51634f563dc8ae3070db2c4a8544305df1b60f007 查找表和彩虹表起作用，因为每个密码的散列方式完全相同。如果两个用户有相同的密码，他们将有相同的密码哈希。我们可以通过随机化每个散列来防止这些攻击，这样当相同的密码被散列两次时，散列就不一样了。 我们可以通过在散列之前在密码中添加或预先添加一个随机字符串（称为 salt ）来随机散列。如上面的示例所示，每次都会将相同的密码散列成完全不同的字符串。为了检查密码是否正确，我们需要这个密码加密时的salt，因此它通常与散列一起存储在用户帐户数据库中，或者作为散列字符串本身的一部分。 Salt不需要加密。因为salt是随机的, 随机化了哈希值，查找表、反向查找表和彩虹表就变得无效了。攻击者不会预先知道salt是什么，因此无法预先计算查找表或彩虹表。如果每个用户的密码都用不同的salt散列，那么反向查找表攻击也不会起作用。 加盐的错误使用 重复使用一个盐 一个常见的错误是在每个散列中使用相同的盐。salt要么硬编码到程序中，要么随机生成一次。这是无效的，因为如果两个用户有相同的密码，他们仍然会有相同的哈希。攻击者仍然可以使用反向查找表攻击同时对每个哈希运行字典攻击。他们只需对每个密码猜测应用salt，然后再对其进行哈希运算。如果将salt硬编码到一个流行的产品中，那么可以为该salt构建查找表和彩虹表，以便更容易地破解产品生成的哈希。 每次用户创建帐户或更改密码时，都必须生成一个新的随机salt。 短盐 如果盐太短，攻击者可以为每个可能的盐建立一个查找表。例如，如果salt只有三个ASCII字符，则只有95x95x95=857375个可能的salt。这看起来可能很多，但是如果每个查找表只包含1MB最常用的密码，那么它们总共只有837GB，考虑到现在1000 GB的硬盘售价低于100美元，这并不算多。 出于同样的原因，用户名不应该用作salt。用户名对于单个服务可能是唯一的，但是它们是可预测的，并且经常被其他服务上的帐户重用。攻击者可以为常见用户名构建查找表，并使用它们来破解用户名作为salt的哈希。 为了使攻击者无法为每个可能的salt创建一个查找表，salt必须很长。一个好的经验法则是使用与哈希函数输出大小相同的salt。例如，SHA256的输出是256位（32字节），因此salt应该至少是32个随机字节。 散列算法的错误使用 本节介绍另一个常见的密码散列误解：散列算法的古怪组合。人们很容易忘乎所以地尝试组合不同的散列函数，希望结果更安全。但实际上，这样做并没有什么好处。它只会造成互操作性问题，有时甚至会降低哈希的安全性。永远不要试图发明你自己的密码，总是使用一个由专家设计的标准。有些人会认为使用多个散列函数会使计算散列的过程变慢，所以破解会变慢，但是有一个更好的方法可以让破解过程变慢，我们稍后会看到。 下面是一些我在互联网论坛上看到的糟糕的古怪哈希函数的例子 md5(sha1(password)) md5(md5(salt) + md5(password)) sha1(sha1(password)) sha1(str_rot13(password + salt)) md5(sha1(md5(md5(password) + sha1(password)) + md5(password))) 不要使用这些。 注：本节已被证明是有争议的。我收到过很多邮件，认为古怪的散列函数是件好事，因为如果攻击者不知道使用的是哪一个散列函数就更好了，攻击者为古怪的散列函数预先计算彩虹表的可能性更小，计算散列函数的时间也更长。 攻击者在不知道算法的情况下无法攻击哈希，但请注意Kerckhoffs的原理，即攻击者通常可以访问源代码（尤其是免费或开源软件），并且给定目标系统中的一些密码哈希对，对算法进行反向工程并不困难。计算古怪的散列函数确实需要更长的时间，但只需要一个小的常数因子。最好使用一个设计得非常难以并行化的迭代算法（这些将在下面讨论）。而且，适当地对散列进行盐分可以解决彩虹表问题。 如果你真的想使用一个标准化的“古怪”散列函数，比如HMAC，那就没关系了。但是，如果这样做是为了降低哈希计算的速度，请先阅读下面关于密钥扩展(key stretching)的部分。 将这些小的好处与意外实现完全不安全的散列函数的风险以及古怪的散列所产生的互操作性问题进行比较。显然，最好使用标准的、经过良好测试的算法。 散列碰撞 因为散列函数将任意数量的数据映射到固定长度的字符串，所以必须有一些输入散列到相同的字符串中。加密散列函数的设计使这些冲突难以找到。有时，密码学家会发现对散列函数的“攻击”，从而更容易找到冲突。最近的一个例子是MD5散列函数，实际上已经找到了它的冲突。 就是有可能字符串 abc 和 bbc 生成的散列是相同的 冲突攻击是一种迹象，表明除用户密码以外的字符串更有可能具有相同的哈希值。然而，即使是在MD5这样的弱哈希函数中发现冲突，也需要大量专用的计算能力，因此在实践中，这些冲突“偶然”发生的可能性非常小。使用MD5和salt散列的密码在所有实际用途中都是安全的，就像使用SHA256和salt散列一样。不过，如果可能的话，最好使用更安全的散列函数，如SHA256、SHA512、RipeMD或WHIRLPOOL。 如何正确的散列 本节详细描述了密码应该如何散列。第一小节涵盖了基本的一切，这是绝对必要的。下面的小节将解释如何扩充基础知识，使哈希更难破解。 用盐做散列 警告：不要只阅读本节。您绝对必须实现下一节中的内容：“使密码破解更困难：慢哈希函数” 我们已经看到恶意黑客如何使用查找表和彩虹表快速破解普通哈希。我们已经了解到使用salt随机散列是问题的解决方案。但是如何生成salt，以及如何将其应用于密码？ Salt应该使用加密安全的伪随机数生成器（CSPRNG）生成。csprng与普通的伪随机数生成器非常不同，比如“C”语言的rand（）函数。顾名思义，csprng被设计成密码安全的，这意味着它们提供了高度的随机性，并且完全不可预测。我们不希望盐是可预测的，所以我们必须使用CSPRNG。每个语言都有对应的函数供你使用, 例如 python 的 os.urandom 等 每个用户每个密码的salt必须是唯一的。每次用户创建帐户或更改密码时，都应该使用新的随机salt对密码进行哈希运算。不要重复使用盐。盐也应该足够长, 以保证有足够多的盐用于哈希加密。根据经验，使salt至少与哈希函数的输出一样长。salt应该与hash一起存储在用户账户表中。 保存密码 使用 CSPRNG 生成足够长的随机盐 将salt预先混入密码中，并使用标准密码哈希函数（如Argon2、bcrypt、scrypt或PBKDF2）对其进行哈希运算。 在用户的数据库记录中保存salt和hash。 校验密码 从数据库中检索用户的salt和hash。 将salt混入用户提交的密码，并使用相同的哈希函数对其进行哈希运算。 将给定密码的哈希值与数据库中的哈希值进行比较。如果匹配，则密码正确。否则，密码不正确。 在 Web 应用程序中，始终在服务器上进行散列 如果您正在编写一个web应用程序，您可能想知道在哪里散列。密码应该在用户浏览器中用JavaScript散列，还是应该发送将明文密码发送到服务器再进行散列呢? 即使用JavaScript散列用户密码，也必须在服务器上散列。考虑一个网站，它在用户浏览器中散列用户密码，而不在服务器上散列。若要验证用户身份，此网站将接受来自浏览器的哈希值，并检查该哈希值是否与数据库中的哈希值完全匹配。这似乎比在服务器上散列更安全，因为用户的密码从未发送到服务器，但事实并非如此。 问题是客户端的哈希值逻辑上变成了用户的密码。用户需要做的只是告诉服务器他们密码的散列。如果一个坏人得到了一个用户的散列，他们可以用它来验证服务器，而不知道用户的密码！因此，如果坏人不知何故从这个假想的网站窃取了哈希数据库，他们就可以立即访问每个人的帐户，而不必猜测任何密码。 这并不是说你不应该在浏览器中散列，但如果你这样做了，你绝对也必须在服务器上散列。在浏览器中进行散列当然是一个好主意，但在实现时请考虑以下几点： 客户端密码哈希不能替代HTTPS（SSL/TLS）。如果浏览器和服务器之间的连接不安全，中间人可以在下载JavaScript代码时修改它，以删除散列功能并获取用户的密码。 有些web浏览器不支持JavaScript，有些用户在浏览器中禁用JavaScript。因此，为了获得最大的兼容性，你的应用程序应该检测浏览器是否支持JavaScript，如果不支持，就在服务器上模拟客户端散列。 你也需要在客户端散列的过程中中加盐。显而易见的解决方案是让客户端脚本向服务器请求用户的salt。不要这样做，因为它让攻击者在不知道密码的情况下检查用户名是否有效。由于您也在服务器上进行散列和加盐（使用一个合格的salt），因此可以使用用户名（或电子邮件）与特定于站点的字符串（例如域名）连接作为客户端salt(这个客户端salt并不是最终的salt, 客户端生成的加密密码也不是最终的密码, 只是为了将明文密码加密而防止中间人攻击, 并且,当黑客拿到了客户端加密后的密码, 他也能通过请求登录接口模拟客户端已经加密密码然后登录的情况, 此时则与客户端不加密的效果一致)。 使得密码破解更难: 缓慢的散列函数 Salt确保攻击者不能使用专门的攻击，如查找表和彩虹表来快速破解大量散列集合，但它不能阻止攻击者单独对每个散列运行字典或暴力攻击。高端图形卡（GPU）和定制硬件每秒可以计算数十亿个哈希，因此这些攻击仍然非常有效。为了降低这些攻击的效果，我们可以使用一种称为密钥扩展(key stretching)的技术。 其想法是使哈希函数非常慢，因此即使使用快速的GPU或定制硬件，字典和暴力攻击也很慢，从而让攻击者放弃或者失败。目标是使散列函数足够慢以阻止攻击，但仍然足够快以避免给用户造成明显的延迟。 密钥扩展是使用一种特殊类型的CPU密集型哈希函数实现的。不要试图创造你自己的加密函数, 简单地对密码的散列进行迭代散列是不够的，因为它可以在硬件中并行化，并且可以像普通散列一样快速执行。使用标准算法，如PBKDF2或bcrypt。 这些算法以安全因子或迭代计数作为参数。此值确定哈希函数的速度。对于桌面软件或智能手机应用程序，选择此参数的最佳方法是在设备上运行一个简短的基准测试，以找到计算哈希值的耗时约半秒的参数。这样，您的程序就可以在不影响用户体验的情况下尽可能安全。 如果您在web应用程序中使用密钥扩展哈希，请注意您将需要额外的计算资源来处理大量身份验证请求，并且密钥扩展可能会使您的网站更容易受到拒绝服务（DoS）攻击。我仍然建议使用密钥扩展，但是迭代次数要少一些。您应该根据计算资源和预期的最大身份验证请求速率来设置迭代次数。通过让用户在每次登录时输入验证码，可以消除DoS威胁。系统在设计时要将迭代次数设置为可配置的，以便将来可以增加或减少迭代次数。 如果您担心计算负担，但仍希望在web应用程序中使用密钥扩展，请考虑使用JavaScript在用户浏览器中运行密钥扩展算法。Stanford Javascript Crypto Library加密库包括PBKDF2。迭代次数应该设置得足够低，这样系统就可以在移动设备等速度较慢的客户端上使用，如果用户的浏览器不支持JavaScript，那么系统应该返回到服务器端来模拟客户端计算。客户端密钥扩展并不能消除服务器端散列的需要。你必须对客户端传回来的哈希值再次进行哈希加密, 也就是说客户端生成的加密密码并不是最终的加密密码, 以此来增加安全性, 因为前端的代码是透明的, 不能将完整的算法放置在前端 不可能破解的哈希: 密钥哈希和密码哈希设备 只要攻击者可以使用哈希来检查密码猜测是否正确，他们就可以对哈希运行字典或暴力攻击。下一步是将密钥添加到哈希中，这样只有知道密钥的人才能使用哈希来验证密码。这可以通过两种方式实现。可以使用类似AES的算法对散列进行加密，或者使用类似HMAC的密钥散列算法将密钥包括在散列中。 这并不像听起来那么容易。密钥必须对攻击者保密，即使在出现漏洞的情况下也是如此。如果攻击者获得对系统的完全访问权限，则无论密钥存储在何处，他们都可以窃取密钥。密钥必须存储在外部系统中，例如专门用于密码验证的物理上独立的服务器，或者连接到服务器的特殊硬件设备，例如YubiHSM。 对于任何大规模（超过10万个用户）的服务，我强烈推荐这种方法。我认为有必要为任何托管超过100万个用户帐户使用该方法。 如果您负担不起多个专用服务器或特殊硬件设备，您仍然可以在标准web服务器上获得密钥哈希的一些好处。大多数数据库都是通过SQL注入攻击被破坏的，在大多数情况下，SQL注入攻击不允许攻击者访问本地文件系统（如果SQL server具有此功能，则禁用对本地文件系统的访问）。如果生成一个随机密钥并将其存储在无法从web访问的文件中，并将其包含到salt哈希中，那么如果使用简单的SQL注入攻击破坏数据库，哈希就不会受到攻击。不要将密钥硬编码到源代码中，而是在安装应用程序时随机生成密钥。这不如使用单独的系统进行密码的管理安全，因为如果web应用程序中存在SQL注入漏洞，攻击者可能会使用其他类型（如本地文件包含）来读取密钥文件。但是，总比什么都没有强。 请注意，密钥哈希并不能消除对盐的需要。聪明的攻击者最终会找到破解密钥的方法，因此密码哈希依然需要加盐和密钥扩展, 这是很重要的。 其他安全措施 密码哈希在发生安全漏洞时保护密码。它并不能使整个应用程序更加安全。为了防止密码散列（和其他用户数据）在第一时间被窃取，还必须做更多的工作。 即使是有经验的开发人员也必须接受安全教育，才能编写安全的应用程序。了解web应用程序漏洞的一个重要资源是openweb应用程序安全项目 OWASP 。一个很好的介绍是 OWASP十大漏洞列表。除非您了解列表中的所有漏洞，否则不要尝试编写处理敏感数据的web应用程序。雇主有责任确保所有开发人员都接受过安全应用程序开发方面的充分培训。 对您的应用程序进行第三方\"渗透测试\"是一个好主意。即使是最好的程序员也会犯错，因此让安全专家检查代码中的潜在漏洞总是有意义的。找一个值得信赖的组织（或雇佣员工）定期检查您的代码。安全审查过程应该在应用程序生命周期的早期开始，并在整个开发过程中持续进行。 同样重要的是要监测你的网站，以发现入侵行为。我建议至少雇佣一个全职工作是检测和处理安全漏洞的人。如果一个漏洞未被发现，攻击者可以通过你的网站利用恶意软件感染访问者，所以检测漏洞并及时作出反应是非常重要的。 常见问题 我应该使用什么散列算法？ 使用 精心设计并经过大量测试的密钥扩展算法比如 PBKDF2, Bcrypt, Scrypt 很好的开源项目比如 Portable PHP password hashing framework PBKDF2在各个语言的实现 crypt 的安全版本 不要使用 快速密码散列函数，如 MD5、 SHA1、 SHA256、 SHA512、 RipeMD、 WHIRLPOOL、 SHA3等 不安全版本的 crypt 任何你自己设计的算法。只能使用公共领域的技术，并且经过经验丰富的密码学家的良好测试。 当用户忘记密码时，我应该如何允许他们重置密码？ 我个人认为，现在广泛使用的所有密码重置机制都是不安全的。如果你有很高的安全要求，比如加密服务，不要让用户重置密码。 大多数网站使用向忘记密码的用户发送邮件来验证身份。为此，生成一个与帐户紧密关联的随机一次性令牌(Token)。将其包含在发送到用户电子邮件地址的密码重置链接中。当用户单击包含有效令牌的密码重置链接时，提示他们输入新密码。确保令牌与用户帐户紧密绑定，以便攻击者不能使用发送到自己电子邮件地址的令牌重置其他用户的密码。 令牌必须设置为在15分钟内或使用后过期，一旦使用过就立即作废。当用户登录（他们想起来了他们的密码）或请求一个新的重置密码时，使该用户任何现有的密码令牌过期。如果一个令牌没有过期，它可以永远被用来入侵用户的帐户。电子邮件（SMTP）是一种纯文本协议，互联网上存在截取电子邮件的恶意路由。用户的电子邮件帐户（包括重置链接）可能会在其修改密码后很长一段时间内被泄露出去。而使令牌尽快过期可以减少用户将信息暴露给攻击者的风险。 攻击者将能够修改令牌，因此不要在其中存储用户帐户信息或失效时间。它们应该是不可猜测的随机二进制数据，仅用于标识数据库表中的某条用户记录。 千万不要通过电子邮件向用户发送新密码。当用户重置密码时，请记住选择一个新的随机盐。不要重复使用他们的旧盐。 如果我的用户帐户资料库被泄漏/入侵，我应该怎么办？ 您的首要任务是确定系统是如何受到危害的，并修补攻击者用来进入的漏洞。如果你没有应对漏洞的经验，我强烈建议你聘请第三方安全公司。 可能会有人试图掩盖漏洞，希望没人注意到。然而，试图掩盖漏洞会让你变得更糟，因为你没有通知用户密码和其他个人信息可能会被泄露，这会让你的用户面临更大的风险。你必须尽快通知你的用户，即使你还没有完全明白发生了什么。在你的网站首页放一个通知，链接到一个有更详细信息的页面，如果可能的话，通过电子邮件向每个用户发送一个通知。 向你的用户解释他们的密码是如何被盐哈希保护的，即使他们被盐哈希保护，恶意黑客仍然可以对哈希运行字典和暴力攻击。恶意黑客会使用他们找到的任何密码试图登录到另一个网站上的用户帐户，希望他们在两个网站上使用相同的密码。将此风险告知您的用户，并建议他们在使用类似密码的任何网站或服务上更改密码。强制他们在下次登录时更改您服务的密码。大多数用户会尝试将自己的密码“更改”为原始密码，以快速绕过强制更改。你需要使用当前密码散列来校验新旧密码是否相同来确保他们不能这样做。 很可能，即使使用盐哈希，攻击者也能很快破解一些弱密码。为了减少攻击者使用这些密码的机会，在登录时除了当前密码之外，还应该要求通过电子邮件进行身份验证，直到用户更改了密码。请参阅前面的问题，“当用户忘记密码时，我应该如何允许用户重置密码？”有关实现电子邮件验证身份的提示。 同时告诉你的用户网站上储存了什么样的个人信息。如果你的数据库包含信用卡号码，你应该指示你的用户仔细检查他们最近和将来的账单，并注销他们的信用卡。 我的密码政策应该是什么? 我应该强制使用强密码吗？ 如果您的服务没有严格的安全要求，那么不要限制您的用户。我建议在用户键入密码时向其显示有关密码强度的信息，让他们决定密码的安全性。如果您有特殊的安全需求，请强制执行至少12个字符的长度，并且至少需要两个字母、两个数字和两个符号。 不要强迫用户每六个月更改一次以上的密码，因为这样做会造成“用户疲劳”，使用户不选择复杂的密码。相反，教育用户在感到密码被泄露时主动更改密码，并且永远不要把密码告诉任何人。如果是商业环境，鼓励员工利用带薪时间熟记和使用密码。 如果攻击者可以访问我的数据库，难道他们不能用自己的散列和登录来替换密码的散列吗？ 是的，但是如果有人可以访问你的数据库，他们可能已经可以访问你服务器上的所有内容，所以他们不需要登录到你的帐户就可以得到他们想要的。密码散列（在网站中）的目的不是保护网站不被破坏，而是在确实发生入侵时保护数据库中的密码。 通过使用两个具有不同权限的用户连接到数据库，可以防止哈希在SQL注入攻击期间被替换。一个用于“创建帐户”代码，另一个用于“登录”代码。“create account”代码操作的用户应该能够读取和写入用户表，但是“login”代码使用的用户应该只能读取。 为什么我必须使用像 HMAC 这样的特殊算法？为什么我不能把密码附加到密钥上呢？ 像 MD5、 SHA1和 SHA2这样的散列函数使用 Merkle-Damgård 结构，这使它们容易受到所谓的长度扩展攻击(length extension attack)。这意味着给定一个 哈希 h (x) ，对于任意的字符串 Y，攻击者可以计算出 h(pad(X)+Y) 的值，而无需知道 X 的值。其中， pad(X) 是哈希函数的填充函数。 这意味着，攻击者不知道密钥的情况下，仍然可以根据给定的哈希值 H(key+message) 计算出 H(pad(key+message)+extension) 。如果该哈希值用于身份认证，并依靠其中的密钥来防止攻击者篡改消息，这方法已经行不通。因为攻击者无需知道密钥也能构造出包含 message+extension 的一个有效的哈希值。 目前尚不清楚攻击者如何利用此攻击更快地破解密码哈希。但是，由于受到攻击，使用普通哈希函数进行密钥哈希加密被认为是不好的做法。一个聪明的密码学家也许有一天会想出一个聪明的方法来使用这些攻击来加快破解速度，所以还是使用HMAC 较好。 盐应该放在密码的前面还是后面？ 这不重要，但是为了互操作性，选择一个并保持风格一致即可。把盐放在密码之前似乎更为常见。 需要保证对比密码时的操作时间相同 原文这里很晦涩, 理解了一会才明白是什么意思 标题的意思是, 假设用户的密码哈希是 ‘abcde’, 当服务端接收到了用户提交的密码, 哈希后假如是 ‘adcca’ 或者是 ‘121333’ 或者是其他的, 要保证判断他们与数据库中的是否一致的代码在处理所有密码时都要有一致的处理时间 比较哈希值的函数遵循 “时间一致” 可确保攻击者无法在使用计时攻击的在线系统中提取密码的哈希值，然后离线破解密码。 检查两个字节（字符串）是否相同的标准方法是比较第一个字节、第二个字节、第三个字节，依此类推。一旦发现两个字符串的字节不一样，就知道它们是不同的，可以立即返回false。如果您在两个字符串中都没有找到任何不同的字节，那么您就知道字符串是相同的，并且可以返回一个true。这意味着比较两个字符串可能需要不同的时间，具体取决于匹配的字符串数量。 例如，对字符串“xyzabc”和“abcxyz”进行标准比较，可以立即看到第一个字符是不同的，不必检查字符串的其余部分。另一方面，当比较字符串“aaaaaaaab”和“aaaaaaaaaaz”时，比较算法在扫描到 z 时才会确认这两个字符串是不一样的, 这代表他已经检查了前面几位, 显而易见的, 一般的, 比较算法在处理这两个判断时用时是不一样的, 后面的会比前面的处理慢一些。 假设攻击者想要侵入一个在线系统，该系统将身份验证尝试的速率限制为每秒一次。另外，假设攻击者知道密码散列的所有参数（salt、散列类型等），但密码和散列后的密码除外。如果攻击者能够精确测量在线系统将真实密码的散列值与攻击者提供的密码的散列值进行比较所需的时间，那么他可以使用定时攻击提取部分散列值，并使用脱机攻击进行破解，从而绕过系统的速率限制。 首先，攻击者找到256个字符串，其哈希值以每个可能的字节开始。他将每个字符串发送到在线系统，记录系统响应所需的时间。耗时最长的字符串将是哈希的第一个字节与实际哈希的第一个字节匹配的字符串。攻击者现在知道第一个字节，可以以类似的方式继续攻击第二个字节，然后攻击第三个字节，依此类推。一旦攻击者对散列有足够的了解，他就可以使用自己的硬件来破解它，而不受系统的速率限制。 这里指的是: 我不知道你的密码, 但是密码的每一位肯定是在256个字符串中间的某一个, 假如代码不遵循 ‘操作时间相同’ 原则, 那我试这256次, 耗时最长的那一个肯定是第一位是对的, 然后我试第二个字符, 一直到我试出来密码或者我根据试出来的猜测出密码 在网络上运行定时攻击似乎是不可能的, 因为网络本身具有延迟。然而，有人 已经做到了，并且被证明是切实可行的。这就是为什么要遵循 ‘操作时间相同’ 原则 怎么编写遵循 ‘操作时间相同’ 的代码 前面的问题解释了为什么操作时间相同是必要的，这里解释了代码实际上是如何工作的。 1234567private static boolean slowEquals(byte[] a, byte[] b){ int diff = a.length ^ b.length; for(int i = 0; i &lt; a.length &amp;&amp; i &lt; b.length; i++) diff |= a[i] ^ b[i]; return diff == 0;} 代码使用 XOR“ ^”运算符来比较整数是否相等，而不是使用“ = =”运算符。原因如下。当且仅当两个整数完全相同时，XORing 的结果才为0。这是因为0 XOR 0 = 0,1 XOR 1 = 0,0 XOR 1 = 1,1 XOR 0 = 1。如果我们对两个整数中的所有位都应用这个函数，那么只有当所有位都匹配时，结果才是0。 所以, 如上面代码所示, 先判断这两个哈希值的长度, 如果其不一致, diff为 1, 但是并不直接退出, 而是在进行 for 循环, 结束后统一返回, 也就是说, 就算在代码中能够提前判断不正确也不立刻返回而是同样遍历一遍达到耗时相同的效果 我们需要使用XOR而不是“= =”运算符来比较整数的原因是“= =”通常被翻译/编译/解释为一个branch。例如，C代码“”可能编译为以下x86程序集：diff &amp;= a == b 12345678MOV EAX, [A]CMP [B], EAXJZ equalJMP doneequal:AND [VALID], 1done:AND [VALID], 0 分支使代码根据整数的相等性和CPU的内部分支预测状态以不同的时间量执行。 C代码应编译为以下内容，其执行时间不依赖于整数的相等性：diff |= a ^ b 123MOV EAX, [A]XOR EAX, [B]OR [DIFF], EAX 为什么要为你的网站设置密码加密 您的用户正在您的网站中输入密码。证明他们相信你的安全。 如果你的数据库遭到黑客攻击，而你的用户密码没有受到保护，那么恶意黑客就可以利用这些密码危害你在其他网站和服务上的用户帐户（大多数人在任何地方都使用相同的密码）。 风险不仅仅在于你的安全，还在于你的用户。 你要对你的用户的安全负责","link":"/2021/09/04/protect_user_pwd/"},{"title":"单例的实现","text":"单例的实现 提前祝大家过个好年 最近忙于项目,今天抽出点时间写写Blog 本篇就写Python的单例实现吧, 就拿自带的模块logging举例吧 Python的logging模块是Python自带的模块,可方便快捷的进行日志的记录 python doc logging本身就是单例的 该模块本身就是线程安全的,下面的注释摘抄至 doc The logging module is intended to be thread-safe without any special work needing to be done by its clients. It achieves this though using threading locks; there is one lock to serialize access to the module’s shared data, and each handler also creates a lock to serialize access to its underlying I/O. If you are implementing asynchronous signal handlers using the signal module, you may not be able to use logging from within such handlers. This is because lock implementations in the threading module are not always re-entrant, and so cannot be invoked from such signal handlers. 也就是说你不需要关注多线程的问题,只要 getLogger() 时指定当前空间即可 Loggers have the following attributes and methods. Note that Loggers should NEVER be instantiated directly, but always through the module-level function logging.getLogger(name). Multiple calls to getLogger() with the same name will always return a reference to the same Logger object. The name is potentially a period-separated hierarchical value, like foo.bar.baz (though it could also be just plain foo, for example). Loggers that are further down in the hierarchical list are children of loggers higher up in the list. For example, given a logger with a name of foo, loggers with names of foo.bar, foo.bar.baz, and foo.bam are all descendants of foo. The logger name hierarchy is analogous to the Python package hierarchy, and identical to it if you organise your loggers on a per-module basis using the recommended construction logging.getLogger(name). That’s because in a module, name is the module’s name in the Python package namespace. 意思是 logger.getLogger() 时传入相同的变量,会永远返回同一个对象,比如我在当前进程内的任何地方, 使用 log = logger.getLogger(\"work\") 生成的log对象一直是同一个对象,这就是单例模式,官方推荐传入 __name__ 因为他是Python包命名空间中模块的名称。 使用logging来讲单例纯粹是一时间没想到有啥能举例子的, 我们就先假如他不是单例的吧😬 不写单例的普通类 手动写一个单例完全是为了记忆单例模式的使用,只是以 logging 模块举例 先写一个普通的类, 这个类封装了logging类, 没有考虑单例问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import loggingimport threadingfrom logging import StreamHandler, handlersclass MyLogger: # log 日志 def __init__(self, *args, **kwargs): # 接收参数 self.level = (kwargs[\"level\"] if kwargs.get(\"level\") else \"debug\") # 日志等级 self.format = (kwargs[\"format\"] if kwargs.get( \"format\") else \"%(asctime)s % (levelname)-8s[%(filename)s:%(lineno)d(%(funcName)s)] %(message)s\") # 格式化结构 self.console = (kwargs[\"console\"] if kwargs.get(\"console\") else True) # 是否输出 self.file = (kwargs[\"file\"] if kwargs.get(\"file\") else None) # 保存的文件名 self.when = (kwargs[\"when\"] if kwargs.get(\"when\") else \"D\") # 日志文件按时间切分 self.backCount = (kwargs[\"backCount\"] if kwargs.get(\"backCount\") else 30) # 保留日志文件最大数量 # 日志级别匹配 self.level_relations = { \"debug\": logging.DEBUG, \"info\": logging.INFO, \"warning\": logging.WARNING, \"error\": logging.ERROR, \"critical\": logging.CRITICAL } self.logger = logging.getLogger(__name__) self.format = logging.Formatter(self.format) if not self.level_relations.get(self.level): self.level = \"debug\" self.logger.setLevel(self.level_relations[self.level]) if self.console: # 输出 streamHandler = logging.StreamHandler() streamHandler.setFormatter(self.format) self.logger.addHandler(streamHandler) if self.file: # 保存 timeHandler = handlers.TimedRotatingFileHandler( filename=self.file, when=self.when, backupCount=self.backCount, encoding=\"utf-8\" ) timeHandler.setFormatter(self.format) self.logger.addHandler(timeHandler)if __name__ == \"__main__\": def test(): l = MyLogger(level=\"debug\") l.logger.warning(\"test\") ts = [] for i in range(10): t = threading.Thread(target=test) t.start() ts.append(t) for t in ts: t.join() 如果我们同时起多个线程去使用, 可能就会出现意料之外的问题 利用 __new__ 实现单例 我们知道,python实例化时其实是先走 __new__ 再走 __init__ 我们可以重写 __new__ 方法,如果发现已生成对象直接返回该对象 同时为了防止多线程的资源竞争,我们使用线程锁来保证同一时间只有一个线程能访问 __new__ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import loggingimport threadingfrom logging import StreamHandler, handlersclass MyLogger: # log 日志 # 使用线程锁防止同一时间多个线程调用__new__ _instance_lock = threading.Lock() def __init__(self, *args, **kwargs): # 接收参数 self.level = (kwargs[\"level\"] if kwargs.get(\"level\") else \"debug\") # 日志等级 self.format = (kwargs[\"format\"] if kwargs.get( \"format\") else \"%(asctime)s %(levelname)-8s[%(filename)s:%(lineno)d(%(funcName)s)] %(message)s\") # 格式化结构 self.console = (kwargs[\"console\"] if kwargs.get(\"console\") else True) # 是否输出 self.file = (kwargs[\"file\"] if kwargs.get(\"file\") else None) # 保存的文件名 self.when = (kwargs[\"when\"] if kwargs.get(\"when\") else \"D\") # 日志文件按时间切分 self.backCount = (kwargs[\"backCount\"] if kwargs.get(\"backCount\") else 30) # 保留日志文件最大数量 # 日志级别匹配 self.level_relations = { \"debug\": logging.DEBUG, \"info\": logging.INFO, \"warning\": logging.WARNING, \"error\": logging.ERROR, \"critical\": logging.CRITICAL } self.logger = logging.getLogger(__name__) self.format = logging.Formatter(self.format) if not self.level_relations.get(self.level): self.level = \"debug\" self.logger.setLevel(self.level_relations[self.level]) if self.console: # 输出 streamHandler = logging.StreamHandler() streamHandler.setFormatter(self.format) self.logger.addHandler(streamHandler) if self.file: # 保存 timeHandler = handlers.TimedRotatingFileHandler( filename=self.file, when=self.when, backupCount=self.backCount, encoding=\"utf-8\" ) timeHandler.setFormatter(self.format) self.logger.addHandler(timeHandler) # 实例化时先走这里 def __new__(cls, *args, **kwargs): # 单例模式 if not hasattr(MyLogger, \"_instance\"): # 检查这个类有没有_instance属性 with MyLogger._instance_lock: # 获取锁 if not hasattr(MyLogger, \"_instance\"): # 这里获取到锁, 但是有可能在获取中有另一个线程已经创建了对象, 所以这里再判断一次 # 没有实例化过 MyLogger._instance = object.__new__(cls) # 调用object的__new__方法, 然后自动调用本类的__init__进行实例化, 将实例化的对象赋值 return MyLogger._instance # 如果已经有了这个属性直接返回if __name__ == \"__main__\": def test(): l = MyLogger(level=\"debug\", file=\"test.log\") l.logger.warning(\"test\") ts = [] for i in range(10): t = threading.Thread(target=test) t.start() ts.append(t) for t in ts: t.join() 运行测试代码, 发现还是会有问题 调试后发现, 即使代码正确捕捉到了 _instance 已经存在, 将其返回了, 但是因为 _instance 是 __new__ 的, 还没有进行 __init__ 调用, 所以每次又重新运行 __init__ , 因为 __init__ 里有给 logging 添加 handler 的操作, 所以随着线程的增多, 每次都会多添加一个 handler, 导致记录一次 logging 记录了多个 handler, 每次记录日志就会重复记录很多次 利用__call__实现 我们将代码改造成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import loggingimport threadingfrom logging import StreamHandler, handlersclass SingletonType(type): # 该类继承元类 _instance_lock = threading.Lock() # 线程锁 def __call__(cls, *args, **kwargs): # 单例模式 if not hasattr(cls, \"_instance\"): # 检查这个类有没有_instance属性 with cls._instance_lock: # 获取锁 if not hasattr(cls, \"_instance\"): # 这里获取到锁, 但是有可能在获取中有另一个线程已经创建了对象, 所以这里再判断一次 # 没有实例化过 cls._instance = super(SingletonType, cls).__call__(*args, **kwargs) # 没有实例化过, 调用type基类的__call__方法, 走正常的流程 return cls._instanceclass MyLogger(metaclass=SingletonType): # log 日志 # 使用线程锁防止同一时间多个线程调用__new__ _instance_lock = threading.Lock() def __init__(self, *args, **kwargs): # 接收参数 self.level = (kwargs[\"level\"] if kwargs.get(\"level\") else \"debug\") # 日志等级 self.format = (kwargs[\"format\"] if kwargs.get( \"format\") else \"%(asctime)s %(levelname)-8s[%(filename)s:%(lineno)d(%(funcName)s)] %(message)s\") # 格式化结构 self.console = (kwargs[\"console\"] if kwargs.get(\"console\") else True) # 是否输出 self.file = (kwargs[\"file\"] if kwargs.get(\"file\") else None) # 保存的文件名 self.when = (kwargs[\"when\"] if kwargs.get(\"when\") else \"D\") # 日志文件按时间切分 self.backCount = (kwargs[\"backCount\"] if kwargs.get(\"backCount\") else 30) # 保留日志文件最大数量 # 日志级别匹配 self.level_relations = { \"debug\": logging.DEBUG, \"info\": logging.INFO, \"warning\": logging.WARNING, \"error\": logging.ERROR, \"critical\": logging.CRITICAL } self.logger = logging.getLogger(__name__) self.format = logging.Formatter(self.format) if not self.level_relations.get(self.level): self.level = \"debug\" self.logger.setLevel(self.level_relations[self.level]) if self.console: # 输出 streamHandler = logging.StreamHandler() streamHandler.setFormatter(self.format) self.logger.addHandler(streamHandler) if self.file: # 保存 timeHandler = handlers.TimedRotatingFileHandler( filename=self.file, when=self.when, backupCount=self.backCount, encoding=\"utf-8\" ) timeHandler.setFormatter(self.format) self.logger.addHandler(timeHandler)if __name__ == \"__main__\": def test(): l = MyLogger(level=\"debug\", file=\"test.log\") l.logger.warning(\"test\") ts = [] for i in range(10): t = threading.Thread(target=test) t.start() ts.append(t) for t in ts: t.join() 在这个代码中, 我们指定了MyLogger 的元类是 SingletonType, 其实在python中实例化对象都是在声明这个类时执行type的__new__和__init__(这里每次声明一个新的类都会走一遍), 然后在创建对象时执行type的__call__, 在__call__中调用自定义类的__new__和__init__ 我们主要是修改了SingletonType 的__call__, 当实例化时首先判断是否存在了, 不存在再走super 也就是 type 的__call__流程 一文搞懂什么是Python的metaclass - 知乎 (zhihu.com) 当然对于自定义metaclass, 开发者们有相当一部分是认为其会破坏代码的可读性等, 如果你也这么觉得, 我们可以使用下一个方法 自写初始化方法 我们回看第一种方法, 之所以有问题是每次在__init__时会添加一个handler, 那么我们可以修改逻辑, 让他通过别的方法来添加handler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import loggingimport threadingfrom logging import StreamHandler, handlersclass MyLogger: # log 日志 # 使用线程锁防止同一时间多个线程调用__new__ _instance_lock = threading.Lock() def _instance_init(self, *args, **kwargs): # 接收参数 self.level = (kwargs[\"level\"] if kwargs.get(\"level\") else \"debug\") # 日志等级 self.format = (kwargs[\"format\"] if kwargs.get( \"format\") else \"%(asctime)s %(levelname)-8s[%(filename)s:%(lineno)d(%(funcName)s)] %(message)s\") # 格式化结构 self.console = (kwargs[\"console\"] if kwargs.get(\"console\") else True) # 是否输出 self.file = (kwargs[\"file\"] if kwargs.get(\"file\") else None) # 保存的文件名 self.when = (kwargs[\"when\"] if kwargs.get(\"when\") else \"D\") # 日志文件按时间切分 self.backCount = (kwargs[\"backCount\"] if kwargs.get(\"backCount\") else 30) # 保留日志文件最大数量 # 日志级别匹配 self.level_relations = { \"debug\": logging.DEBUG, \"info\": logging.INFO, \"warning\": logging.WARNING, \"error\": logging.ERROR, \"critical\": logging.CRITICAL } self.logger = logging.getLogger(__name__) self.format = logging.Formatter(self.format) if not self.level_relations.get(self.level): self.level = \"debug\" self.logger.setLevel(self.level_relations[self.level]) if self.console: # 输出 streamHandler = logging.StreamHandler() streamHandler.setFormatter(self.format) self.logger.addHandler(streamHandler) if self.file: # 保存 timeHandler = handlers.TimedRotatingFileHandler( filename=self.file, when=self.when, backupCount=self.backCount, encoding=\"utf-8\" ) timeHandler.setFormatter(self.format) self.logger.addHandler(timeHandler) # 实例化时先走这里 def __new__(cls, *args, **kwargs): # 单例模式 if not hasattr(MyLogger, \"_instance\"): # 检查这个类有没有_instance属性 with MyLogger._instance_lock: # 获取锁 if not hasattr(MyLogger, \"_instance\"): # 这里获取到锁, 但是有可能在获取中有另一个线程已经创建了对象, 所以这里再判断一次 # 没有实例化过 MyLogger._instance = object.__new__(cls) # 调用object的__new__方法, 然后自动调用本类的__init__进行实例化, 将实例化的对象赋值 MyLogger._instance._instance_init(*args, **kwargs) # 只有第一次初始化时才执行handler return MyLogger._instance # 如果已经有了这个属性直接返回if __name__ == \"__main__\": def test(): l = MyLogger(level=\"debug\", file=\"test.log\") l.logger.warning(\"test\") ts = [] for i in range(10): t = threading.Thread(target=test) t.start() ts.append(t) for t in ts: t.join() 保证每次只在需要的时候添加handler 即可","link":"/2021/09/04/realize_single_case/"},{"title":"Redis 常问知识点(简略)","text":"redis的数据类型 字符串(string) string是redis最基本的类型, 一个key对应一个value, string可以包含任何数据, 甚至是序列化的对象也可以, 一个value最大容量为512MB 哈希(Hash) Hash是一个键值对的集合, 类似于后端语言的字典, 是一个string类型的field和value的映射表, 很适合用来存储对象 列表(List) list是一个简单的字符串列表, 里面的元素是有序的, 在添加新元素的时候可以选择添加到列表的头部或尾部, 每个列表的数据长度最多为40多亿 集合(Set) Set是string类型的无序集合, 一个key对应多个string的value, 因为是通过哈希表实现的, 所以对集合的操作, 复杂度都是O(1) 有序集合(ZSet) 与普通的Set不同的是, ZSet的value是有序的. 在ZSet中, value还有一个score字段, 排序时按照score从小到大排序 Redis的过期失效机制 Redis在设置任何数据类型时, 都可以设置过期时间, 为-1是永不过期, 以秒为单位 Redis使用两种策略来删除过期的数据: 惰性清除 在访问key时, 如果key已经过期了, 将key删除 定时清理 Redis内部存在一个定时任务, 默认 25ms 执行一次. 每次清理都会遍历所有 db, 从每个 db 中随机取20个 key, 如果过期就删除key, 如果其中有5个 key 过期, 就继续对这个 db 剩下的 key 清理, 否则清理下一个 db. Redis数据淘汰 如果执行写入命令时, 发现内存不够, 就会按照配置好的淘汰策略清理内存, 淘汰策略分为以下几种: noeviction 不删除, 如果内存不够了, 直接返回写入错误 allkeys-lru 在所有key中, 优先删除最少使用(访问)的key(lru 算法) allkeys-random 在所有key中, 随机删除一部分key volatile-lru 在所有设置了过期时间的key中, 优先删除最少使用的key(lru 算法) volatile-random 在所有设置了过期时间的key中, 随机删除一部分key volatile-ttl 在所有设置了过期时间的key中, 优先删除剩余时间短的key volatile-lfu 在所有设置了过期时间的key中, 优先删除最少使用(访问)的key(lfu 算法) allkeys-lfu 在所有key中, 优先删除最少使用(访问)的key(lfu 算法) lru 算法 lru 算法是最开始的淘汰算法, lru 认为, 如果一个数据近期没有访问, 那么之后一段时间也不会访问 lfu 算法 lfu 算法在Redis4.0之后推出, lfu 认为, 一个数据在一段时间内被访问的次数越多, 之后被访问的概率越大. Redis持久化方案 RDB 把数据按照快照的形式保存在磁盘中, 达到触发条件时, 生成一个快照, 然后替换原有的持久化文件 每次进行save时, 会阻塞Redis的主线程, 向硬盘中写数据会造成一定的 I/O 压力 AOF 每次有新的数据操作, 就把新的数据持久化 每次对数据进行操作, 会将操作记录写入到aof_buf缓冲区的末尾, Redis每隔一段时间(默认是1s), 会将aof_buf缓冲区里的数据写入和保存到aof文件中. 将缓冲区的数据同步到磁盘时会有 I/O 压力, 而且写入的频率比RDB高很多, 同步过程中可能会造成 2s 的阻塞 防止AOF文件越来越大, 可以执行BGREWRITEAOF命令, 生成新的AOF文件, 新的修改记录会写进新的AOF文件 两者之间的区别 推荐使用 AOF 作为持久化 aof 比 rdb 更新的频率更高 aof 比 rdb 更安全, 但是更大 rdb 的性能比 aof 好 RDB和AOF混合 4.0新增的混合持久化方式, 在AOF文件中, 前半段是RDB格式, 后半段是AOF格式 结合了RDB和AOF的优点, 速度更快, 同时增量更新的数据通过AOF的方式保存, 减少可能的数据丢失 但是与4.0之前的版本不兼容, 同时阅读性差 持久化选择 必须要强调的是, 在不需要考虑数据丢失的情况下, 不需要考虑持久化. 单机情况下, 如果可以接收十几分钟的Redis不可用, 可以直接选择RDB持久化, 对性能的影响更小, 如果对数据丢失的容忍度不高, 只能选择AOF 如果你使用的是多节点部署, 最好还是开启持久化, 防止节点都出现故障时, 重新拉起后没有数据. 多节点可以选择将主节点不开启持久化, 从服务器开启AOF持久化, 并定时备份AOF文件. Redis当做缓存系统 Redis常被当做缓存使用, 将一些数据缓存在 Redis 中, 不用每次都访问数据库, 减少压力, 同时Redis自带的数据过期机制, 可以方便的维护缓存 缓存的常见使用方式 这里跟具体的业务有关 等待缓存自己过期 在用户请求某个数据时, 优先从Redis中查询是否存在这个数据, 如果存在直接返回, 如果不存在就从数据库中获取数据并录入到Redis中, 当数据库中的数据更新时, 不对redis中的老数据缓存进行处理, 等待缓存自己过期后再从数据库中拉取新的数据 优点: 不必关注缓存过期策略, 开发成本低, 管理成本低, 出 BUG 概率低 缺点: 完全依赖过期时间, 时间短容易造成缓存频繁失效, 时间长容易造成数据更新后老的缓存存在时间长 主动删除缓存 在用户请求某个数据时, 优先从Redis中查询是否存在这个数据, 如果存在直接返回, 如果不存在就从数据库中获取数据并录入到Redis中, 当数据库中的数据更新时, 删除redis里的缓存数据, 等待下次查询时, 走未命中缓存的流程 优点: 错误缓存的存在时间短, 只增加了更新数据时的删除缓存逻辑 缺点: 后端需要同时连接数据库和Redis, 损耗双倍的连接资源 主动更新缓存 在用户请求某个数据时, 优先从Redis中查询是否存在这个数据, 如果存在直接返回, 如果不存在就从数据库中获取数据并录入到Redis中, 当数据库中的数据更新时, 主动将Redis中的缓存更新为最新数据, 同时重置过期时间 为了保证速度和效率, 更新缓存这一步使用消费者来做, 将需要更新的数据推入消息队列, 由消费者来接收处理数据 优点: 使用消息队列, 降低代码的耦合性, 旧缓存存在时间很短 缺点: 如果多后端同时修改同一个缓存, 可能因为网络传输问题, 导致先后顺序错误, 未将数据修改为正确的最终结果, 同时引入了消息队列, 增加成本 订阅日志来修改缓存 假如数据库是MySQL, 可以通过订阅MySQL的binlog日志, 通过解析日志来获取数据, 同步到缓存中 优点: 完全解耦, 延迟低, 可靠性强 缺点: 开发成本高, 同步服务出现问题时Redis的缓存完全不可信 一般的方案一比较适用, 因为其开发快, Bug 少, 适合对缓存延迟没有特别要求的业务 缓存穿透 缓存穿透指的是用户想要获取一个一定不存在的数据, 因为缓存是在没有命中时才写入, 导致不存在的数据每次请求都需要落到数据库中, 如果流量很大有可能拖垮数据库 解决方法 如果某个数据查询不到, 比如查询name为s1的信息, 查询不到时, 将查询不到的标识也记录进缓存中, 设置较短的过期时间, 当第二次查询时, 直接命中缓存, 返回不存在 缓存血崩 缓存血崩指的是在设置缓存是设置了相同的过期时间, 导致缓存在某一时刻全部过期失效, 全部查询进数据库, 导致数据库压力瞬间增大 解决 在写入缓存时设置时间段内随机的过期时间, 例如20-30分钟的随机值过期 缓存击穿 在某个缓存刚好过期的时候, 有大量的请求并行获取这条数据, 因为缓存刚刚失效, 新的缓存还没落入, 导致都访问数据库查询数据, 数据库压力瞬间增大 解决 在缓存失效时, 在redis中留下标识位, 标志这个数据正在从数据库获取数据中, 当有新的请求获取这条数据时, 如果找到了这个标识位, 代表有其他的连接正在获取数据, 等待一段时间后直接从redis中重新获取数据, 而不从数据库中获取 可以使用redis的SETNX来插入标识位, SETNX只有key不存在时才创建(返回1), 存在则返回已经存在, 可以使用SETNX来判断当前有没有连接正在更新缓存 热 key 问题 什么是热 key 类似于微博热搜榜, 知乎热搜榜这些, 访问频率很高的 key 就成为热点 key, 当请求热点 key 时, 由于请求量很大, 可能会导致缓存服务宕机 危害 热 key 会让流量集中, 如果达到了硬件上限, 比如网卡满了, 会导致其他 key 访问出现堵塞, 甚至有可能直接将缓存服务或者这个节点失效, 如果是分片存储缓存, 则可能导致整个片缓存丢失, 其他片没有此数据, 同样的也可能导致缓存击穿, 引起业务崩溃 如何找到热 key 根据业务判断, 比如 热搜榜/ 推荐商品/ 热评 等在设计时就应该考虑到可能出现热 key 问题 客户端进行埋点收集统计后上报 服务有代理层的话可以在代理层进行收集和分析 如何解决 如果是分片, 增加分片副本, 分担读取流量 对热 key 进行备份, 读取时随机访问其中的一个副本 在客户端使用本地缓存, 只在本地缓存过期或者不存在或者用户主动点击刷新才请求缓存服务器 为什么不使用Memcached作为缓存框架 Memcached又大又重, 没有特别必要不使用 Redis速度更快 为什么不使用语言自带的数据结构作为缓存 多个后端无法进行数据共享 申请的内存有限 无法持久化 无法分布式 无法单独部署 缓存预热 在系统启动时, 将常用的数据主动写入到缓存中, 避免第一次请求时从数据库获取 方式 数据量不大时在工程启动时进行加载缓存 数据量大时, 通过执行定时脚本进行缓存刷新 数据量特大时, 优先保证热 key 加载到缓存 缓存降级 指的是在缓存失效或者缓存服务器直接挂掉的时候, 不去访问数据库, 直接返回默认数据. 降级服务一般是有损的, 使用时代表着问题出现了 RESP RESP是 Redis的序列化协议, 仅用作Redis的客户端与服务端进行通讯 RESP的优点是: 实现简单, 解析快速, 可读性强 RESP可以序列化不同的数据类型, 比如: 整形, 字符串, 数组等等, 并且专门为错误提供了类型 RESP是二进制安全协议, 在处理批量数据时, 也不用逐条单独的进行处理, 在批量传输数据时, 有参数标识了数据长度 RESP支持五中数据类型: 字符串: 以+开头 错误: 以-开头 整形: 以:开头 批量字符串: 以$开头 数组: 以*开头 架构模式 单机 单机部署在单个机器上 优点: 方便快速简单省资源 缺点: 内存容量和处理能力有限, 没办法高可用 主从复制 使用自带的主从复制功能, 将某个节点设置为主, 其他为从, redis将主中的数据复制到若干从节点中, 每次更新也是, 前提是能够连接 优点: 读(从)写(主)分离, 分散Redis压力 缺点: 无法保证高可用, 写数据的压力依旧全在主节点 哨兵 Redis Sentinel Documentation – Redis 哨兵模式也是主从模式, 只是有至少三个哨兵节点, 会不断的检查各个节点是否在正常运转, 当节点错误时, 如果是从节点则自动剔除, 主节点则进行故障转移, 如果是主节点下线, 则从剩下的从节点中选取一个节点成为主节点, 同时还会向指定的 API 向其他程序发送错误通知 优点: 高可用, 自动监控各个节点并进行故障转移 缺点: 主从模式, 当主节点出现问题时, 故障转移需要一定时间, 还有可能会丢弃数据, 而且没有解决主节点的压力 集群 Redis-cluster无中心结构, 其中的节点与其他节点数据共享, 每个节点都保存了数据和整个集群的状态, 每个节点都和其他节点连接 优点: 无中心结构, 节点间数据共享, 可动态新增和删除节点, 其中一个节点下线不影响其他节点 缺点: 数据隔离性差, 容易相互影响, 数据通过异步进行复制, 不保证数据强一致性 CAP C(一致性) 分布式系统中的所有数据, 在某一时刻是否等同于同样的值 A(可用性) 一部分节点故障后, 集群整体是否还能响应客户端的读写请求 P(分区容错性) 如果系统不能在指定的时限内达到数据的一致性, 就意味着发生了分区的问题, 此时需要在一致性和可用性之间做出选择 悲观锁和乐观锁 悲观锁 获取数据时都认为别人会修改这个数据, 所以在每次拿到数据的时候都会上锁, 别人拿到锁之前无法拿到数据 乐观锁 获取数据时都认为别人不会修改这个数据, 不会上锁, 但是在数据更新之前, 去数据库中查看别人有没有更新这个数据, 可以使用版本号来做, 比如Redis中的INCR命令 两种锁的选型 不能说哪个锁是绝对好的, 两者之间各有优缺, 具体还是需要看业务: 乐观锁适用于写很少的情况下, 冲突真的很少发送时, 不加锁可以省去加锁解锁的时间, 提高效率 当你在设计的过程中, 就意识到可能会发生数据的冲突, 那么就需要使用悲观锁来保证数据的正确性 为什么Redis是单线程 Redis6.0修改为多线程处理, 之前都是单线程 Redis6.0也只是处理网络数据和协议解析使用了多线程, 执行命令依旧是单线程 Redis是基于内存的操作, 因此CPU不是瓶颈, 其瓶颈更多是内存大小和网络带宽, 而使用多线程会提高Redis开发难度, 可能带来更多 BUG Redis6.0将网络数据处理修改为了多线程, 提高了网络处理的效率, 充分利用 CPU 资源, 分摊 I/O 任务, 效率基本上翻倍 优点 使用单线程编写Redis, 会使得代码变得清晰, 减少 BUG, 提高可读性, 也无需考虑数据的加锁问题, 提高性能, 也不存在线程或者进程切换带来的性能损耗 缺点 无法充分的发挥多核机器的优势 Redis为什么快 完全基于内存, 数据全部存储在内存中(不开启持久化), 没有磁盘 I/O 单线程模型, 没有上下文切换的开销, 不用加锁, 没有性能消耗 Redis主从同步实现 新节点 当一个新节点上线后, 如果是从节点, 会从主节点拉取全量数据, 进行全量同步 旧节点上线 节点将之前的最后一次同步的 id 和偏移量发送到主节点, 主节点进判断并将需要同步的数据推送到节点中 如果 id 与当前主节点最新的 id 不一致, 就会进行全量同步 如果 id 与当前主节点最新的 id 一致, 就会进行部分同步 全量同步 主节点重新生成一个RDB数据快照文件, 发送给节点, 节点解析RDB文件, 并将数据载入到节点中, 同时, 在同步过程中, 如果有新的操作, 也会由主节点记录后发送给节点 部分同步 根据偏移量, 主节点获取最后几次操作日志, 发送给节点 命令传播 在同步完成后, 就进入到了命令传播阶段. 当主节点有新的数据修改时, 异步的发送给其他节点 哨兵的实现故障转移 检测节点下线 每隔一段时间(默认2s), 哨兵节点会给主节点发送PING命令, 如果一段时间内没有收到回复, 哨兵就认为主节点客观下线 然后, 哨兵节点会向其他哨兵节点发送命令, 获取其他哨兵内这个节点的状态, 当其他哨兵也认为该节点下线到达一定数量后, 就确认确实客观下线了 哨兵选举 主节点客观下线后, 多个哨兵之间互相通信, 选举出一个领导者哨兵, 这个领导者哨兵对主节点进行故障转移 选举使用Raft算法, 就是最先检测到主节点下线的哨兵节点, 向其他哨兵节点发送申请成为领导者的命令, 如果其他哨兵没有同意过其他哨兵的申请, 就同意本次申请, 当同意的票数过半, 就成为领导者哨兵, 否则由另外的哨兵节点重新申请, 一般情况下, 第一次选举就会成功, 变成领导者 故障转移 领导者哨兵从节点中按照规则选出一个节点作为主节点, 筛选的规则是: 排除不健康的节点(下线的/断线的/最近5s 内没有回复哨兵INFO命令的/与旧的主节点断开时间长的) 根据优先级, 复制偏移量, 来选择一个从节点为主节点 然后向这个从节点发送升级命令, 让从节点变成主节点, 老的主节点更新为新的主节点的从节点 Redis的常用使用场景 缓存系统, 存储数据 排行榜系统, 使用有序集合 计数器系统, 比如 浏览量, 播放量, 在线人数 分布式锁, 多个后端使用同一个资源时, 加锁防止竞争 消息系统, 消息队列也提供了Redis作为中间件使用 Lua在Redis中的使用 什么是Lua The Programming Language Lua Lua是个脚本语言, 使用C语言编写, 目的是为了嵌入各种应用程序中, 为应用程序提供灵活的扩展定制功能 为什么使用Lua 减少网络开销: 对于客户端来讲, 可以将多个操作放置进一个脚本中执行, 只需要一次网络通信 原子操作: 脚本中通常有多步操作, Redis会将脚本作为一个整体执行, 中间不会插入其他命令, 避免资源竞争 可复用: 脚本可永远存在Redis中, 其他不同语言的客户端都可以复用这个脚本 方便: Redis的2.6之后就默认集成了lua环境, 无需引入插件或者修改配置文件等方式开启 lua的普遍用法 将脚本写进xx.lua中, 或者以变量的方式写在代码中 使用SCRIPT LOAD将脚本 load 进脚本缓存中, Redis返回这个脚本的sha1校验和 使用EVALSHA sha1 numkeys key [key ...] arg [arg ...] 调用函数 lua的参数 lua可以通过传参的方式来进行变量的输入,EVALSHA sha1 numkeys key [key ...] arg [arg ...] 分为几部分: sha1字段为load 时返回的校验和 numkeys指key的数量, 比如EVALSHA 5332031c6b470dc5a0dd9b4bf2030dea6d65de91 1 test 500 100 , 此时key有1个为test, arg有两个为500 和100 在脚本中, 通过 KEYS[1], KEYS[2]等等来按位置获取参数key, 通过ARGV[1], ARGV[2]等等来按位置获取参数arg 哨兵模式中lua的执行逻辑 在 load 脚本时, 会将脚本存储在每个节点 在调用脚本时, 会调用当前节点的脚本 redis规定, 在运行lua脚本时, 必须不能在代码中含有随机性质的代码, 例如生成随机数, 目的是防止在节点 a 执行脚本结果与节点 b 执行结果不一致 分布式锁 lua 脚本保证原子性 要点 使用 lua 脚本来完成加解锁步骤, 目的是 lua 脚本运行是原子性的, 防止资源竞争 value 随机生成, 目的是防止 key 过期时间设置的不合理, 在第一个锁加上后, 未主动解锁前, key 过期, 此时第二个线程请求加锁, 查证没有 key, 则正常加锁, 而第一个线程结束后进行解锁, 如果没有唯一标识进行判断, 就会将线程2的锁解除 加锁 使用setnx, 如果 key 存在则不做任何动作, key 不存在插入 value key 不存在时需要继续给这个 key 设置超时时间 value 要求随机生成 解锁 获取 key 的 value value 一致则删除 不一致代表已经被占用, 此时直接退出","link":"/2022/02/04/redis_interview/"},{"title":"requirements 语法","text":"requirements 语法 之前一直苦于一个问题,比如一些包在Win上安装不了,比如 uvloop 但是为了提高效率,代码中必须有这个模块 在运行中可以通过 os 模块判断是否使用, 那依赖文件呢? requirements.txt 要不要有 uvloop 呢? 其实我们可以通过语法来赋予 requirements.txt 一定的灵活性. 比如,我们使用 pip freeze &gt; requirements.txt 时,输出的大致为 12redis==3.2.1requests==2.21.0 每一行为 模块名==版本号, 这其实就是一种语法, 用来标记安装的模块的版本号, 其实他还有很多语法 详见官方文档 PEP508-doc 根据操作系统确定是否安装依赖 这里抛砖引玉,只写一个例子,就是根据系统OS判断要不要装某个模块 比如 uvloop, 不支持 Windows 我们可以这样写 1uvloop==0.14.0;platform_system==\"Linux\" 这样就是判断当前环境,如果为 Linux 就安装 0.14.0 的 uvloop 模块,如果是其他环境就 忽略 需要注意的是, Linux 是表格中写的可选值(详见官方文档的platform_system栏) 请严格区分大小写并不要写错,写错不会报错但是识别不了","link":"/2021/09/04/requirements_syntax/"},{"title":"Rust程序设计语言(1)","text":"安装 brew brew install rust 其他 官网 校验是否安装成功 安装后在命令行输入 rustc --version 如果看到rust的版本号即可, 例如 rustc 1.42.0 (b8cedc004 2020-03-09) 打开内置的文档 命令行输入 rustup doc, 会调用默认浏览器打开本地的内置文档 VsCode配置插件 插件商城输入 rust, 排第一的就是, 安装后打开rust项目会提示下载依赖, 同意即可 Hello,world 编写一个输出 hello, world 的程序 编写与执行 在某个地方新建文件夹 hello_world , 在文件夹下新建文件 main.rs , 编写代码如下 123fn main() { println!(\"hello, world\");} 保存后在当前目录下执行命令 rustc main.rs 会生成可执行文件 main, 执行这个文件, 打印 hello, world, 例如 1234➜ hello_world rustc main.rs ➜ hello_world ./main hello, world➜ hello_world 解析 rust的代码写在 .rs 后缀的文件中 rust推荐使用下划线方法来命名, 比如 hello_world 而不是 helloWorld 或者 helloworld rust的缩进是4个空格而不是一个tab 我们来解析代码 12fn main() {} fn代表定义一个函数, 这里定义了一个 main 函数, main函数是特殊的函数, 每个可执行的rust程序都从main函数开始, main() 代表这个函数不需要任何参数, 如果有的话应该定义在 () 中. () 后直接跟的 {} 代表函数本体, rust要求函数内部的代码都被这个大括号包裹, 而 main(){} 也代表了这个函数没有任何的返回值, 一般来说 { 与函数名在同一行, 并使用空格分开 rust的新版本自带了代码的格式化工具 rust fmt, 使用他可以将你的代码格式化的更加规范 在当前命令行中使用 rustfmt main.rs 查看格式化后的代码, 如果你的代码原来是 1fn main() {println!(\"hello, world\");} 格式化之后变成了 123fn main() { println!(\"hello, world\");} 而其中的 1println!(\"hello, world\"); 则是函数的逻辑, 上面说到了缩进是四个空格 println! 是rust内置的宏(macro), 类似于内置的语法, 而引入内置的函数则是 println, 这个之后再说明 \"hello, world\"是传入这个宏的参数, 是一个字符串, 然后该字符串就会被输出到命令行中 rust中使用 ; 作为一行的结束, 代表这个表达式结束, 下一个表达式开始 编译 rust是一门静态语言, 他也是需要编译的, 还记得我们写完后在命令行输入 rustc main.rs 吗, 这就是在编译代码, 编译完成后会生成编译平台可执行的文件 hello, cargo 认识cargo cargo 是rust的构建系统和依赖管理工具, 类似于golang的 go mod 在实际的编写项目中, 常常需要引入第三方的函数, 此时我们就需要 cargo 来帮助我们管理 cargo在安装 rust 时就已经安装到了你的电脑中 你可以在命令行中输入 1cargo --version 来查看cargo的版本, 例如 cargo 1.42.0 (86334295e 2020-01-31) 使用cargo建立项目 正常情况下我们一般使用 cargo 来建立新项目, 而不是手动建立文件夹 12345➜ student ls➜ student cargo new hello_cargo Created binary (application) `hello_cargo` package➜ student lshello_cargo 可以看到, 在执行 cargo new hello_cargo 之后, 原本空的文件夹下出现了 hello_cargo 文件夹, 这与我们执行 new 时的输入是相同的 我们的项目就在这里 里面已经多了几个文件, 目录树如下 12345678910111213141516171819.├── .git│ ├── HEAD│ ├── config│ ├── description│ ├── hooks│ │ └── README.sample│ ├── info│ │ └── exclude│ ├── objects│ │ ├── info│ │ └── pack│ └── refs│ ├── heads│ └── tags├── .gitignore├── Cargo.toml└── src └── main.rs 可以看到, cargo会在 hello-cargo 下初始化 git, 并且为我们生成了 .gitignore 忽略文件, 其中默认忽略了 /target 目录, 我们之后再介绍这个文件夹 同时生成了 cargo.toml 文件, toml格式是一种配置文件的格式, 他的内容大致如下 123456789[package]name = \"hello_cargo\"version = \"0.1.0\"authors = [\"example &lt;example@example.com&gt;\"]edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] 其中, package下为项目的信息, name为项目名, version为版本, authors为创建人(读取git的信息), edition这个项目创建时的大版本号, 目前是2018 里面的Value内容是可以修改的, 如果信息不准确你可以手动进行修改 我们真正的代码在 src/main.rs 中, 里面已经默认添加了 main 函数 123fn main() { println!(\"Hello, world!\");} rust希望你将所有的源代码放置在这个src目录下, 在根目录只放置 README.md/ 配置文件 等不涉及到代码的东西 如果当前目录已经在 git 的控制下, 那么使用 cargo new 默认不会创建git相关的文件, 但是你可以使用参数 --vcs=git 来强制创建, 更多用法可查看 cargo new --help 执行cargo cargo build 在命令行执行 123➜ hello_cargo git:(master) ✗ cargo build Compiling hello_cargo v0.1.0 (/Users/Work/Code/Rust/student/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.76s 我们会发现在目录下生成文件夹 /target 在里面的 /debug 中则有可执行文件 hello_cargo 我们执行他 12➜ hello_cargo git:(master) ✗ ./target/debug/hello_cargoHello, world! 所以, 我们 build 后会把生成的文件放置在 /target/debug 下, 当然 target 下还有很多文件, 我们之后再说 当某个项目第一次build, 还会在根目录生成 Cargo.lock 文件, 里面会存放一些具体的依赖, 一般不需要我们修改 cargo run 我们也可以使用 cargo run 来直接运行 build 出的程序, 与上面的方式没有区别 1234➜ hello_cargo git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/hello_cargo`Hello, world! 更强大的是, 如果你修改了源代码, 此时你无需执行 build, 直接执行 run 可自行 build然后执行 比如我们将 main.rs 修改为 1234fn main() { println!(\"Hello, world!\"); println!(\"Hello, world!\");} 保存后直接执行 cargo run 123456➜ hello_cargo git:(master) ✗ cargo run Compiling hello_cargo v0.1.0 (/Users/Work/Code/Rust/student/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.27s Running `target/debug/hello_cargo`Hello, world!Hello, world! 如果你事先没有 build, 也就是没有 target 文件夹, 执行 cargo run也会自己build cargo check 如果你只想确认你编写的代码是否可以运行而不想build出文件, 可以执行 cargo check, 可以在不生成可执行文件的前提下检查你的代码是否可以编译 123➜ hello_cargo git:(master) ✗ cargo check Checking hello_cargo v0.1.0 (/Users/chenming/Work/Code/Rust/student/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.13s cargo release 当你的项目需要发布或者迁出稳定版的时候, 使用 cargo build --release , 与普通的build不同的是, 该操作会优化生成的可执行文件, 提高执行速度等等, 当然, 因为优化原因, release 的耗时会比普通的 build 慢一些, 编译完成后会放置在 /target/release 文件夹下, 建议每次发布时都采用此方式编译 代码格式化 之前提到对某一个 rs 文件格式化代码使用 rustfmt xx.rs 如果对整个项目都格式化, 使用 cargo fmt 即可 如果你只想查看哪些是需要格式化的而不是直接修改好文件, 使用 cargo fmt -- --check 即可 最好对每个项目都是用targo来管理, 这样对项目来讲是最好的 设计猜谜游戏程序 这个程序的流程是, 用户输入一个数字, 然后程序自己随机出一个数字, 将这两个数字进行对比 建立新项目 使用 cargo 建立新项目并进入目录 12345➜ student cargo new guessing_game Created binary (application) `guessing_game` package➜ student lsguessing_game➜ student cd guessing_game 此时在 /src/main.rs 中已经有一个 main 函数了, 我们修改 main 函数 处理用户输入的数字 我们将代码修改成下面的 12345678910use std::io; // 引入标准库fn main() { println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 println!(\"你猜测的数字是: {}\", guess) // 输出获取到的输入} 值得注意的是, rust的注释是 //, 他不会编译//后的内容直到本行的结尾 这段代码的目的是读取用户输入的数字并输出 在第一行, 我们使用 use 语法来引入标准库 std::io, 类似于Python/Go的import 我们首先在输入框中输出提示 输入你的猜测数字: let 在第5行, 我们使用 let 来创建一个 变量, 但是与其他语言不同的是, 如果你只是使用 let, 那么你创建的变量的值是不可变的, 例如以下代码 12let a = \"1212\";a = \"1111\" ; 我们使用 cargo check 来检查会爆出错误 123456789101112error[E0384]: cannot assign twice to immutable variable `a` --&gt; src/main.rs:5:5 |4 | let a = \"1212\"; | - | | | first assignment to `a` | help: make this binding mutable: `mut a`5 | a = \"1111\" ; | ^^^^^^^^^^ cannot assign twice to immutable variableerror: aborting due to previous error 告诉我们不能对不可变的变量进行二次赋值 所以, 如果这个变量在以后需要重新赋值, 我们需要使用 let mut 12let mut a = \"1212\";a = \"1111\" ; 对于新建变量来说, 还是要根据用途来进行设计 12let mut a = \"1212\"; // 可变变量let b = \"dddd\" // 不可变变量 回到代码中, 我们看到, 我们新建了一个可变变量 guess, 他的值是 String::new() , 代表着使用了 String 的new 方法, 生成了一个 String 实例, String 代表着 rust 的字符串类型, 那么, String::new()代表生成了一个字符串类型的初始值, 也就是空字符串 ::new 代表调用 new 方法, new对于String 来说是关联函数(associated function) , 通常我们认为new是String 的静态方法, 一些面向对象的语言通常都有这个概念, 指的是类自有的方法, 而不需要对象去调用 在 rust 中, 新建一个新的类型的初始值通常使用 ::new 123io::stdin() // 调用stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 这三行代码其实是一条语句, 我们之前提到, ; 代表一段代码的结束, 所以rust会将这三行合并成一条语句来解析, 所以我们也可以将这三行缩短为, 这样会减少代码的可读性 1io::stdin().read_line(&amp;mut guess).expect(\"读取失败\"); 这段代码的意思是调用 io 模块的静态方法 stdin, 此方法回传一个实例 stdin, 匹配标准输入控制 然后继续调用实例的 read_line 方法, 此方法对标准输入代码执行 read_line 命令, 来获取使用者的输入信息, 我们还将生成的可变变量 guess 传递进去, 代表将用户输入的结果传递给 guess &amp; 代表这个参数是引用(reference) , 这让代码中的多个部分共享一个值, 不需要每次都复制值到一个新的地址, 引用是个复杂的概念, rust 可以让你安全又轻松的使用引用, 这个之后再讲, 你现在需要知道的是, 引用默认也是不可变的, 因此在后面加上 mut 代表这个是可变引用, 因此你必须写 &amp;mut guess 而不是 &amp;guess 使用Result类型处理可能出现的错误 .expect(\"读取失败\"); 这个代码处理了 read_line 方法可能出现的错误, 因为 read_line 返回了 io::Result 对象, 在 rust 中有很多库都有 Result类, Result实际上是种枚举(enumerations/enums), 枚举是拥有固定的值的类型, 这些值被称为枚举的变体(variants), 对于Result 来说, 变体有 ok 和 Error, ok代表成功, error 代表失败, 返回 Result 的目的是让使用者在错误发生时去处理这个问题, io::Result 自带了方法 expect, 当Result返回 时便会触发 expect, 如果是 ok 则代表没有出现问题, expect 不会对数据进行任何操作 当我们不对 expect 进行捕捉, 我们在编译时就会出现如下警告 1234567891011use std::io; // 引入标准库fn main() { println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess); // 调用stdin的方法read_line获取输入值 // .expect(\"读取失败\"); // 如果获取错误打印警告 println!(\"你猜测的数字是: {}\", guess) // 输出获取到的输入} 12345678910111213➜ guessing_game git:(master) ✗ cargo build Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game)warning: unused `std::result::Result` that must be used --&gt; src/main.rs:6:5 |6 | / io::stdin() // 调用函数stdin7 | | .read_line(&amp;mut guess); // 调用stdin的方法read_line获取输入值 | |_______________________________^ | = note: `#[warn(unused_must_use)]` on by default = note: this `Result` may be an `Err` variant, which should be handled Finished dev [unoptimized + debuginfo] target(s) in 0.62s 提示你没有处理可能出现的错误, 这里我们先添加 expect 保证其编译时不警告, 至于怎么去使用 expect 我们之后再说 println!打印输入的数字 1println!(\"你猜测的数字是: {}\", guess) // 输出获取到的输入 这里是将用户输入的数字打印出来, {}代表占位符, 将 guess 的值填充到 {} 中, {} 可以多个, 例如 1234let x = 5;let y = 10;println!(\"x = {} 而且 y = {}\", x, y); 输出 1x = 5 而且 y = 10 运行第一个部分 显然的, 程序还没有编写完成, 目前只能获取到用户的输入并打印出来 1234567➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game) Finished dev [unoptimized + debuginfo] target(s) in 0.60s Running `target/debug/guessing_game`输入你的猜测数字: 3你猜测的数字是: 3 生成随机的秘密数字 既然是猜谜游戏, 那么系统需要生成一个随机的数字来进行比对决定对错 使用Crate来获取更多功能 crate.io 是rust官方的仓库, 里面是rust各种各样的包(类似Python的pypi), 我们需要使用其中的一个包 rand 来帮助我们生成随机数字 如何将rand添加进我们的项目呢? 我们找到项目根目录下的Cargo.toml 文件, 并编辑 12345678910[package]name = \"guessing_game\"version = \"0.1.0\"authors = [\"xx &lt;xx@Outlook.com&gt;\"]edition = \"2018\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies]rand = \"0.5\" 我们在 [dependencies] 下新增包 rand 设置其版本为 0.5 ,这代表限制rand的版本在0.5`中, 避免出现兼容问题 然后我们使用 cargo build 能看到cargo自动下载了我们指定的包, 如果我们指定的包需要依赖其他的包, cargo也会自动帮我们下载(比如下面的 rand_core) 123456➜ guessing_game git:(master) ✗ cargo build Updating crates.io index Downloaded rand v0.5.6 Downloaded rand_core v0.3.1 ...... Finished dev [unoptimized + debuginfo] target(s) in 11.13s crate.io受网络影响, 在国内可能会出现通信问题, 可以使用第三方源比如USTC 如果你出现Blocking waiting for file lock on package cache错误, 尝试删除 ~/.cargo/.package-cache 文件 通过Cargo.lock确保项目依赖的正确性 当我们通过 cargo 安装新的依赖后, 我们会发现 Cargo.lock 文件也发生了变化, 增加了我们添加的依赖的具体的信息, 比如 123456789101112[[package]]name = \"rand\"version = \"0.5.6\"source = \"registry+https://github.com/rust-lang/crates.io-index\"checksum = \"c618c47cd3ebd209790115ab837de41425723956ad3ce2e6a7f09890947cacb9\"dependencies = [ \"cloudabi\", \"fuchsia-cprng\", \"libc\", \"rand_core 0.3.1\", \"winapi\",] cargo通过该文件来保证依赖的完整性和准确性, 当我们联合开发时, 只要将 Cargo.lock Cargo.toml 上传至项目中, 通过 cargo build 即可下载同样的依赖 升级Crate依赖 如果依赖有小版本的升级, 这通常是修复BUG和提高性能, 使用 cargo update 可以更新依赖, cargo会根据 cargo.toml 的语义化版本升级兼容该版本的小版本更新, 然后更新 cargo.toml 和 cargo.lock 中的内容 例如 你指定了rand 版本为 rand=0.8 则如果当前的版本是 0.8.3 新版本是 0.8.5会自动更新 如果新版本为 0.9.1 则与你指定的版本不同, 则不更新 如果你想更新到 0.9 版本, 需手动的编辑 toml 文件然后执行 update, 但是因为大版本的更新可能伴随着功能的修改, 必须要在手动升级前确认新版本的兼容性 生成随机数字 修改代码为 12345678910111213use std::io; // 引入标准库use rand::Rng;fn main() { println!(\"输入你的猜测数字: \"); // 打印 let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 println!(\"你猜测的数字是: {}\", guess) // 输出获取到的输入} 注意到我们新增了两行代码 1234 use rand::Rng; ....let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 在最开始, 我们引入了新的模块, rand::Rng, 需要注意的是, 我们在下面使用 rand 的时候并没有使用 Rng, 实际上这个 Rng 被称作 特征(trait) 它定义了数字生成器的工作方法, 必须将其引入才可以正常生成数字, 关于特征的更多情况, 我们之后再做讲解 重要的是生成随机数字这一段, 我们使用 rand包的thread_rng方法, 这会返回一个随机数字的生成器, 以当前的工作进程做为种子, 然后我们调用这个生成器的 gen_range 方法, 这个方法是由我们引入的 Rng 定义的, 他接受两个参数, 最大值和最小值, 我们传入 1, 101 代表生成 1-100的数字, 他是顾头不顾尾的, 所以我们要填到101 我们将其打印出来运行, 目的是测试功能是否正常, 事实上程序并未完成 12345678➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game) Finished dev [unoptimized + debuginfo] target(s) in 0.51s Running `target/debug/guessing_game`输入你的猜测数字: 生成的数字是: 61你猜测的数字是: 1 将猜测的数字与生成的数字进行比较 在上面, 我们生成了数字并获取到了用户输入的数字, 这一步我们将这两个数字进行比较 12345678910111213141516171819use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { println!(\"输入你的猜测数字: \"); // 打印 let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; println!(\"正确\"), }} 我们先引入了 std::cmp::Ordering , Ordering是一个枚举, 其变体为 Less, Greater, Equal. 当你对两个数字进行比较时会有这三种结果 cmp方法会对数字进行比较, 我们传入引用 secret_number , 目的是将 guess 与 secret_number 进行比较, 他会回传我们引入的 Ordering 变体 match 有时候, 我们需要对某个枚举的变体进行分别处理, 比如这里, 我们根据数字比较结果来提示用户数字的范围 所以我们使用 match 语法 match 由**分支(arms)组成, 每个分支包含一个模式(pattern)**和他的处理逻辑, 当匹配到这个模式, 就会执行对应的逻辑. 在执行完毕后则退出 math 不再进行下面的匹配, match的具体细节会在之后讲解 但是我们运行时会发现他会报错 1234567891011121314151617➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game)error[E0308]: mismatched types --&gt; src/main.rs:15:21 |15 | match guess.cmp(&amp;secret_number){ | ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer | = note: expected reference `&amp;std::string::String` found reference `&amp;{integer}`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `guessing_game`.To learn more, run the command again with --verbose. 这是因为, guess的类型是字符串, 而secret_number是数值,这就会导致 型別無法配對（mismatched types）, rust是静态类型的语言, 这两个是无法进行直接比较的 关于数值, rust有多个数值类型, 分别为 i3232位元数字, u32无符号32位元数字, i6464位元数字, u6464位无符号元数字等等, 默认的类型为 i32, 因此 secret_number 为 i32 同时我们也面临一个问题, 就是用户输入的不是数字怎么办 此时我们需要将guess转换为数字, 让他们可以比较, 将代码修改为 1234567891011121314151617181920use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { println!(\"输入你的猜测数字: \"); // 打印 let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 let guess: u32 = guess.trim().parse().expect(\"请输入正确的数字\"); println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; println!(\"正确\"), }} 我们添加了一行 1let guess: u32 = guess.trim().parse().expect(\"请输入正确的数字\"); 注意到, 之前有定义过 guess 为 string 类型, 这里是将他重新定义为一个u32类型的数值, 这在rust中被称为遮蔽(shadow), 我们遮蔽了原来的guess, 遮蔽让我们可以重复的使用一个变量名, guess.trim()可以去除这个字符串前后的空白和换行, 而.parse()则可以将字符串转换为数值类型, 同时我们捕捉expect, 如果转换失败, 则告诉用户出现错误了, 我们来执行代码 12345678➜ guessing_game git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/guessing_game`输入你的猜测数字: 生成的数字是: 54 1你猜测的数字是: 1太小了 12345678➜ guessing_game git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/guessing_game`输入你的猜测数字: 生成的数字是: 9ffff111thread 'main' panicked at '请输入正确的数字: ParseIntError { kind: InvalidDigit }', src/main.rs:13:22note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 使用户循环输入 目前的程序, 用户输入一次失败后就结束了程序, 为了提升体验, 我们需要让用户可以循环输入 loop loop语法可以生成一个死循环, 我们将代码修改为 12345678910111213141516171819202122use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 loop{ println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 let guess: u32 = guess.trim().parse().expect(\"请输入正确的数字\"); println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; println!(\"正确\"), } }} loop是一个死循环, 因此我们不停的输入数字去比较, 退出的方法只有强制关闭程序比如 ctrl+c, 或者输入一个无法解析为数值的字符串让他报错 12345678910111213➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game) Finished dev [unoptimized + debuginfo] target(s) in 0.40s Running `target/debug/guessing_game`生成的数字是: 79输入你的猜测数字: 11你猜测的数字是: 11太小了输入你的猜测数字: ffthread 'main' panicked at '请输入正确的数字: ParseIntError { kind: InvalidDigit }', src/main.rs:14:26note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace break 我们需要在用户猜中之后让他结束这个游戏, 使用 break 语法可以退出循环 12345678910111213141516171819202122232425use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 loop{ println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 let guess: u32 = guess.trim().parse().expect(\"请输入正确的数字\"); println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; { println!(\"你猜中了, 游戏结束\"); break; }, } }} 当猜中时, 使用break退出循环, 因为下面没有代码了,就直接退出 123456789101112➜ guessing_game git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/guessing_game`生成的数字是: 25输入你的猜测数字: 11你猜测的数字是: 11太小了输入你的猜测数字: 25你猜测的数字是: 25你猜中了, 游戏结束 对错误进行处理 现在, 用户输入一个无法转成数值的字符串会导致程序结束, 我们现在需要处理这个错误, 让他在错误时重新输入, 不让代码结束, 我们应该对每个错误都捕捉处理, 避免程序关闭, 这对每个程序都是一样的 我们将expect的处理变成一个match, 当分支检测到Error时进行特殊的处理 12345678910111213141516171819202122232425262728293031use std::io; // 引入标准库use rand::Rng;use std::cmp::Ordering;fn main() { let secret_number = rand::thread_rng().gen_range(1, 101); // 随机生成一个1-100的数字 println!(\"生成的数字是: {}\", secret_number); // 打印生成的数字 loop{ println!(\"输入你的猜测数字: \"); // 打印 let mut guess = String::new(); // 创建一个字符串变量guess io::stdin() // 调用函数stdin .read_line(&amp;mut guess) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 let guess: u32 = match guess.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; { println!(\"输入了一个无法解析的字符串\"); continue; }, }; println!(\"你猜测的数字是: {}\", guess); // 输出获取到的输入 match guess.cmp(&amp;secret_number){ Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; { println!(\"你猜中了, 游戏结束\"); break; }, } }} 我们在上面说过, parse返回一个枚举, 那我们就使用match判断这个枚举的分支, 他会有两种情况, OK 和Err, 如果是OK则代表正确, 我们将回传的num原样返回给guess, 如果Err 代表失败, 在失败时我们就不关心num是什么了, 所以我们使用_ 接受, 然后打印告诉用户出现了错误, 使用break关键字跳出当前的循环 12345678910111213141516➜ guessing_game git:(master) ✗ cargo run Compiling guessing_game v0.1.0 (/Users/Work/Code/Rust/student/guessing_game) Finished dev [unoptimized + debuginfo] target(s) in 0.44s Running `target/debug/guessing_game`生成的数字是: 82输入你的猜测数字: 11你猜测的数字是: 11太小了输入你的猜测数字: ff输入了一个无法解析的字符串输入你的猜测数字: 82你猜测的数字是: 82你猜中了, 游戏结束 如果是真实的程序, 应该将程序生成的数值打印去除, 这里保留只是为了方便调试","link":"/2021/09/04/rust_programming_language(1)/"},{"title":"Rust程序设计语言(2)","text":"变量与可变性 rust默认你创建的变量是不可变变量, 这是为了提高代码的安全性, rust鼓励你多使用不可变变量, 当然当你有需要的时候, 你可以将其变成可变变量 我们来创建一个新的项目来开始本章 cargo new variables 修改main.rs为 123456fn main() { let x = 5; println!(\"{}\", x); x = 6; println!(\"{}\", x);} 运行他, 会报错 1234567891011121314151617181920➜ variables git:(master) ✗ cargo run Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables)error[E0384]: cannot assign twice to immutable variable `x` --&gt; src/main.rs:4:5 |2 | let x = 5; | - | | | first assignment to `x` | help: make this binding mutable: `mut x`3 | println!(\"{}\", x);4 | x = 6; | ^^^^^ cannot assign twice to immutable variableerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0384`.error: could not compile `variables`.To learn more, run the command again with --verbose. 这里的错误是 cannot assign twice to immutable variable, 告诉你不能对不可变变量二次赋值 rust加入这个限制是为了代码的安全性, 因为对于开发者来说, 建立不可变变量的目的是不希望他能够修改, 如果你可以修改, 就可能会导致代码朝着无法预料的方向发展 在rust中, 编译器会确保你创建的不可变变量永远不被修改, 这能让你更加专注的考虑正常的逻辑 同时我们可以设置可变变量来解决问题, 使用 mut 来标识这个变量是可变的, 比如 123456fn main() { let mut x = 5; println!(\"{}\", x); x = 6; println!(\"{}\", x);} 此时就可以正常的运行 123456➜ variables git:(master) ✗ cargo run Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables) Finished dev [unoptimized + debuginfo] target(s) in 0.60s Running `target/debug/variables`56 对于大型的项目来说, 将变量设置成可变然后更改其值要比将变量设置为不可变然后读取其值复制给新的变量效率更高 变量与常量的区别 当你创建一个不可变变量 时, 你仍然可以在后续中修改他为可变变量, 但是对于常量来讲, 创建过后及 无法通过任何方式修改, 他不是预设无法修改, 而是永远无法修改 当你使用 const 关键字来创建常量时, 必须要指定他的类型 常量只能被常量表达式来设置, 不能通过某个函数的返回值或者运行时产生的数值来设置 rust的常量通常使用全大写的字母, 多个单词间使用_连接的方式来命名, 例如 1const MAX_POINTS: u32 = 100_000; // 创建常量 MAX_POINTS , 类型是u32, 值是100000 其中, 100000与100_000是一样的数值, 加_可以提升可读性 遮蔽(shadowing) 对于变量来讲, 我们可以在给某个变量赋值后, 通过遮蔽的方式来重新赋值, 或者说是覆盖 使用 let 来对一个已经存在的变量重新声明, 这样新的变量就会遮蔽原来的变量 12345678fn main() { let a = 1; println!(\"{}\", a); let a = 5; println!(\"{}\", a); let a = a+1; println!(\"{}\", a);} 输出 123156 需要注意的是, 我们在遮蔽时, 必须要带上let关键字, 否则会出现编译错误 我们知道, 使用 mut 可以设置可变变量, 他与遮蔽的不同是遮蔽对某个变量操作时可以设置不同的类型, 而mut不可以, 比如 12let spaces = \" \";let spaces = spaces.len(); 这里 spaces 从字符串类型遮蔽成了数字类型 12let mut spaces = \" \";spaces = spaces.len(); 这段代码是无法编译的, 因为mut无法改变值的类型 12345fn main() { let mut a = 1; println!(\"{}\", a); a = \"dadad\"} 123456789101112➜ variables git:(master) ✗ cargo run Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables)error[E0308]: mismatched types --&gt; src/main.rs:4:9 |4 | a = \"dadad\" | ^^^^^^^ expected integer, found `&amp;str`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `variables`. 数据类型 数据类型分为两种: 纯量(scalar)和复合(compound) Rust是一个静态类型语言, 因此, 所有变量在编译时编译器就必须知道他的类型, 如果无法得知就会导致编译错误 当然, 一般情况下, 编译器会自动识别出我们想要设置的类型, 比如 1let a = 1; 但是对于函数来讲, 有时候可能有多个可能的结果返回, 比如 1let guess: u32 = \"42\".parse().expect(\"error！\"); 在编译时就会出现错误 1234567891011 Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables)warning: unused variable: `guess` --&gt; src/main.rs:2:9 |2 | let guess: u32 = \"42\".parse().expect(\"這不是數字！\"); | ^^^^^ help: consider prefixing with an underscore: `_guess` | = note: `#[warn(unused_variables)]` on by default Finished dev [unoptimized + debuginfo] target(s) in 0.40s Running `target/debug/variables` 纯量 纯量的类型代表单一的值, rust有四种纯量, 分别为 整数/浮点数/字符/布尔 整数 整数指的是没有小数点的数字, 之前我们使用过 u32, 还有其他的几种 长度 带正负号 不带正负号(正整数) 8位 i8 u8 16位 i16 u16 32位 i32 u32 64位 i64 u64 128位 i128 u128 系统架构 isize usize 首先, 带正负号与不带正负号的区别就是字面意思, 带正负号可以表示负数, 不带则只能表示正整数 然后, 长度代表了这个变量在记忆体内存储的大小, 也影响了数字的范围, 而isize和usize则与系统有关, 如果你的系统是32位, 则是32位的长度, 64就是64 对于某个数字, 你可以将类型拼在值后面来标识这个值是什么类型, 比如54u16代表是u16位的值是54 默认的整数是i32, 这在rust中是运行速度最快的类型 整数溢出 举个例子, 如果你创建了一个u8的变量, 那么他的长度只有8位, 只能容纳 1-255 之间的数值, 如果你给他赋值成 256, 或者大于255的数字, 就会发生整数溢出, 如果你是在默认情况下编译的话, 则会在运行时造成panic错误, 如果你是编译成稳定版(release), 程序在检测到溢出时会处理这个错误, 并不会让他直接panic但是会使原有的值发生变化, 造成逻辑错误. 浮点数 浮点数有 f32(单精度) 和 f64(双精度), 默认是f64 12345fn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32} 数值运算 数值之间当然可以进行运算 12345678910111213141516fn main() { // 加 let sum = 5 + 10; // 減 let difference = 95.5 - 4.3; // 乘 let product = 4 * 30; // 除 let quotient = 56.7 / 32.2; // 求余 let remainder = 43 % 5;} 布尔值 true(真)和false(假) 12345fn main() { let t = true; let f: bool = false; } 字符 单个字符使用单引号来表示, 例如一个字母/中文/表情, 当我们需要表达不止一个字符时, 就需要使用双引号 12345678fn main() { let c = 'z'; let z = 'ℤ'; let heart_eyed_cat = '😻'; let a = \"1111111\"; let b = '我'; let d: char = '他';} rust的char与unicode类似, 确又不是完全一样, 我们之后会详细解释 复合类型 复合类型有两个最基本的, 元组(tuples)和阵列(arrays) 元组 元组是将不同或相同的数据类型放置到一起的常见用法, 需要注意的是元组的长度在确定后无法更改 元组的设立是用括号括起来, 因为一个元组内的每个数据都有可能有独立的数据类型, 所以在必要时也可以指定每个的类型, 如果不指定rust会自己判断 123fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1);} 这里的变量tup就是元组, 元组内有多个元素, 我们可以使用模式配对(pattern matching), 来获取每一个元素的值 1234567fn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\"y 的數值為：{}\", y);} 这种将元组打散然后分别赋值给 x/y/z, 需要保证接受者和元组的长度是一致的, 这种也被成为解构(destructuring) 还有一种通过索引来取其中某个值的方法, 在rust中通过.来获取, 比如 123456789fn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2;} 索引和其他语言一样, 都是从0开始的, 并且不能超出索引大小 阵列 与元组不同的是, 一个阵列的元素必须是同一个数据类型, 而且和元组一样, 阵列长度在确定后无法更改 阵列的设立是使用中括号, 例如 123fn main() { let a = [1, 2, 3, 4, 5];} 当你希望将数据放置在堆栈上而不是堆上时(我们之后会详细解读), 或者当你想要确保始终拥有固定数量的元素时, 你可以使用阵列来做 当你不知道有多少个数据时(很多时候是这样), 阵列和元组都将不适合使用, 此时, rust标准库提供了**矢量(vector)**类型, 他是可以改变长度的, 如果你不确定应该使用矢量还是阵列时, 你应该使用矢量来创建, 矢量的具体细节之后再讲述 当你明确的知道数据的数量时, 你就可以放心的使用阵列, 例如, 每年有12个月 12let months = [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"]; 这里rust会自己判别阵列的类型和长度, 当然你也可以指定 1let a: [i32; 5] = [1, 2, 3, 4, 5]; 这里, i32 是每个元素的类型, 5是这个阵列的长度 如果你想给每个元素都设置一个默认值, 可以这样写 1let a = [3; 5]; 会生成阵列[3, 3, 3, 3, 3], 即a的长度为5, 每个默认值都是3 获取阵列元素 我们可以使用索引来获取对应的值 123456fn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1];} 无效的阵列元素获取 对于/阵列来讲, 当你获取不存在的索引是, 有可能会出现编译通过而运行时出现错误的情况, 比如 1234567fn main() { let a = [1, 2, 3, 4, 5]; let element = a[10]; println!(\"元素的數值為：{}\", element);} 我们使用check功能发现并没有检查出错误 123➜ variables git:(master) ✗ cargo check Checking variables v0.1.0 (/Users/Work/Code/Rust/student/variables) Finished dev [unoptimized + debuginfo] target(s) in 0.12s 但是当我们运行时, 当执行到这里时, rust会抛出错误, 而对于其他的底层语言(例如C), 则不会报错但是会得到不可预料的值, rust这样做减少了不可预料的BUG的产生, 这是Rust的安全原则之一 123456789101112131415➜ variables git:(master) ✗ cargo run Compiling variables v0.1.0 (/Users/Work/Code/Rust/student/variables)error: index out of bounds: the len is 5 but the index is 10 --&gt; src/main.rs:4:19 |4 | let element = a[10]; | ^^^^^ | = note: `#[deny(const_err)]` on by defaulterror: aborting due to previous errorerror: could not compile `variables`.To learn more, run the command again with --verbose.","link":"/2021/09/04/rust_programming_language(2)/"},{"title":"Rust程序设计语言(3)","text":"运算符 运算符本身与其他语言一样, 本来原版书没写, 但是还是有用的, 这里还是稍微记一下 Rust 语言支持以下四种运算符 算术运算符 位运算符 关系运算符 逻辑运算符 算数运算符 名称 运算符 加 + 减 - 乘 * 除 / 求余 % Rust 不支持自增(++)和自减(–) 关系运算符 名称 运算符 大于 &gt; 小于 &lt; 大于等于 &gt;= 小于等于 &lt;= 等于 == 不等于 != 逻辑运算符 名称 运算符 逻辑与 &amp;&amp; 逻辑或 || 逻辑非 ! 位运算符 位运算符的相关操作逻辑,可自行百度 名称 运算符 位与 &amp; 位或 | 异或 ^ 位非 ! 左移 &lt;&lt; 右移 &gt;&gt; 函数 函数在rust中无处不在, 对于rust程序来讲, main函数是许多程序的入口, 之前我们知道, 建立一个函数的关键字是 fn rust使用下划线命名法来命名, 这个之前也有提到过 我们来看下面的程序 123456789fn main() { println!(\"Hello, world!\"); another_function();}fn another_function() { println!(\"hello another_function!\");} rust中, 函数的范围由 {} 指定, 也就是说, 这段代码中有两个函数, main 和 another_function, 程序的入口是 main, 在 main 中调用了 another_function, 当我们从上往下看的时候, 会发现在 another_function 未定义之前就调用了 another_function, 这样也是可以的, rust 并不会报错, 只要你存在, 不管在哪里都可以. 在函数中逻辑是从上到下执行的, 因此会先打印 Hello, world!, 在执行 another_function, another_function 中会打印 hello another_function! 123456➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 1.00s Running `target/debug/fun`Hello, world!hello another_function! 函数的参数 很多时候, 函数需要根据参数来进行操作, rust需要在建立函数时定义参数的名称与类型, 写在函数名后的 () 中 1234567fn main() { another_function(5);}fn another_function(x: i32) { println!(\"x = {}\", x);} 12345➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.40s Running `target/debug/fun`x = 5 对于函数 another_function 来讲, 我们设置了一个参数 x, 他是 i32 类型, 需要注意的是, 我们必须对每个参数都说明类型, 不然会导致编译错误 当某个函数的需要多个参数时, 我们这样写 12345678fn main() { another_function(1, 2);}fn another_function(x: i32, y: i32) { println!(\"x = {}\", x); println!(\"y is {}\", y);} 函数的内容包含了陈述式和表达式 函数的内容是由一系列的 陈述式(statements) 和在后面的可选的 表达式(expression) 组成的, rust是基于表达式的语言, 下面我们来介绍这两个的区别 陈述式是一系列动作的指令, 陈述式不回传任何数据 表达式则是通过逻辑处理来产生结果, 也就是说表达式返回数据 比如代码 123fn main() { let a = 1;} 这里的mian函数本身是一个陈述式, 因为他不返回任何数据 这里的 let a = 1; 也是一个陈述式, 因为他不返回任何数据, 因为他不返回任何数据, 所以你不能接受他的返回数据, 例如 123fn main() { let b = (let a = 1);} 这就会导致编译出错, 因为let a = 1是一个陈述式, 他不返回任何数据, 但是你试图使用返回值来作为 b 的值 而表达式则会给出结果, 比如 1+1 会返回2, 表达式可以是陈述式的一部分, 比如 let a = 1中的1就是一个表达式, 他返回了一个1, 同时我们使用{}产生的作用域也是一个表达式, 例如 12345678910fn main() { let x = 5; let y = { let x = 3; x + 1 }; println!(\"y = {}\", y);} 其中, 表达式 1234let y = { let x = 3; x + 1}; 会返回4, 此时使用 y 接收就能获得 4, 这是因为 x + 1后面并没有带上 ;, 如果你加上了 ; 则不会返回结果, 这是必须要记住的 函数返回值 函数的返回值定义是-&gt;, 写在接收参数的()后, 同样的要定义他的类型. 但是无需命名 123456789fn five() -&gt; i32 { 5}fn main() { let x = five(); println!(\"x = {}\", x);} 需要注意, five 函数里直接写了5, 但是没有跟;, 所以他会返回5, 同时 five 定义了返回值是一个, 类型是 i32 同时 main 中定义了 x 来接受 five 的返回值, 所以 x 为 5, 同时函数 five 为表达式 12345➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.57s Running `target/debug/fun`x = 5 当我们为 5 加上 ;, five 就变成了 陈述式, 此时在编译时就会报错 123456789101112131415161718➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun)error[E0308]: mismatched types --&gt; src/main.rs:1:14 |1 | fn five() -&gt; i32 { | ---- ^^^ expected `i32`, found `()` | | | implicitly returns `()` as its body has no tail or `return` expression2 | 5; | - help: consider removing this semicolonerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `fun`.To learn more, run the command again with --verbose. 当这个函数有多个返回值, 则使用()包裹 123456789fn five() -&gt; (i32, i32) { (5, 6)}fn main() { let x = five(); println!(\"x0 = {}, x1 = {}\", x.0, x.1);} 12345➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.25s Running `target/debug/fun`x0 = 5, x1 = 6 注释 一个好的程序, 注释并不可少. 多写**注释(comments)**对自己和他人都有好处 编译器在编译时会将注释部分去除, 所以不用担心会增加编译文件的大小 rust的注释使用 // , 一般会在 // 后加上一个空格 1// 这里是注释 需要注意的是, //标识改行为注释, 因此 // 后一直到本行结束之间的所有东西都被编译器认为是注释 当需要多行注释时, 为每一行都加上 // 即可 12// 注释1// 注释2 注释也可以加在某一行代码的结束 123fn main() { let x = 3; // 注释} 控制流程 在程序中, 一个流程通常有多个分支, 我们需要在某个时候根据某个条件来决定怎么做 if表达式 if表达式根据条件的不同执行不同的代码. 当满足条件时就执行这段代码, 不满足时就不执行 12345678fn main(){ let a = 5; if a &lt; 5{ println!(\"&lt;5\") }else{ println!(\"&gt;=5\") }} 这里我们判断a是否小于5, 根据不同的情况来打印不同的结果 需要注意的是, 其中某个分支的逻辑必须使用 {} 包裹 并且, a&lt;5 返回的是一个bool, rust中if表达式只能使用bool来进行判断, 加入我们将代码修改成 12345678fn main(){ let a = 5; if a{ println!(\"&lt;5\") }else{ println!(\"&gt;=5\") }} 则会导致编译失败, 这是因为a是int 而不是bool 1234567891011121314➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun)error[E0308]: mismatched types --&gt; src/main.rs:3:8 |3 | if a{ | ^ expected `bool`, found integererror: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `fun`.To learn more, run the command again with --verbose. rust并不会将其他非bool值自动转化成bool 使用 else if 处理多个情况 使用多个else if和if和else一起使用来处理多个分支 123456789101112fn main(){ let a = 5; if a == 4{ println!(\"4\") }else if a == 5{ println!(\"5\") }else if a == 5{ println!(\"51\") }else{ println!(\"not\") }} 需要注意的是, 在这个代码块中, 判断只会成功一次, 也就是说, 在这个多重判断中, 即使a可以为true两次, 也只会执行一次, 也就是只会打印5 而不是51 当你有多个分支时, 不推荐使用大量的 else if, 这样会导致代码看起来不友好, 后面会推荐使用match 在let中使用if 123456789fn main(){ let t = true; let s = if t{ 5 }else{ 6 }; println!(\"{}\", s)} 这里就是, 我们在赋值的时候, 根据t的不同来返回不同的值给s, 这里注意, 写一个数字本身就是一个表达式, 也就是说如果t为true, s就为5, 其他为6 12345➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.36s Running `target/debug/fun`5 这种写法有一个限制, 就是if的返回值必须是同一类型, s不可能有可能是int有可能是str, 例如 123456789fn main(){ let t = true; let s = if t{ 5 }else{ \"6\" }; println!(\"{}\", s)} 这种就会报错 123456789101112131415161718192021➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun)error[E0308]: `if` and `else` have incompatible types --&gt; src/main.rs:6:9 |3 | let s = if t{ | _____________-4 | | 5 | | - expected because of this5 | | }else{6 | | \"6\" | | ^^^ expected integer, found `&amp;str`7 | | }; | |_____- `if` and `else` have incompatible typeserror: aborting due to previous errorFor more information about this error, try `rustc --explain E0308`.error: could not compile `fun`.To learn more, run the command again with --verbose. 因为rust在编译时就必须准确的知道s的类型, 但是s可能会有两种类型, 这样会导致代码有可能出现问题 循环 循环可以重复的执行某段代码 rust有三种循环: loop/while/for loop loop关键字会让rust一直重复执行代码一直到明确的要求结束 看以下代码 12345fn main(){ loop{ println!(\"a\") }} 此程序是死循环, 不停的打印字符串a, 因为没有使用关键字break, 所以不会终止循环 从循环返回 12345678910fn main(){ let mut c = 0; let r = loop{ c += 1; if c == 10{ break c*2; } }; println!(\"{}\", r)} 我们可以定义一个变量来接受某个循环的返回值 while循环 我们使用循环时, 多会使用一个大的嵌套, 比如loop{}, 其实rust中的while可以在特定的场景下减少代码, 比如 12345678fn main(){ let mut c = 4; while c != 0{ c -= 1; println!(\"{}\", c) } println!(\"OK\")} while可以与一个判断条件一起使用, 比如这里就是判断c!=0, 如果c!=0为false时则退出循环. 而在循环内则对c进行-1, 代码逻辑等同于 1234567891011fn main(){ let mut c = 4; loop { c -= 1; println!(\"{}\", c); if c == 0{ break; }; } println!(\"OK\")} for循环 使用遍历来描述for可能更为准确, for并不是死循环, 而是遍历完成就结束 123456fn main(){ let c = [1, 2, 3, 4]; for i in c.iter(){ println!(\"{}\", i) }} 这里我们遍历c这个数组, 注意c.iter()可以生成一个range, 每次抛出c的一个元素, 使用for可以防止索引超出范围 12345678➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.42s Running `target/debug/fun`1234 再比如 123456fn main(){ let c = [1, 2, 3, 4]; for i in c.iter().rev(){ println!(\"{}\", i) }} rev方法可以翻转一个range, 因此会输出4-1 12345678➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun) Finished dev [unoptimized + debuginfo] target(s) in 0.32s Running `target/debug/fun`4321 练习 编写程序实现摄氏度与华氏度之间的转换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455use std::io; // 引入标准库fn main(){ loop { println!(\"选择转换模式: 1: 摄氏度转华氏度 2: 华氏度转摄氏度 其他任意键: 退出 &gt;&gt;&gt;\"); let mut model = String::new(); io::stdin().read_line(&amp;mut model).expect(\"读取失败\"); // 如果获取错误打印警告 if model.trim() == \"1\"{ println!(\"输入你要转换的摄氏度&gt;&gt;&gt;\"); let mut c = String::new(); io::stdin().read_line(&amp;mut c).expect(\"读取失败\"); // 如果获取错误打印警告 let c: f32 = match c.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; { println!(\"输入了一个无法解析的字符串\"); continue; }, }; let f = transformation_centigrade(c); println!(\"摄氏度:{}对应的华氏度是:{}\", c, f); } else if model.trim() == \"2\"{ println!(\"输入你要转换的华氏度&gt;&gt;&gt;\"); let mut f = String::new(); io::stdin().read_line(&amp;mut f).expect(\"读取失败\"); // 如果获取错误打印警告 let f: f32 = match f.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; { println!(\"输入了一个无法解析的字符串\"); continue; }, }; let c = transformation_fahrenheit_degree(f); println!(\"华氏度:{}对应的摄氏度是:{}\", f, c); } else{ println!(\"exit.\"); break; } }}// 华氏度2摄氏度fn transformation_fahrenheit_degree(f: f32) -&gt; f32{ return (f-32.0)/1.8;}// 摄氏度2华氏度fn transformation_centigrade(c: f32) -&gt; f32{ return 32.0+c*1.8;} 运行 12345678910111213141516171819202122232425262728➜ fun git:(master) ✗ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/fun`选择转换模式: 1: 摄氏度转华氏度 2: 华氏度转摄氏度 其他任意键: 退出 &gt;&gt;&gt;1输入你要转换的摄氏度&gt;&gt;&gt;222摄氏度:222对应的华氏度是:431.59998选择转换模式: 1: 摄氏度转华氏度 2: 华氏度转摄氏度 其他任意键: 退出 &gt;&gt;&gt;2输入你要转换的华氏度&gt;&gt;&gt;4444华氏度:4444对应的摄氏度是:2451.111选择转换模式: 1: 摄氏度转华氏度 2: 华氏度转摄氏度 其他任意键: 退出 &gt;&gt;&gt;qexit. 生成 n 阶斐波那契数列 123456789101112131415161718192021222324252627282930313233343536use std::io; // 引入标准库fn main(){ loop { println!(\"输入期望的n&gt;&gt;&gt;\"); let mut n = String::new(); io::stdin().read_line(&amp;mut n).expect(\"读取失败\"); let n: usize = match n.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; { println!(\"输入了一个无法解析的字符串\"); continue; }, }; let mut c: usize = 0; let mut s0 = 0; let mut s1 = 1; println!(\"结果: \"); loop{ if c == n{ break; }; let mut f = 0; if c == 0{ f = 0; }else{ f = s0+s1; } s0 = s1; s1 = f; c+=1; print!(\"{} \", f) } println!(\"\") }} 运行 123456789101112131415161718192021➜ fun git:(master) ✗ cargo run Compiling fun v0.1.0 (/Users/Work/Code/Rust/student/fun)warning: value assigned to `f` is never read --&gt; src/main.rs:23:21 |23 | let mut f = 0; | ^ | = note: `#[warn(unused_assignments)]` on by default = help: maybe it is overwritten before being read? Finished dev [unoptimized + debuginfo] target(s) in 0.48s Running `target/debug/fun`输入期望的n&gt;&gt;&gt;3结果: 0 1 1 输入期望的n&gt;&gt;&gt;1结果: 0 打印歌曲 “The Twelve Days of Christmas” 的歌词, 使用循环 1234567891011121314151617181920212223fn main(){ let days = [\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\", \"tenth\", \"eleventh\", \"twelfth\"]; let gift = [\"a partridge in a pear tree\", \"two turtle doves\", \"three French hens\", \"four calling birds\", \"five golden rings\", \"six geese a-laying\", \"seven swans a-swimming\", \"eight maids a-milking\", \"nine ladies dancing\", \"ten lords a-leaping\", \"eleven pipers piping\", \"twelve drummers drumming\"]; let mut n = 0; println!(\"The Twelve days of Christmas\"); for d in days.iter(){ print!(\"On the {} day of Christmas, my true love sent to me: \", d); let mut gi = n; loop{ if gi != 0{ print!(\"{}, \", gift[gi]); gi -= 1; }else if n == 0{ print!(\"{} \\n\", gift[gi]); break; }else{ print!(\"and {} \\n\", gift[gi]); break; } }; n += 1 };} 运行 12345678910111213The Twelve days of ChristmasOn the first day of Christmas, my true love sent to me: a partridge in a pear tree On the second day of Christmas, my true love sent to me: two turtle doves, and a partridge in a pear tree On the third day of Christmas, my true love sent to me: three French hens, two turtle doves, and a partridge in a pear tree On the fourth day of Christmas, my true love sent to me: four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the fifth day of Christmas, my true love sent to me: five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the sixth day of Christmas, my true love sent to me: six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the seventh day of Christmas, my true love sent to me: seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the eighth day of Christmas, my true love sent to me: eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the ninth day of Christmas, my true love sent to me: nine ladies dancing, eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the tenth day of Christmas, my true love sent to me: ten lords a-leaping, nine ladies dancing, eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the eleventh day of Christmas, my true love sent to me: eleven pipers piping, ten lords a-leaping, nine ladies dancing, eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree On the twelfth day of Christmas, my true love sent to me: twelve drummers drumming, eleven pipers piping, ten lords a-leaping, nine ladies dancing, eight maids a-milking, seven swans a-swimming, six geese a-laying, five golden rings, four calling birds, three French hens, two turtle doves, and a partridge in a pear tree","link":"/2021/09/04/rust_programming_language(3)/"},{"title":"Rust程序设计语言(4)","text":"前言 所有权系统是Rust最为独特的性质, 他让Rust无需垃圾回收即可保障内存的安全. 所以, 理解所有权怎么工作是非常重要的, 本章, 我们将讲到所有权和相关的功能, 借用, slice以及Rust如何在内存中放置数据 什么是所有权 rust的核心之一就是所有权 对于运行中的程序来说, 他必须对使用的内存进行管理, 同时对于运行中产生的垃圾, 程序也需要进行销毁, 以免出现内存泄露等问题 某些语言自带了垃圾回收机制, 在程序运行时不断的扫描寻找不再使用的内存将其释放 另一些语言要求程序员通过代码来自己分配和释放内存 而rust使用的是第三种, 通过所有权系统来管理内存, 编译器在编译时会根据规则来进行检查. 在运行时可以保证不会减慢程序的运行速度 栈(stack)与堆(heap) 栈和堆都是在程序运行中可供使用的内存, 他们的结构并不相同, 栈是有序的, 他就像一个水桶, 最上面的是栈顶, 向这个栈里存放数据叫做进栈, 他像一个水桶, 所以存储数据只能存放在水桶的最上面, 当移除数据出栈的时候, 也只能从栈顶移除, 所以, 栈遵循先进后出的逻辑. 栈中的所有数据都必须占用已知且固定的大小, 而且栈中的数据是有大小限制的, 所以在程序运行中出现的大小未知或者可能变化的数据, 必须存储在堆上, 堆不是有序的, 当你向堆中存储一个数据, 操作系统首先在堆的某处找到一块足够大的空间, 把它标记为已使用, 然后回传该空间的指针, 这个过程叫做在堆上分配内存, 指针的大小是已知且固定的 所以可以把真正的数据存储在堆中, 将指针存放在栈中, 当需要访问真实数据时, 先获取指针, 再访问指针 入栈比在堆上分配内存快, 这是因为栈在建立时每一块数据的大小是固定的, 而且是有序的, 操作系统无需为新数据去搜索合适的内存空间. 当在堆上分配内存时, 系统需要先找到一块足够大的内存, 然后做记录 访问堆上的数据也比访问栈的数据慢, 堆上面的数据通过指针访问, 现代处理器在内存中跳转越少速度就越快(缓存), 而堆是无序的, 意味着指针指向的地方可能需要很多次内存跳转 同样的, 因为这个原因, 处理器在处理数据彼此相近的时候(比如栈)比远的时候(堆)效率更高. 在堆上分配大量空间也会消耗时间. 当代码调用一个函数时, 会将函数的值和函数内部的局部变量压入栈中, 当这个函数结束时, 这些数据就属于垃圾, 理应被回收, 此时则出栈, 因为栈是后进先出, 导致这种回收是快速的, 符合逻辑的, rust的所有权就是这样做的 跟踪哪部分代码正在使用哪些数据, 最大限度的减少堆上重复数据的数量, 同时清理堆上不再使用的数据, 这些就是所有权系统需要去关心的 12345678910111213// 假设一个抽象的栈 []{ A; // A入栈, [A] B; // B入栈, [B, A] { a; // a入栈, [a, B, A] b; // b入栈, [b, a, B, A] }; // 函数结束了, a和b是垃圾了, 将a和b出栈, 直接取栈顶的的一段即可,保证效率的同时也符合逻辑(代码从上往下执行的顺序), [b, a, B, A] -&gt; [B, A] C; // C入栈, [C, B, A] D; // D入栈, [D, C, B, A]} 所有权的基本规则 Rust中的每一个值都有且只有一个被称为其 所有者 的变量 值在任一时刻有且只有一个所有者 所有者离开作用域时, 这个值将会被丢弃 变量作用域 每个变量都有其 作用域(scope), 作用域是一个 项(item) 在程序中有效的范围 1let s=\"hello\"; 这里的变量s绑定到了字符串hello中, 这个字符串编码进了程序代码中, 那么s从声明开始到当前作用域结束时都是有效的 12345fn main() { // s未声明 let s = \"hello\"; // s在这里生效 // 可以使用s}// 函数结束, 作用域也结束, s无法使用了 这里有两个关键点 s进入作用域时, s是有效的 s离开作用域, s无效 String类型 上面的例子来说, s因为是不可变的, 加上其数据很小, 所以本体存储在栈中 本次测试将把数据的本体放置在堆中, 而将指针放置在栈中 我们这里使用String作为例子, 专注于String与所有权相关部分. 对于在编译时无法知道具体的值的变量, 也就是说并不知道大小, 他就会被分配到堆上, 比如String 1let s = String::from(\"hello\"); 这里的::是运算符, 具体的详情我们在之后的章节说明. 12345fn main() { let mut s = String::from(\"hello\"); s.push_str(\", world\"); // 在s后拼接字符串 println!(\"{}\", s); // hello, world} 这里得到的s是可变的, 他可以通过调用 push_str 函数来修改自己 内存与分配 对于字符串字面值来说, 我们在编译时就能准确的知道其内容, 所以直接硬编码进最终的可执行文件中, 这使得字符串字面值快速且高效. 这里的前提是字符串字面值的不可变性, 但是, 对于未知的文本, 我们无法在开始时确定大小, 因为他是可以改变的. 对于string类型, 为了让他可以支持一个可变的, 可增长的文本片段, 需要在堆上分配一块在编译时未知大小的内存存放数据, 这就有两个问题 必须在运行时向操作系统请求内存 当string处理完成后将内存返回给操作系统 如何在运行时请求内存呢? 当我们调用String::from 时, 他会请求所需要的内存 如何在处理完成后将内存返给操作系统呢? 在有垃圾回收 GC 的语言中, GC会记录和清理不再使用的内存, 作为开发者我们不需要关心他, 没有GC则需要开发者手动的释放, 就跟请求一样需要我们写在代码中, 正确的处理内存回收通常比较困难, 如果忘记回收会浪费内存, 导致内存泄露等. 如果回收过早, 可能会在后续的使用中出现无效变量, 如果重复回收也可能会导致问题, 所以要准确的在合适的地方对一个 分配(allocate) 配对一个 释放(free) 在Rust中, 内存在拥有他的变量离开作用域时就被自动释放, 例如下面的例子 123456{ let mut s = String::from(\"hello\"); // 创建s, s此时是有效的, 在此作用域中 s.push_str(\", world\"); // 使用修改s, 在s后拼接字符串 println!(\"{}\", s); // hello, world} // 该作用域已结束, 作用域内的使用的内存需要释放// s失效了 这里, 当s离开当前有效的作用域时, Rust为我们自动调用函数drop (前提是该数据类型有drop), 该函数可以将变量释放, Rust会在结尾}自动调用 需要释放的变量的drop 变量与数据交互: 移动 如果我们将一个变量赋值给另一个变量, 其数据会怎么处理呢? 123let x = 5; // x为5let y = x; // copy x的值5, 赋值给y// x和y都等于5 因为5是在编译时就可以确定的, 所以这两个5被放入了栈中 那么对于无法确定大小的变量来说, 例如 12let s1 = String::from(\"s1\");let s2 = s1; 之前说过, 对于不可预测的变量, 我们会在栈上存储指针而在堆上存储真正的数据, 那么对于s1来说, 在栈上的数据为 name value ptr(指针) 堆上的地址 len(长度) 2 capacity(容量) 2 指针指向的堆的数据为 index value 0 s 1 1 这就是将s1绑定给变量s1在内存中的表现形式 我们注意到, 栈上的数据有 长度 和 容量, 长度指的是当前使用了多少字节的内存, 容量指的是从操作系统申请了多少字节的内存, 这两个是不一样的, 不要混淆 而我们将s1赋值给s2时, 实际上只是从拷贝了s1在栈上的数据, 也就是说此时 s1与s2共同指向了一个堆地址, 这跟其他语言的 浅COPY(shallow copy) 非常像, 这样做的好处是使操作变得快速, 如果是 深COPY(deep copy) , 意味着需要将堆上的数据找到,再插入到堆的另一个地方, 如果堆上的值很大, 则会造成效率的低下 但是这样会导致问题出现, 例如当s1与s2离开了作用域时, Rust 会对s1和s2进行清理, 但是他们实际上指向了同一个地址, 两次清理一个内存, 这就会出现前文提到的 二次释放(double free) 问题, 因此, Rust使用了不同的方法, 即 移动(move) , 就是在运行 s2=s1 时, 将s1无效化 123456fn main() { let s1 = String::from(\"s1\"); // 创建s1 let s2 = s1; // 将s1栈上的数据转移到s2上, s1失效了 println!(\"{}\", s1); // s1不可用, 所以会出错 println!(\"{}\", s2); // s2可用} // drop时, 先处理s2的Drop再s2的栈, s1无了, 只清理s1的栈 运行该代码时, 会出错 1234567891011121314error[E0382]: borrow of moved value: `s1` --&gt; src/main.rs:4:20 |2 | let s1 = String::from(\"s1\"); | -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait3 | let s2 = s1; | -- value moved here4 | println!(\"{}\", s1); | ^^ value borrowed here after moveerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0382`.error: could not compile `ownership`. Rust禁止你使用无效的引用 所以, Rust在处理这个s2 = s1时, 先将s1的栈数据复制一份给s2, 然后将s1置空, 这样就解决了二次释放的问题 需要知道的是, Rust的设计原则是: 永远不会自动创建数据的深拷贝, 这是出于对性能影响的考虑 变量与数据交互: 克隆 如果你确实需要进行深copy, 你可以使用内置函数clone 123456fn main() { let s1 = String::from(\"s1\"); // 创建s1, s1进入作用域 let s2 = s1.clone(); // s1的堆数据复制为另一份, 然后重新生成栈数据, 指向新的堆数据, s2进入作用域 println!(\"{}\", s1); // 未发生转移, s1还是可用的 println!(\"{}\", s2); // s2可用} // drop时, s1和s2的堆数据并不是一个, 所以没有二次释放的问题, 先进后出所以先清理s2 必须要注意的是, 这样会对资源和性能造成一定的损耗, 在确保你必须这样做时才需要进行克隆操作 只在栈上的数据: 拷贝 而对于只在栈上保存的数据, 也就是在编译时就知道值的数据来说, 不存在转移和克隆, 因为他是只保存在栈上, 所以进行拷贝速度很快,Rust在处理这种数据的赋值时直接copy栈的数据到另一个变量, 所以两个变量都可用 12345fn main() { let s1 = 1; // 创建s1, 进入作用域 let s2 = s1; // 拷贝s1的栈数据生成s2, s2进入作用域 println!(\"{},{}\", s1, s2) // s1与s2都可以使用} // i32没有drop, 根据先进先出, 清理s2再s1 怎么分辨什么是会出现移动的呢, Rust有一个叫做Copy的trait的特殊注解, 如果某个类型拥有这个注解, 那么旧的变量在赋值给新的变量后依旧可用. 如果一个类型有Drop注解, 那么他就无法使用Copy注解. 他们是无法共存的. 什么类型是Copy的呢? 可以查看对应的文档. 一般的, 任何简单标量值的组合可以是Copy的, 不需要分配内存或者某种形式的资源类型是Copy的, 比如 所有整数类型 布尔类型 所有浮点类型 字符类型, char 元组, 当其包含的类型都是Copy时 drop与内存释放的关系 这里是本人记录的 需要注意的是, Rust释放内存有两种 如果是有drop注解的数据类型(例如String), 先执行drop方法,再将栈数据删除 而没有drop注解的数据类型(例如i32), 直接将栈数据删除 为什么drop与copy注解不能兼容 这里是本人记录的 我们知道, copy注解代表着该数据类型并不会发生转移, 也就是说发生 s1 = s2 时,s2 依旧存在, 在内部逻辑中是Copy一份栈数据, 有copy 的数据类型一般只将数据放置在栈上, 在退出作用域时, 只需要清理栈数据即可, 而拥有drop的数据类型, rust会优先调用drop方法, 一般来讲, drop 一般是清理堆的有关数据, copy的不需要清理, 所以为了保持统一, 就规定了两者不兼容 如果某个类型同时拥有Copy和Drop注解的话, 首先拥有Drop一般都需要将数据本体放置进堆, 那样在重复赋值时又有Copy会Copy一份栈数据, 就造成了两个变量实际上指向了同一个资源, 在清理时就会发生二次释放的问题 所有权与函数 123456789101112131415161718fn main() { let s = String::from(\"s\"); // 创建s, 进入作用域 takes_ownership(s); // s转移进了函数takes_ownership的some_string中 println!(\"{}\", s); // 这里会报错, 因为s已经转移, s不可用了 let i = 5; // i进入作用域 makes_copy(i); println!(\"{}\", i); // i可用, 因为i是存储在栈上, 有`Copy`直接复制一份进makes_copy的some_integer} // s和i退出作用域, 栈是先进后出, 所以先清理i, i没有`Drop`所以直接删除栈, s已经被转移所以不做特殊操作fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(\"{}\", some_string);} // some_string 移出作用域并调用`drop`方法。占用的内存被释放fn makes_copy(some_integer: i32) { // some_integer 进入作用域 println!(\"{}\", some_integer);} // 将 some_integer 释放, 因为i32没有`drop`注解所以只清理栈数据 返回值与作用域 如果函数是拥有返回值, 如果返回值是drop, 则会将返回值移动给返回值的接收者, 如果是copy, 则是copy给返回值 变量的所有权总是遵循相同的模式: 将值付给另一个变量时移动他. 当持有堆中数据值的变量离开作用域时, 堆中值会通过drop被清理, 除非数据被移动到另一个变量 看下面代码 1234567891011121314151617181920212223fn main() { let s1 = gives_ownership(); // s1接受返回值, 进入作用域 let s2 = String::from(\"s2\"); // 创建s2, 进入作用域 let s3 = takes_and_gives_back(s2); // s2传入takes_and_gives_back函数, s2转移给该函数的a_string, 随后s3接受返回值, 进入作用域 println!(\"{}\", s2); // 这里s2已经发生转移, 指针为空, 所以使用会报错 println!(\"{}, {}\", s1, s3); // s1和s3可用} // 退出作用域, 清理s3&gt;s2&gt;s1// s2为空fn gives_ownership() -&gt; String { let some_string = String::from(\"gives_ownership\"); some_string // 如果这里返回了, 而返回值是String类型, 有Drop注解, 会发生所有权的移动, 移动给接受者, some_string失效了} // some_string 移除作用域, 因为 some_string 已经转移所以只删除栈fn takes_and_gives_back(a_string: String) -&gt; String { a_string // 如果这里返回了, 而返回值是String类型, 有Drop注解, 会发生移动, 移动给接受者, a_string失效了} // a_string 移除作用域, 因为 a_string 已经转移所以只删除栈 这样就会出现一个问题, 如果某个变量是拥有Drop的, 那么这个变量需要作为某个函数的参数使用, 我们传入到这个函数中总会使原有的变量失效, 那么如果我还需要再使用这个变量呢? 有一个折中的办法, 在函数中再将参数值传出, 例如 123456789101112fn main() { let s1 = String::from(\"s1\"); let (s2, len) = calculate_length(s1); // s1转移了, 用s2接受原来的s1 println!(\"The length of '{}' is {}.\", s2, len);}fn calculate_length(s: String) -&gt; (String, usize) { let length = s.len(); // len() 返回字符串的长度 (s, length) // 将s也返回} 但是这样太LOW了, 为了解决这样的问题, Rust提供了引用(references) 引用和借用 引用可以在不转移所有权的情况下使用变量 12345678910fn main() { let s1 = String::from(\"hello\"); // s1进入作用域 let len = calculate_length(&amp;s1); // 将 &amp;s1 传入, &amp;意思是引用, 即将s1的引用传入函数calculate_length println!(\"The length of '{}' is {}.\", s1, len); // 仍可以使用s1, 因为未发生所有权转移}fn calculate_length(s: &amp;String) -&gt; usize { // 因为类型变成了String的引用, 所以接收参数类型发生变化 s.len()} &amp;代表对某个引用, 引用允许你使用值但不获取其所有权, 比如上面的 s1, 当 s1传入到 calculate_length 的参数 s 时, 实际上s是 s1 的引用, 类似于指针, 指向了s1 与&amp;(引用)相反的操作是解引用(dereferences), 他的运算符是 *, 之后会讲到 &amp;s1 让我们创建一个指向s1的引用, 但是并不拥有他, 因为不拥有他, 所以当引用离开作用域时其指向的值也不会被清理 在 calculate_length 结束时, s离开作用域, 理应清理, 但是因为s只是个引用类型, 所以只把s清理并不会清理s对应的真正的变量 对于函数 calculate_length 来说, 其接受了String的引用, 这种行为被称为 借用 需要注意的是, 如果你借用了某个变量, 那你 默认情况下 是无法修改这个变量的值的 123456789fn main() { let mut s = String::from(\"hello\"); change(&amp;s);}fn change(some_string: &amp;String) { some_string.push_str(\", world\"); // 尝试追加字符串} 会报错 123456789101112error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference --&gt; src/main.rs:8:5 |7 | fn change(some_string: &amp;String) { | ------- help: consider changing this to be a mutable reference: `&amp;mut std::string::String`8 | some_string.push_str(\", world\"); // 尝试追加字符串 | ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutableerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0596`.error: could not compile `ownership`. 提示你无法修改他, 当然这是默认情况下 可变引用 某些情况下可以修改引用的值, 我们修改代码成 12345678910fn main() { let mut s = String::from(\"hello\"); change(&amp;mut s); // &amp;mut 表示是可变的引用 println!(\"{}\", s) // hello, world}fn change(some_string: &amp;mut String) { // 同样的参数类型也要 mut some_string.push_str(\", world\"); // 尝试追加字符串} 这样即可运行, 但是注意, 可变引用有几个限制 在特定作用域的特定数据只能有一个可变引用 例如以下代码 123456fn main() { let mut s = String::from(\"hello\"); let r1 = &amp;mut s; let r2 = &amp;mut s; // 错误, 因为s的 &amp;mut 同时只能出现一个 println!(\"{},{}\", r1, r2);} 会报错 1234567891011121314error[E0499]: cannot borrow `s` as mutable more than once at a time --&gt; src/main.rs:4:14 |3 | let r1 = &amp;mut s; | ------ first mutable borrow occurs here4 | let r2 = &amp;mut s; | ^^^^^^ second mutable borrow occurs here5 | println!(\"{},{}\", r1, r2) | -- first borrow later used hereerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0499`.error: could not compile `ownership`. 这是为了避免出现数据竞争的问题, 数据竞争通常由这三种行为造成: 两个或多个指针同时访问一个数据 至少一个指针写入数据 没有同步数据的机制 数据竞争可能导致出现BUG, 并且让开发者难以定位和解决问题, 所以Rust在编译时会检查这个问题 当然, 这个限制只是存在于同一个作用域, 例如下面的代码是可以的 1234567fn main() { let mut s = String::from(\"hello\"); { let r1 = &amp;mut s; } // 可变引用r1退出作用域 let r2 = &amp;mut s; // 可以重新创建} 在特定作用域的特定数据不能同时拥有可变和不可变引用 12345678910fn main() { let mut s = String::from(\"hello\"); let r1 = &amp;s; // 不可变1 let r2 = &amp;s; // 不可变2 let r3 = &amp;mut s; // 可变1 println!(\"{}, {}, and {}\", r1, r2, r3); // 会报错, 因为不可变与可变引用无法共存 } 报错 12345678910111213141516error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --&gt; src/main.rs:6:14 |4 | let r1 = &amp;s; // 不可变1 | -- immutable borrow occurs here5 | let r2 = &amp;s; // 不可变26 | let r3 = &amp;mut s; | ^^^^^^ mutable borrow occurs here7 | 8 | println!(\"{}, {}, and {}\", r1, r2, r3); | -- immutable borrow later used hereerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0502`.error: could not compile `ownership`. 两者不能共存, Rust认为如果你使用了不可变引用. 你一定不希望他在某些时候变化, 所以禁止共存, 但是对于多个不可变引用, 是可以的. 因为都是读取, 就是安全的, 没有办法影响到别人, 所以可以一个作用域可以有多个不可变引用存在 标题所言的是特定作用域, 对于引用来说, 他的作用域从声明的地方开始到最后一次使用为止. 如果声明未使用, 那么只存在于声明的那一行, 当然最好不要声明却不使用, 这是不好的习惯 123456789fn main() { let mut s = String::from(\"hello\"); let r1 = &amp;s; // 不可变1, 未使用 let r2 = &amp;s; // 不可变2, 未使用 let r3 = &amp;mut s; // 可变1, 使用 println!(\"{}\", r3); // 这里已经超出了r1和r2的作用域, 因为r1/r2未使用, 作用域只有生成的一行} 12345678910fn main() { let mut s = String::from(\"hello\"); let r1 = &amp;s; // 不可变1, 未使用 let r2 = &amp;s; // 不可变2, 未使用 println!(\"{},{}\", r1, r2); // 这里是r1/r2最后一次使用, r1/r2作用域到此结束 let r3 = &amp;mut s; // 可变1, 使用 println!(\"{}\", r3); // 可使用, 当前作用域无不可变引用} 垂悬引用 垂悬指针指的是指针指向的内容已经被分配给了其他的持有者. 在Rust中, 编译器确保了永远不会出现这个问题, 因为当你拥有引用时, 编译器会确保数据不会在其引用之前离开作用域 12345678910fn main() { let res = dangle(); // 接收返回的引用 println!(\"{}\", res);}fn dangle() -&gt; &amp;String { let s = String::from(\"hello\"); // s进入作用域 &amp;s // 将s的引用返回} // 函数结束, s的数据会被清理, 但是s的引用返回出去了 这里的 res 是函数 dangle 内部生成的变量的引用, 但是该函数内部的变量会结束后销毁, 此时你获取到的引用就是错误的, 就会发生悬垂引用的问题, Rust会在编译时予以拦截 123456789101112error[E0106]: missing lifetime specifier --&gt; src/main.rs:6:16 |6 | fn dangle() -&gt; &amp;String { | ^ help: consider giving it a 'static lifetime: `&amp;'static` | = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed fromerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0106`.error: could not compile `ownership`. 如果有这样的需求, 你应该直接返回变量, 而不是他的引用, 这样会发生所有权的移动 12345678910fn main() { let res = dangle(); // 接收返回 println!(\"{}\", res);}fn dangle() -&gt; String { let s = String::from(\"hello\"); // s进入作用域 s // 将s返回} // 函数结束, s触发了所有权的移动 slices slice是没有所有权的. slice允许你引用集合中某一短连续的元素序列, 而不引用整个集合 假设有这样的需求, 写一个函数, 接受一个字符串, 返回字符串中的第一个单词. 如果函数在该字符串中没有找到空格, 那么这整个就是一个单词, 如果有空格, 则第一个空格前的是一个单词 初版代码如下 123456789101112fn first_word(s: &amp;String) -&gt; usize { // 接收引用, 返回索引 let bytes = s.as_bytes(); // 转换成bytes元组 for (i, &amp;item) in bytes.iter().enumerate() { // 生成迭代器并循环他 // i是当前遍历到的索引, &amp;item是当前内容的引用 if item == b' ' { // 如果遇到了空格 return i; // 将索引return } } // 如果没有找到, 证明全部都是一个单词, 所以返回整体的索引 s.len()} s是原本的字符串的引用, 因为我们并不需要该字符串的所有权 我们返回的是该字符串中第一个单词的索引 .as_bytes()是将字符串转换成bytes元组, .iter()是返回里面的每一个值, 而.enumerate() 则是接收.iter()返回的值进一步包装. 返回一个元组, 分为索引和值的引用, 当当前字节为空格的时候, 证明需要返回了, 单词结束, 于是将索引直接返回, 当遍历完也没有的时候证明整个字符串都是一个单词, 此时将整个长度返回 这样看起来没什么问题, 但是这里返回的索引长度其实与我们传入的s不是绑定的, 我们在开发中可能遇到这样的问题, 在某一个地方求出结果, 在后面调用时发现不匹配, 原来是源数据被改动了, 例如 1234567fn main(){ let mut s = String::from(\"word\"); let k = first_word(&amp;s); s.clear(); // 这里调用clear方法, 会获取s的可变引用, 字符串变成初始值, 也就是空串 println!(\"{}\", k) // k依旧是原来的\"word\"时的结果 // 后续中使用 k 就会出现问题, 因为s已经变更} 因为 first_word 虽然需要了s的不可变引用, 但是返回值是普通的数字, 与s无关, 所以执行 first_word 之后不可变引用退出作用域了, 所以可以在 clear 里顺利的申请可变引用, 从而修改值 字符串slice 字符串slice是String中一部分值的引用 123456fn main(){ let s = String::from(\"hello world\"); let h = &amp;s[0..5]; let w = &amp;s[6..11]; println!(\"h={},w={}\", h, w)} 如上面的代码. &amp;s[0..5]代表引用了s的索引0-5之间的内容, 语法是[start_index..end_index], start_index是slice中的开始索引, end_index是slice中最后一个位置的后一个值索引. 例如[0..5]实际上是s的索引0到索引4, 也就是字符串hello的引用, 我们运行查看结果 1h=hello,w=world 这种方法不是引用整个字符串, 而是字符串中的某一段 Rust的..range语法, 还有多种简略写法 如果从索引0开始, 可以忽略0, 可以达到一样的效果 1234let s = String::from(\"hello\");let slice = &amp;s[0..2]; // helet slice = &amp;s[..2]; // he 如果一直到索引最后, 也可以舍弃尾部的数字 123456let s = String::from(\"hello\");let len = s.len();let slice = &amp;s[3..len]; // llolet slice = &amp;s[3..]; // llo 如果是同时舍弃开头和结尾, 则是将整个字符串获取 123456let s = String::from(\"hello\");let len = s.len();let slice = &amp;s[0..len]; // hellolet slice = &amp;s[..]; // hello 我们将之前的代码修改为新的字符串slice引用的方式, 之后会解释为什么这样做 12345678910fn first_word(s: &amp;String) -&gt; &amp;str { let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() { if item == b' ' { return &amp;s[..i]; // 返回s的引用, 从0到当前空格的索引 } } &amp;s[..] // 全部都是一个单词, 就把整个返回} 那么这样写的好处是什么呢? 回忆一下借用的规则, 当某个值已经有不可变引用时, 无法生成可变引用了, 对于s来讲, 函数 fiest_word 返回的是s的不可变引用, 而后我们在尝试改变s的值的时候.clear()尝试申请s的可变引用, 这样就会导致编译时出现问题, 避免出现BUG, 我们按照之前的调用, 尝试 .clear() 12345678910111213141516error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --&gt; src/main.rs:17:5 |15 | let word = first_word(&amp;s); | -- immutable borrow occurs here16 | 17 | s.clear(); | ^^^^^^^^^ mutable borrow occurs here18 | 19 | println!(\"the first word is: {}\", word); | ---- immutable borrow later used hereerror: aborting due to previous errorFor more information about this error, try `rustc --explain E0502`.error: could not compile `ownership`. 会在编译器就报错, 防止出现BUG 字符串字面值其实就是slice 原来在Rust中, 直接给变量赋值字符串 1let s = \"s\"; 这里, s类型就是 &amp;str, 他是一个指向程序特定内部位置的slice, 所以他是不可变的, 因为就是不可变引用 字符串slice作为参数 修改后的获取单词函数定义是 1fn first_word(s: &amp;String) -&gt; &amp;str {} 而更好的方式是定义为 1fn first_word(s: &amp;str) -&gt; &amp;str {} 这样的目的是提高兼容性, 上面说了, 使用let s = \"s\"; 类型是 &amp;str, 所以新写法可以兼容这种字符串, 当然对于String类型, 我们可以通过转化成slice来使用 12345678910111213141516fn main() { let my_string = String::from(\"hello world\"); // first_word 中传入 `String` 的 slice let word = first_word(&amp;my_string[..]); let my_string_literal = \"hello world\"; // 因为字符串字面值就是字符串 slice， // 这样写也可以，即不使用 slice 语法！ let word = first_word(my_string_literal); // &amp;str 也可以继续的生成 slice let word = first_word(&amp;my_string_literal[..]);} 其他类型的slice 字符串slice里面存放的是字符串, 其实其他类型也是可以的 12let a = [1, 2, 3, 4, 5];let b = &amp;a[..2]; 那么这个slice的类型就是 &amp;[i31], 使用方法与字符串slice并无区别, 你可以对索引集合使用slice, 具体的信息会在之后详解 总结 所有权到这里就结束了, 所有权, 借用和slice可以让Rust程序变得更加的安全, 当你耐心的看到这里, 可能你对Rust的独特的编程思想有了大致的理解 Rust设置了诸多限制, 并且希望你写出故意设卡(qia)的代码, 目的是让程序更加安全, 在编译期就把可能出现的问题暴露出来, 让你去主动解决, 而不是在运行时, 或者是生产环境中才出现问题. 这需要开发者时刻留意遵循Rust的规范, 但是这一切都是值得的. 而Rust的所有权系统, 让你无需关注垃圾的回收, 当然搭配作用域/引用/借用一起使用需要开发者关注变量的使用和作用域","link":"/2021/09/04/rust_programming_language(4)/"},{"title":"Rust程序设计语言(5)","text":"结构体使用结构体来组织关联数据 golang里有同样的类型, 学到这里感觉有点舒服了 struct, 是一个自定义的数据类型, 其中可包含若干个值, 从而形成适合你业务的组合, 比如go的struct(结构体) 定义和实例化 结构体的每一个部分可以是不同的类型, 跟元组不同的是, 结构体需要对每一个数据进行命名, 这是为了定义这个值, 也是为了给这个值声明意义. 因为有了这些名字, 使得结构体比元组更加灵活, 不需要依赖顺序来方式实例中的某一个值, 而是通过其名字. 定义结构体的关键字是 struct, 后面是这个结构体的名字, 一般情况下结构体的名字都应该能体现出这个结构体的作用, 在 {} 中每一个部分, 都被称为一个字段(field) 123456struct User { name: String, // 用户名 email: String, // 邮箱 age: u64, // 年龄 active: bool, // 活跃状态} // 结构体 User, 代表用户信息 要使用结构体, 我们就需要实例化, 创建实例时需要指定要实例化的结构体是哪个, 并在 {} 内使用 key: value 的形式对某个字段赋值, 注意这里的字段顺序可以与定义结构体时的字段顺序不同 123456let user1 = User { name: String::from(\"user1\"), age: 23, active: false, email: String::from(\"user1@outlook.com\")}; 我们也可以在实例化后修改字段的值, 此时这个实例应当是可变的 1234567let mut user1 = User { name: String::from(\"user1\"), age: 23, active: false, email: String::from(\"user1@outlook.com\")}; // mut 可变user1.age = 24 // 通过 .key 的方式来找到值 也可以将实例作为表达式的返回值 12345678fn build_user(name: String, email: String) -&gt; User{ User{ name: name, email: email, active: false, age: 18 }} // 返回结构体 User 的实例 注意, 当变量或者参数名和类型与结构体的字段完全一致时, 可以使用简略的写法 123456789fn build_user(name: String, email: String) -&gt; User{ let active = false; User{ name, // name: name, User的字段name与参数name一致 email, // email: email, User的字段email与参数email一致 active, // active: active, User的字段active与变量active一致 age: 18 }} 我们也可以借用已经存在的实例的某些字段创建新的实例 123456789101112let user1 = User { name: String::from(\"user1\"), age: 23, active: false, email: String::from(\"user1@outlook.com\")}; // user1let user2 = User { name: user1.name, // 借用user1的字段 age: user1.age, // 借用user1的字段 email: String::from(\"user2@outlook.com\"), active: true}; 如果剩下的字段值都使用老的实例的值, 还可以使用简略的写法 12345678910let user1 = User { name: String::from(\"user1\"), age: 23, active: false, email: String::from(\"user1@outlook.com\")}; // user1let user2 = User { email: String::from(\"user2@outlook.com\"), ..user1 // name/age/active 都使用user1}; 元组结构体 有时我们想给某个元组定义一个名字, 让这个元组结构可以复用并且与普通元组分开, 此时你可以使用 元组结构体, 元组结构体不同于普通的结构体, 他没有具体的每个字段的名字, 只有字段的类型, 但是整个元组结构体拥有一个名字 12345struct Color(i32, i32, i32); // 元组结构体定义struct Point(i32, i32, i32); // 同上let black = Color(0, 0, 0); // 赋值let origin = Point(0, 0, 0); 上面的 Color 和 Point 虽然都是 i32, 长度为3 的元组, 但是因为不是一个结构体所以无法混用 同时因为没有字段的名字, 想要访问其中某一个值, 可以通过索引来获取 结构体的生命周期 你可能注意到了, 我们定义的结构体, 并没有使用引用, 比如使用 String 而不是&amp;str, 是因为这设计到了生命周期的概念, 这个是之后的内容, 目前我们需要让这个结构体内的字段的所有权在自己手中, 以便正常运行, 如果你使用了引用, 目前是无法编译的 123456struct User { name: &amp;str, // 用户名 email: String, // 邮箱 age: u64, // 年龄 active: bool, // 活跃状态} // 结构体 User, 代表用户信息 12345678910111213141516error[E0106]: missing lifetime specifier --&gt; src/main.rs:3:15 |3 | name: &amp;str, // 用户名 | ^ expected named lifetime parameter |help: consider introducing a named lifetime parameter |2 | struct User&lt;'lifetime&gt; {3 | name: &amp;'lifetime str, // 用户名 |error: aborting due to previous errorFor more information about this error, try `rustc --explain E0106`.error: could not compile `t_struct`. 等到之后, 我们会讲到怎样解决这个问题 使用结构体编写示例代码 我们使用之前学的知识, 编写一段代码, 他的功能是求出长方形的面积 123456789fn main() { let width1 = 30; let height1 = 50; println!(\"area={}\", area(width1, height1))}fn area(width: u32, height: u32) -&gt; u32{ width * height} 上面的代码能够完成我们的需求, 但是仔细想, 一个长方形, 长和宽应该是绑定的关系, 如何体现绑定关系呢? 我们将长和宽使用元组绑定到一起 12345678fn main() { let rect1 = (30, 50); println!(\"area={}\", area(rect1))}fn area(dimensions: (u32, u32)) -&gt; u32{ dimensions.0 * dimensions.1} 这样就增加了一些结构性. 但是问题出现了, 使用元组的方式, 我们没法知道哪一个是长, 哪一个是宽, 假如说我们需要根据长宽不同进行不同操作, 比如在屏幕中绘制, 那就可能让调用者产生疑问, 不知道参数的意义 于是我们使用结构体来进行代码的编写 123456789101112131415fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; println!(\"area={}\", area(&amp;rectange1))}struct Rectangle { width: u32, height: u32}fn area(rectangle: &amp;Rectangle) -&gt; u32{ rectangle.height * rectangle.width} 这里的函数 area 为了防止所有权的转让, 我们使用了引用的方式 通过派生 trait 增加功能 有时候我们想打印一个结构体实例的内容, 使用println!是不行的, 例如 1234567fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; println!(\"rec = {}\", rectange1);} 1234567891011121314error[E0277]: `Rectangle` doesn't implement `std::fmt::Display` --&gt; src/main.rs:6:26 |6 | println!(\"rec = {}\", rectange1); | ^^^^^^^^^ `Rectangle` cannot be formatted with the default formatter | = help: the trait `std::fmt::Display` is not implemented for `Rectangle` = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead = note: required by `std::fmt::Display::fmt`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0277`.error: could not compile `t_struct`. 这是因为, println! 宏默认使用类型的Display格式输出, 意思是打印出来的输出, 之前所有的基本类型都实现了Display, 但是因为结构体, rust并不知道你想要输出什么, 所以没有提供Display实现 但是rust给了我们建议, 查看输出, 有一行 1note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead 似乎是告诉我们应该这样输出, 于是我们将打印修改为 1println!(\"rec = {:?}\", rectange1); 运行后发现还是不行, 但是又给了一个提示 12345678910111213error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug` --&gt; src/main.rs:6:28 |6 | println!(\"rec = {:?}\", rectange1); | ^^^^^^^^^ `Rectangle` cannot be formatted using `{:?}` | = help: the trait `std::fmt::Debug` is not implemented for `Rectangle` = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug` = note: required by `std::fmt::Debug::fmt`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0277`. 12= help: the trait `std::fmt::Debug` is not implemented for `Rectangle`= note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug` 这里告诉我们rust确实有打印, 但是是Debug模式, 需要我们显式的开启, 我们将代码修改为 12345678910111213fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; println!(\"rec = {:?}\", rectange1);}#[derive(Debug)]struct Rectangle { width: u32, height: u32} 运行 123 Finished dev [unoptimized + debuginfo] target(s) in 0.40s Running `target/debug/t_struct`rec = Rectangle { width: 20, height: 30 } 可以打印出结构体数据了 我们回看新加入的注释, #[derive(Debug)], 实际上是为结构体 Rectangle 加入了 Debug 的 derive, rust中还有很多这样的用法, 我们之后再说 方法语法 当我们写python的时候, 总会使用到类/方法, 使用类生成对象, 调用对象的方法, 让这个方法与类有紧密的联系 再比如Go, 也有类似的概念, 其实rust也是有的, 依附于结构体struct, 可能更像go, 被称之为结构体的 方法 定义方法 123456789101112131415161718fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; println!(\"area={}\", rectange1.area()) // 调用结构体定义的方法}struct Rectangle { width: u32, height: u32}impl Rectangle{ // impl 结构体名称 fn area(&amp;self) -&gt; u32 { // 定义方法 area self.height * self.width }} 其中, impl 是关键字, 意为定义结构体的方法, 在其中定义了方法area, 注意参数变成了 &amp;self, 学过其他语言的一把都知道这个是代表实例自身, 因为这里我们不想获取实例的所有权, 而是只想获取长和宽, 所以使用了 &amp;, 如果想要在一个方法中修改实例, 可以将参数修改为 &amp;mut self 将参数设置为 self 是不常见的, 这代表获取了实例的所有权, 通常只有将self 转换成别的实例时才适用. 调用结构体方法的时候使用 实例.方法 即可, 参数&amp;self 是自己会传递的, 无需手动的写入 在C/C++中, 参数self为指针时, 调用其方法需要-&gt;, 而.是不为指针时调用的方式, 在Rust中会自己为你识别, 而不必关注参数是 slef/ &amp;self/ &amp;mut self 带有更多参数的方法 很多时候调用方法时肯定需要传入更多参数, 这些参数与实例本身并无联系 1234567891011121314151617181920212223242526fn main() { let rectange1 = Rectangle{ width: 20, height: 30 }; let rectange2 = Rectangle{ width: 30, height: 50 }; println!(\"area={}\", rectange1.area()); println!(\"r2 can_hold r1 = {}\", rectange1.can_hold(&amp;rectange2)) // 调用, 额外参数手动指定}struct Rectangle { width: u32, height: u32}impl Rectangle{ fn area(&amp;self) -&gt; u32 { self.height * self.width } fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool { // 接受一个额外参数 other 类型是 &amp;Rectangle self.width &gt; other.width &amp;&amp; self.height &gt; other.height }} 这时候在 self 之后追加即可, 传入参数时需要手动传递, 一样无需传入self 关联函数 impl还可以定义不需要slef作为参数的函数, 这种被称作 关联函数, 他们与结构体相关联, 但是因为不依赖self, 所以依旧是函数而不是方法, 例如 1234567891011121314fn main() { let sq = Rectangle::square(20); // 通过 :: 调用, 因为不依赖实例, 所以不需要通过实例去调用, 直接使用结构体}struct Rectangle { width: u32, height: u32}impl Rectangle { fn square(size: u32) -&gt; Rectangle { // 不依赖实例本身 Rectangle { width: size, height: size } }} ::的语法是不是很熟悉? 更多的使用方法之后会详解 多个impl块 每个结构体都允许有多个impl块, 比如 123456789101112131415161718192021222324struct Rectangle { width: u32, height: u32}impl Rectangle { fn square(size: u32) -&gt; Rectangle { // 不依赖实例本身 Rectangle { width: size, height: size } }}impl Rectangle { fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool { // 接受一个额外参数 other 类型是 &amp;Rectangle self.width &gt; other.width &amp;&amp; self.height &gt; other.height }}impl Rectangle{ fn area(&amp;self) -&gt; u32 { self.height * self.width }} 这样是可以正常使用的, 但是一般不建议这样做, 因为没有意义, 可能在特殊的需求下有用, 我们之后会说 枚举与模式匹配 枚举(enumerations/ enums)开发者应该都很熟悉, 枚举让你可以通过列举可能的 成员(variants) 来定义一个类型 定义枚举 通过一个场景来理解枚举, 我们知道, IP地址目前主要有两种, IPv4 和 IPv6, 这两个都属于IP, 假设我们的程序有可能会且只会处理这两种IP, 那么我们可以将两个归属为一起, 当代码在处理IP时将其当做一样的来处理, 我们可以使用 枚举 来做. 定义一个枚举 IpAddrKind 来整合这两种类型, 分别为 v4 和 v6 12345enum IpAddrKind { // 枚举名 v4, // ipv4 v6, // ipv6} 现在, 对于程序来讲, IpAddrKind是一个可以使用的数据类型了 枚举值 使用定义的枚举 12let four = IpAddrKind::v4;let six = IpAddrKind::v6; 枚举的每一个成员都在其枚举的命名空间中, 使用 :: 呼出, v4和v6都属于IpAddrKind, 所以可以当做一个类型处理 123456789101112131415enum IpAddrKind { // 枚举名 v4, // ipv4 v6, // ipv6}fn a(ip: IpAddrKind){}fn main() { let four = IpAddrKind::v4; let six = IpAddrKind::v6; a(four); a(six)} 如果我们想要将IP地址和IP类型形成关联关系, 我们可能优先想到使用结构体 123456789101112131415161718192021enum IpAddrKind { // 枚举名 v4, // ipv4 v6, // ipv6}struct IpAddr { // ip地址结构体 address: String, // ip kind: IpAddrKind // 类型}fn main() { let address1 = IpAddr{ kind: IpAddrKind::v4, address: String::from(\"123.234.111.222\") }; let address2 = IpAddr{ kind: IpAddrKind::v6, address: String::from(\"::1\") };} 其实在枚举IpAddrKind时, 我们就已经知道了是v4还是v6, 而在结构体IpAddr中只多出来了字段address, 那么我们可以给枚举设置value, 来让代码更简单 12345678910enum IpAddr { // 枚举名 v4(String), // ipv4, String类型 v6(String), // ipv6, String类型}fn main() { let address1 = IpAddr::v4(String::from(\"127.0.0.1\")); let address2 = IpAddr::v6(String::from(\"::1\"));} 因为IP地址实在是太常见了, 很多时候我们都会用到, 所以Rust内置了数据结构专门存放IP地址, IpAddr in std::net - Rust (rust-lang.org), 内部是这样定义的 123456789101112struct Ipv4Addr { // --snip--}struct Ipv6Addr { // --snip--}enum IpAddr { V4(Ipv4Addr), V6(Ipv6Addr),} 将枚举的value设置成结构体, 而这个结构体可以存放任何数据, 这样来增加兼容性 因为我们的例子中都没有引用标准库中的定义, 所以即使我们自己定义了IpAddr枚举, 也不会产生冲突 下面我们再看一个新的枚举 123456enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32),} 这个枚举Message 下面有4个成员, Quit没有关联任何数据, Move对应一个匿名结构体, Write关联一个元组String, ChangeColor关联一个元组 如果我们单纯使用结构体也可以达到效果 1234567struct QuitMessage; // 类单元结构体struct MoveMessage { x: i32, y: i32,}struct WriteMessage(String); // 元组结构体struct ChangeColorMessage(i32, i32, i32); // 元组结构体 问题是, 这样的话就没有将这几个Message形成关联关系, 如果使用枚举, 因为枚举本身是一种类型, 就能将这些Message以成员的方式合到一起 对于枚举类型, 我们也可以通过使用impl关键字来为枚举类型定义方法(和结构体类似) 12345678impl Message { fn call(&amp;self) { // 方法call }}let m = Message::Write(String::from(\"hello\"));m.call(); // 调用 具体的调用, self方式, 可以参照上方的结构体impl option枚举 Option是标准库定义的另一个枚举, 他的应用很广泛, 他代表了一个值要么有值要么没值. 你可能现在不明白有什么作用 Rust中没有其他语言有的空值功能, 空值(Null)也是一个值, 他代表了没有值. 在其他语言中, 变量都有两种状态: 空值和非空值 Tony Hoare，null 的发明者，在他 2009 年的演讲 “Null References: The Billion Dollar Mistake” 中曾经说到： I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. 我称之为我十亿美元的错误。当时，我在为一个面向对象语言设计第一个综合性的面向引用的类型系统。我的目标是通过编译器的自动检查来保证所有引用的使用都应该是绝对安全的。不过我未能抵抗住引入一个空引用的诱惑，仅仅是因为它是这么的容易实现。这引发了无数错误、漏洞和系统崩溃，在之后的四十多年中造成了数十亿美元的苦痛和伤害。 空值的问题主要在于, 当你想像使用非空值一样使用空值, 就会出现某种形式上的错误, 因为空和非空无处不在, 所以很容易出现这种问题 rust中没有空值, 他有一个在编码时可以存在或者不存在的概念的枚举, 这个就是Option 1234enum Option&lt;T&gt; { Some(T), None,} 因为Option太多常用, 所以不需引用标准库也直接存在, Option下拥有两个成员, Some(T)和None, &lt;T&gt;是我们还没有讲到的功能, 他指的是一个泛类型参数, 目前你可以理解成可以包含任何类型的数据, 我们之后会详细讲解 因为对Option做了特殊处理, 所以Option下面的成员Some和None也可以直接使用, 无需Option::Some 1234let some_number = Some(5);let some_string = Some(\"a string\");let absent_number: Option&lt;i32&gt; = None; 如果你使用成员None, 则需要告诉Rust Option 是什么类型, 因为Rust无法自己知道None是什么类型 并且, 因为你通过Option创建的值是Option类型, 他无法直接与普通的类型进行操作 123456fn main() { let x: i8 = 5; let y: Option&lt;i8&gt; = Some(5); let sum = x + y;} 会报错 123456789101112error[E0277]: cannot add `std::option::Option&lt;i8&gt;` to `i8` --&gt; src/main.rs:5:17 |5 | let sum = x + y; | ^ no implementation for `i8 + std::option::Option&lt;i8&gt;` | = help: the trait `std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is not implemented for `i8`error: aborting due to previous errorFor more information about this error, try `rustc --explain E0277`.error: could not compile `t_enum`. 告诉你无法将 i8 与 Option&lt;i8&gt; 进行相加, 因为他们的类型不同, 而对于i8这种类型, Rust可以保证他一定是有值的, Option&lt;i8&gt; 也有可能是为None的, Rust为了避免这个错误不允许直接计算. 而要想进行操作, 必须将 Option&lt;T&gt; 转换成 T , 在这个过程中就会让我们预先的处理空值的问题. 当我们发现一个变量为Option&lt;T&gt;是, 牢记可能是空值, 而其他的普通类型, 他一定是非空, 就不用考虑空值的问题 怎么将Option&lt;T&gt;转换成T, 在之后会告诉你, 你也可以查看Option in std::option - Rust (rust-lang.org) match控制流运算符 类似Golang有switch语法, Python可以使用else if ,达到对某个值进行多个分支判断的逻辑, Rust里当然也是有的, match, Rust会在编译期检查所有可能的情况你都做了处理, 当匹配到符合条件的分支时, 就进入对应模式的代码中处理 123456789101112131415enum Coin{ // 枚举 Penny, Nickel, Dime, Quarter,}fn value_in_cents(coin: Coin) -&gt; u8 { match coin { // match Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, }} 上面是一个枚举和以枚举成员当做模式的match表达式 这里的函数value_in_cents 接收一个枚举的实例, 然后进入match表达式, match关键字之后跟一个表达式, 在这里跟的是coin的实例. 没错, match之后可以跟任何类型. 而{}中的则是这个match的分支, 对于分支来讲, 有两个部分组成, 一个模式和一些代码. 比如第一个分支 Coin::Penny =&gt; 1 , 这里的Coin::Penny就是模式, =&gt; 后跟的就是代码, 当匹配到模式之后, 会运行定义的代码 一个match有多个分支, 在匹配时, 会从上到下匹配, 直到匹配成功后就退出match 匹配到的代码如果很短, 通常不使用大括号, 如果有多行代码则需要使用, 例如 1234567891011fn value_in_cents(coin: Coin) -&gt; u8 { match coin { // match Coin::Penny =&gt; { println!(\"Penny\"); // 打印 1 // 返回 }, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter =&gt; 25, }} 绑定值的模式 枚举可能是有值的, match 同样也可以获取到枚举实例的值 123456789101112#[derive(Debug)] // debugenum UsState { Alabama, Alaska,}enum Coin { Penny, Nickel, Dime(u8), Quarter(UsState),} 我们为枚举Coin的成员Quarter 设置值为另一个枚举 1234567891011fn value_in_cents(coin: Coin) -&gt; u8 { match coin { Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime =&gt; 10, Coin::Quarter(state) =&gt; { println!(\"State quarter from {:?}!\", state); 25 }, }} 然后在 match 时, 如果是 Quarter 则打印其值 12345678910111213141516171819202122232425262728293031323334#[derive(Debug)] // debugenum UsState { Alabama, Alaska,}enum Coin { Penny, Nickel, Dime(u8), Quarter(UsState),}fn value_in_cents(coin: Coin) -&gt; u8 { match coin { Coin::Penny =&gt; 1, Coin::Nickel =&gt; 5, Coin::Dime(v) =&gt; { println!(\"{}\", v); 8 }, Coin::Quarter(state) =&gt; { println!(\"State quarter from {:?}!\", state); 25 }, }}fn main(){ let d = Coin::Dime(20); let q = Coin::Quarter(UsState::Alaska); let dp = value_in_cents(d); let qp = value_in_cents(q);} 在这里使用cargo run 会出现几个报警, 这是因为没有将一些枚举使用起来, 这里不作理会 使用()的方式可以接受处理枚举中包含值的情况 匹配 Option&lt;T&gt; match同样可以处理Option&lt;T&gt; 123456789101112fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; { match x { None =&gt; None, Some(i) =&gt; Some(i + 1), }}fn main(){ let five = Some(5); let six = plus_one(five); let none = plus_one(None);} 因为Optione&lt;T&gt;可能存在为None的情况, 所以通过match进行分别处理, 这里的x 就是为None时不做任何处理, 有值时进行 +1 处理 匹配是穷尽的 Rust的匹配是穷尽的, 你必须为match设置能覆盖所有情况的分支, 否则会编译失败 12345678910fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; { match x { Some(i) =&gt; Some(i + 1), }}fn main(){ let five = Some(5); let six = plus_one(five);} 1234567891011121314151617181920error[E0004]: non-exhaustive patterns: `None` not covered --&gt; src/main.rs:2:11 |2 | match x { | ^ pattern `None` not covered | = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match armswarning: unused variable: `six` --&gt; src/main.rs:9:9 |9 | let six = plus_one(five); | ^^^ help: consider prefixing with an underscore: `_six` | = note: `#[warn(unused_variables)]` on by defaulterror: aborting due to previous errorFor more information about this error, try `rustc --explain E0004`.error: could not compile `t_enum`. 这里就是没有处理为None的情况, Rust会避免出现这种问题 _通配符 其他语言类似的分支处理, 通常会有一个default, 如果都匹配不上, 则会进入default分支, 通常default分支是写在最后的 123456789101112fn main() { let some_u8_value = 0; match some_u8_value { 1 =&gt; println!(\"one\"), 3 =&gt; println!(\"three\"), 5 =&gt; println!(\"five\"), 7 =&gt; println!(\"seven\"), _ =&gt; { println!(\"kkkkk\") }, }} Rust有一个_, 作用是通配符, 能匹配所有的情况 比如这里, 如果some_u8_value不是1/3/5/7的其中一个, 则最后会匹配到_分支 _分支需要写在最后, 因为他是通配的, 假如写在第一位, 那么所有的值都能匹配进_, 这样就会导致逻辑出现问题 if let简单控制流 如果有需求, 如果值为3则进行操作, 其他则不处理 1234567fn main(){ let some_u8_value = Some(0); match some_u8_value { Some(3) =&gt; println!(\"three\"), _ =&gt; (), }} 实际上, 如果使用match的话, 为了适应无穷性, 必须进行通配符适配, 难免会增加样板代码, 不简洁 Rust提供了if let, 来处理只匹配一个模式忽略其他模式的情况 123456fn main(){ let some_u8_value = Some(3); if let Some(3) = some_u8_value { println!(\"three\"); }} if let 后跟一个由=分割的模式和表达式, 比如这里, Some(3)就是模式, 表达式是 123{ println!(\"three\");} 当模式匹配后进行表达式的运行, 不匹配则不运行, 例如 123456fn main(){ let some_u8_value = Some(1); if let Some(3) = some_u8_value { // 不运行 println!(\"three\"); }} 相比普通的match 更加简单, 但是, 这种写法会失去编译时的穷尽检查, 让代码可能会超出你期望的方式运行, 因此使不使用需要自己衡量 if let 也可以加 else , 作用与通配符_一致, 例如 12345678fn main(){ let some_u8_value = Some(1); if let Some(3) = some_u8_value { println!(\"three\"); }else{ println!(\"other\") // 打印 }} 也可以和多个 if let 一起使用 1234567891011fn main() { let some_u8_value = Some(4); if let Some(3) = some_u8_value { println!(\"three\"); } if let Some(4) = some_u8_value { println!(\"four\") } else { println!(\"other\") }} 需要说明的是, 如果多个分支了, 最好还是使用 match, 这样反而会提高代码简洁性","link":"/2021/09/07/rust_programming_language(5)/"},{"title":"Rust程序设计语言(6)","text":"前言 真正写过项目的人都知道, 代码肯定不是一个文件可以搞定的, 里面的逻辑都是很复杂的, 所以项目都是有目录结构这种东西. 我们按照逻辑的分类将其分割开, 目的是提高代码的可读性. 随着项目的增大, 我们就会增加多个包的概念, 一个包可以包含多个二进制的crate项和一个可选的crate库, 随着包越来越大, 我们可以将包的部分代码提取出来, 做成独立的crate, 做成外部的依赖项, 通过引用的方式让代码可用, 本篇会讲诉这些怎么使用, 而rust有一个命名空间的概念, 这些将在之后解答. 一般我们还会把可以重复使用的逻辑和代码单独拎出来, 封装成单独的包, 暴露接口给其他人使用. 这里还会有一个作用域(scope)的概念, 代码所在的上下文有一组定义为in scope的名称, 当阅读, 编写, 编译代码时, 程序员和编译器需要知道特定的位置的特定的名称是否引用了变量, 函数, 结构体, 枚举, 模块, 常量或者其他有意义的项. 你可以创建作用域, 以及改变哪些名称在作用域内还是外面. 同一个作用域不能同时拥有两个相同名称的项 rust有许多功能可让你管理代码的组织, 包括哪些内容可以公开, 哪些作为私有的部分, 和程序的每个作用域的名字. 这些功能, 也被称作模块系统(the module system), 包括几个部分 包(packages): cargo的一个功能, 让你可以构建. 测试和分析crate crates: 一个模块的树形结构, 它形成了库或者二进制项目 模块(modules)和use: 让你控制作用域和路径的私有性 路径(path): 命名结构体, 函数或者模块的方式 包和 crate crate 是一个二进制或者库, crate root 是一切的开始, 编译器认为他是起始点, 并构成你的 crate 根模块 包 是提供一系列功能的一个或者多个 crate, 一个包会包含一个 cargo.toml 文件, 里面描述了怎样构建这些 crate 一个包中最多只能包含一个 库crate, 可以包含任意个 二进制crate, 包中至少有一个 crate, 不论他是 库crate 还是 二进制crate 我们使用 cargo new package_name 来创建包, 发现会生成几个默认的文件 12345678910➜ student cargo new package_modules Created binary (application) `package_modules` package➜ student cd package_modules ➜ package_modules git:(master) ✗ tree.├── Cargo.toml└── src └── main.rs1 directory, 2 files 我们看到会在 src 文件夹下生成 main.rs 文件, 事实上 rust 认为 main.rs 就是二进制 crate 的根, 也就是 crate root, 但是当 src 下有一个 lib.rs 时, rust认为此时这个包带有与其同名的的 库crate, 此时 lib.rs 为 crate 的根 回到我们这里来, 这时 包 package_name 下只有一个 二进制 crate, 当我们在 src 下新增 lib.rs, 则有一个 二进制 crate 和一个 库 crate 将多个文件放进 src/bin 下, 则会有多个 二进制 crate, 每个文件会单独编译成 二进制 crate 一个 crate 通常代表一个功能块的集合, 可以方便的分享给别人或者其他的包使用, 我们之前使用了 rand 来生成随机数, rand 就是一个 crate, 我们将其他人写的 crate 引入给我们自己使用, 我们使用 rand 时需要通过其名字 rand进行访问 对于作用域来讲, 一个 crate 内部的特征(比如rand的Rng), 会在内部生效, 当其他项目引用了 crate, 加入这个 crate 中有特征 a, 而本身的项目也有特征 a, 特们也不会混淆, 因为引用 crate 必须加上这个 crate 的名字(比如rand::Rng) 定义模块来控制作用域 如果我们需要写一个 crate 给其他项目使用, 那么我们就需要考虑一个问题, 就是提供什么函数或者特征给对方, 而我们自己内部的变量和函数, 肯定是不希望外面可以直接访问的, 我们希望能区分私有的和公开的东西 模块就可以让我们对 crate 的代码进行分组, 首先会提高可读性和复用性, 另外可以控制项的私有性, 将项分为不可以被外部使用的私有的(private), 和可以被外部使用的公有的(public) 我们使用 cargo 新的指令来新建一个名为restaurant的库 crate, cargo new --lib restaurant 12345678910➜ student cargo new --lib restaurant Created library `restaurant` package➜ student cd restaurant ➜ restaurant git:(master) ✗ tree.├── Cargo.toml└── src └── lib.rs1 directory, 2 files 使用新建库 crate 的方式, 发现不再生成 main.rs 而是 lib.rs 标志这是一个库 crate 我们修改 lib.rs 的代码为 123456789101112131415161718mod front_of_house { // mod定义一个模块 后面跟的是这个模块的名字front_of_house // 模块的内容 mod hosting { // 定义模块front_of_house下面的模块 hosting fn add_to_waitlist() {} // 模块 hosting 下的函数 fn seat_at_table() {} } mod serving { // 定义模块front_of_house下面的模块 serving fn take_order() {} fn server_order() {} fn take_payment() {} }} mod关键字为定义模块使用的, 后面跟的就是模块的名字, {} 中就定义了模块的具体的内容, 上边就定义了两个子模块. 子模块中定义了3个函数, 模块内可以定义模块, 函数, 结构体, 枚举, 常量和特征. 模块可以将相关的定义和代码放置在一起, 提高代码的可读性, 搭配注释使用效果更好 上面说过, crate的根可能是src/main.rs或者src/lib.rs, 其实这两个文件都分别在 crate 模块结构中自动生成一个名为 crate 的根模块,这种结构被称作 模块树(module tree) 例如上面的代码, 模块树的结构为 123456789crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment 既然是树形结构, 那么一定有父和子的关系, 还有平级的兄弟关系, 需要注意的是, 最上面的 crate 是隐式生成的, 所以被称为根 模块中项的路径 我们想引用模块中的某一个项, 就需要知道他的路径, 路径分为两种, 相对路径和绝对路径 相对路径 (absolute path): 从 crate 根开始, 一层一层找到该项 绝对路径(relative path): 从当前的模块开始, 都以self, super 或者当前模块的标识符作为开头 不管是什么路径, 都会跟一个或者多个由双冒号(::)分割的标识符 我们修改之前的模块, 为方便演示, 去除了多余的模块, 新增引用方式 12345678910111213141516mod front_of_house { // mod定义一个模块 后面跟的是这个模块的名字front_of_house // 模块的内容 mod hosting { // 定义模块front_of_house下面的模块 hosting fn add_to_waitlist() {} // 模块 hosting 下的函数 }}fn eat_at_restaurant() { // pub 是关键字, 代表这个函数是公有的 // Absolute path crate::front_of_house::hosting::add_to_waitlist(); // 绝对地址引用模块front_of_house的hosting模块的add_to_waitlist函数 // Relative path front_of_house::hosting::add_to_waitlist(); // 相对地址引用} 关键字pub标识这个项是公有的, 可以被外部调用的 对于绝对地址引用, 以crate开头, 因为要从最根的模块开始, 而最根的就是crate, 然后根据模块的定义树结构一步步的寻址, 每一层级中间使用::连接 相对地址来说, 因为 front_of_house 与 eat_at_restaurant 在一个层级, 所以无需加 crate, 因为他们都属于最大的 crate 模块 关于绝对路径和相对路径那种比较合适, 其实没有特别的要求, 从你的角度去考虑吧 (文档中说考虑到如果模块结构有变动, 如果是相对路径还需要修改路径, 所以推荐使用绝对路径) 因为是个库 crate, 所以我们应该使用cargo build而不是cargo run 123➜ restaurant git:(master) ✗ cargo build Compiling restaurant v0.1.0 (/Users/Work/Code/Rust/student/restaurant)error[E0603]: module `hosting` is private 我们可以发现, 在编译中会出现错误, 提示 hosting 模块是私有的 我们之前说过, 模块化的作用, 1是可以整理和分类项, 2是可以设置私有和公开 对于私有化的各种项, 不允许外部的代码去调用, 这样就避免了引用时将 crate 内部的项暴露给外面, 对于没有指定私有还是公开的项, 默认都是私有的 父模块只可以引入子模块的公开项 子模块可以访问父模块的所有项 兄弟模块直接可以互相访问所有项 使用 pub 来公开项 之前说过, 关键字pub可以将某个项设置为公开 我们修改之前的代码 12345678910111213141516mod front_of_house { // mod定义一个模块 后面跟的是这个模块的名字front_of_house // 模块的内容 pub mod hosting { // 定义模块front_of_house下面的模块 hosting, pub 设置其为公开 pub fn add_to_waitlist() {} // 模块 hosting 下的函数, pub 设置其为公开 }}fn eat_at_restaurant() { // pub 是关键字, 代表这个函数是公有的 // Absolute path crate::front_of_house::hosting::add_to_waitlist(); // 绝对地址引用模块front_of_house的hosting模块的add_to_waitlist函数 // Relative path front_of_house::hosting::add_to_waitlist(); // 相对地址引用} 这里需要特别注意, 如果你不将 add_to_waitlist 设置为公开, 只设置 hosting 也是不行的, 因为只设置模块为公开不代表里面的所有项为公开, 你需要访问 add_to_waitlist 函数, 所以函数项也需要设置 pub, 当你不设置 hosting 只设置 add_to_waitlist 也是不行 123➜ restaurant git:(master) ✗ cargo build Compiling restaurant v0.1.0 (/Users/Work/Code/Rust/student/restaurant) Finished dev [unoptimized + debuginfo] target(s) in 0.23s super 来设置相对路径 还有一种使用super来开头的找寻相对路径的方式, 看下面的例子 12345678910fn serve_order() {} // 函数 serve_ordermod back_of_house { // 模块 back_of_house fn fix_incorrect_order() { // 函数 fix_incorrect_order cook_order(); // 引用函数 cook_order super::serve_order(); // 相对引用 serve_order (super 方式) } fn cook_order() {} // 函数 cook_order} super 相当于 linux 路径中的 .. 的意思, 就是指的当前层级的上一级, 这里的上一级其实就是crate 结构体和枚举的公有化 对于结构体了来讲, 如果结构体设置了pub, 只代表这个结构体本身变为了公有, 下面的字段默认还是私有, 需要单独的指定pub才行 123456789101112131415161718192021222324252627mod back_of_house { pub struct Breakfast { // 设置公开的结构体 pub toast: String, // 设置结构体的字段 toast 公开 seasonal_fruit: String, // 不设置默认不公开 } impl Breakfast { pub fn summer(toast: &amp;str) -&gt; Breakfast { // 设置结构体的方法 summer 公开 Breakfast { toast: String::from(toast), seasonal_fruit: String::from(\"peaches\"), } } }}pub fn eat_at_restaurant() { // Order a breakfast in the summer with Rye toast let mut meal = back_of_house::Breakfast::summer(\"Rye\"); println!(\"{}\", meal.toast); // Change our mind about what bread we'd like meal.toast = String::from(\"Wheat\"); println!(\"I'd like {} toast please\", meal.toast); println!(\"{}\", meal.seasonal_fruit); // 不行, 因为不是公开的 } 而对于枚举来讲, 如果你pub了一个枚举项, 则该项下的成员全部是公有的 1234567891011mod back_of_house { pub enum Appetizer { // 公开的枚举项 Soup, // 公开 Salad, // 公开 }}pub fn eat_at_restaurant() { let order1 = back_of_house::Appetizer::Soup; let order2 = back_of_house::Appetizer::Salad;} 这是从使用场景来考虑的, 枚举通常作为多个可能的结果来使用, 所以你可能更需要全部公有, 而每一个都写上pub相对繁琐 而对于结构体来讲, 有可能并不是所有的字段都是需要公开的, 全部公开而有些不使用反而会降低代码质量 使用use关键字将名称引入作用域 在上面我们引用项时, 都必须在使用时写一个长长的路径, 而使用use, 可以只引入一次, 然后就可以像使用自己的项时使用引入的项啦 1234567891011121314mod front_of_house { // 模块 pub mod hosting { // 公开模块 pub fn add_to_waitlist() {} // 公开函数 }}use crate::front_of_house::hosting; // 引入 hostingpub fn eat_at_restaurant() { // 各种调用 hosting 下的项 hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();} 使用use引用需要的项之后, 就可以直接使用项了, 当然私有公有规则和之前的引用方式保持一致 相对路径也是可以的 1234567891011121314mod front_of_house { // 模块 pub mod hosting { // 公开模块 pub fn add_to_waitlist() {} // 公开函数 }}use front_of_house::hosting; // 引入 hostingpub fn eat_at_restaurant() { // 各种调用 hosting 下的项 hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();} use的惯用方式 引用函数项时不要直接引用到函数 上面的代码中, 我们使用use引入, 是引入use front_of_house::hosting 然后调用时使用hosting::add_to_waitlist() 可能有人会问, 为什么不引用时使用use front_of_house::hosting::add_to_waitlist 在使用时直接add_to_waitlist() 呢? 这样其实也是可以运行的, 只是不符合使用习惯, 我们希望, 在使用外部的函数项时, 尽量的保留上一级, 方便与本地的项做区分. 引用其他项时直接引用到该项 对于非函数的项, 通常直接引用到该项. 大家都这样写 但是也可能有例外, 比如, 两个不同的 crate 有相同的项, 例如 12345678910use std::fmt;use std::io;fn function1() -&gt; fmt::Result { // Result // --snip--}fn function2() -&gt; io::Result&lt;()&gt; { // Result // --snip--} 此时就还是要引用到上一级, 因为 rust 无法自己分辨某个项是哪个, 因为他们的名字都一样 使用as重命名 上面说的引用多个 crate 但是里面的项一致的问题, 还可以使用as关键字来为某个项重命名 12345678910use std::fmt::Result;use std::io::Result as IoResult; // 在本 crate 中重命名为 IoResult(本 crate 生肖)fn function1() -&gt; Result { // --snip--}fn function2() -&gt; IoResult&lt;()&gt; { // --snip--} 使用pub use重新导出项 对于我们自己的 crate 来讲, 我们导入的别人的公有项会变成我们自己的私有项, 如果我们想要将我们引入的项变成在我们的 crate 中同样也是公开的, 可以使用pub use 12345678910111213mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} }}pub use crate::front_of_house::hosting; // 重导出, 此时引用我们这个 crate 的代码也可以引用 hostingpub fn eat_at_restaurant() { // 自己的 crate 是可以使用front_of_house::hosting的 hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist();} 当其他代码引入我们的 crate 时, 可以使用hosting::add_to_waitlist来引入函数add_to_waitlist, 而这个函数对于我们的 crate 来讲也是我们引用的 使用外部包 就像 python的包仓库pypi一样, rust也有自己的软件仓库crates.io: Rust Package Registry, 我们之前用过上面的包rand, 方法是在Cargo.toml添加行 12[dependencies]rand = \"0.5.5\" 在Cargo.toml添加rand依赖告诉cargo从crates.io中下载, 并在项目代码中使用 然后使用use来引用这些项, 比如 12345use rand::Rng;fn main() { let secret_number = rand::thread_rng().gen_range(1, 101);} 注意标准库（std）对于你的包来说也是外部的 crate, 也需要你引入, 但是因为他太常使用了, 所以他被集成在了 Rust 中, 你无需修改 Cargo.toml 来引入 std，不过需要通过 use 将标准库中定义的项引入项目包的作用域中来引用它们，比如我们使用的 HashMap： 1use std::collections::HashMap; 通过嵌套路径来减少大量的use行 use关键字每一行只能写一个, 也就是说现在你只能在一行引入一个项, 当我们有很多项的时候, 就会出现很多行的问题, 比如 12use std::cmp::Ordering;use std::io; 他们都属于std, 此时我们可以将两条合并 1use std::{cmp::Ordering, io}; 使用{}来引入多个路径, 前提是他们都是同一个前缀, 每个路径以,分割 对于需要引入父路径又需要引入子路径的时候, 可以使用 self 来代表前缀本身 12use std::io;use std::io::Write; 修改为 1use std::io::{self, Write}; 通过golobal将所有公有项引入 我们也可以通过关键字golobal将某一个路径的所有公有项全部引入 1use std::collections::*; 这非常不推荐使用, 因为你很容易将其下的公有项与自己的项混淆, 而且通常引入的路径公有项你也不是全都会使用到 将模块分割进不同文件 到现在为止, 上面的例子中模块都在一个文件lib.rs中, 但是实际的开发中, 模块其实是很大的, 我们需要将其分割开来提高代码的可读性 我们新建src/front_of_house.rs文件, 并编写代码 123pub mod hosting { // 定义模块 hosting pub fn add_to_waitlist() {} // 公开函数} 再修改src/lib.rs代码 123456789mod front_of_house; // 引入同级目录下 front_of_house.rs 中的项加载模块pub use crate::front_of_house::hosting; // 引入子模块 hostingpub fn eat_at_restaurant() { // 公开函数 hosting::add_to_waitlist(); // 调用 hosting 的 add_to_waitlist 函数 hosting::add_to_waitlist(); hosting::add_to_waitlist();} 此时 src 下的文件有 123456➜ src git:(master) ✗ tree.├── front_of_house.rs└── lib.rs0 directories, 2 files 在 mod front_of_house 后使用分号，而不是代码块，这将告诉 Rust 在另一个与模块同名的文件中加载模块的内容, 这里是将 front_of_house.rs 的 hosting 导入了 有时候我们需要再加些目录来表达更复杂的关系, 举个例子 新建src/front_of_house 目录, 编写 src/front_of_house/hosting.rs文件 1pub fn add_to_waitlist() {} 修改文件 src/front_of_house.rs 1pub mod hosting; // 引入 同级的名为 front_of_house 文件夹下的 hosting.rs 文件的项 此时src下的文件结构是 12345678➜ src git:(master) ✗ tree.├── front_of_house│ └── hosting.rs├── front_of_house.rs└── lib.rs1 directory, 3 files 如上面的注释所说, 当你在 crate 的 rs 文件下找到了mod xxx; 的时候, 就代表他会引入同级与他文件名相同的文件夹下的xxx.rs 文件中的项 我一开始也不明白为什么这样写, 官方文档中也没有相对详细的介绍, 只找到了一小节说就要这样写, 参见: Modules - The Rust Reference (rust-lang.org) 总之找同级和同名的文件夹下内容就行了 多层结构也是这样 修改src/lib.rs 1234567891011mod front_of_house; // 引入 front_of_house.rs 文件的项pub use crate::front_of_house::hosting;pub use crate::front_of_house::hosting::test;pub fn eat_at_restaurant() { hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist(); test::t();} 修改src/front_of_house/hosting.rs 12pub mod test;pub fn add_to_waitlist() {} 新建文件夹src/front_of_house/hosting, 修改文件src/front_of_house/hosting/test.rs 1pub fn t(){} 此时他的目录为 12345678910➜ src git:(master) ✗ tree.├── front_of_house│ ├── hosting│ │ └── test.rs│ └── hosting.rs├── front_of_house.rs└── lib.rs2 directories, 4 files 可以看到, 在 hosting.rs 里新增了 pub mod test; 代表着去与他同级的目录也就是hosting中寻找test.rs文件, 找里面的项, 寻找到了函数t 在 lib.rs 中使用 hosting::test::t(); 即可调用这个函数项 我们也可以使用上面的对于嵌套的时候减少 use 的方式修改 lib.rs 的引用 12345678910mod front_of_house; // 引入 front_of_house.rs 文件的项pub use crate::front_of_house::hosting::{self, test}; // 引入 hosting 和 hosting::testpub fn eat_at_restaurant() { hosting::add_to_waitlist(); hosting::add_to_waitlist(); hosting::add_to_waitlist(); test::t();}","link":"/2021/11/11/rust_programming_language(6)/"},{"title":"Rust程序设计语言(7)","text":"前言 最近真的有点焦虑啊, 难受了 Rust 的标准库中有一些我们常用的数据结构, 帮助我们更快更好的开发代码, 这种数据结构被称为集合, 大部分其他的数据结构, 比如int大多数只能代表一个值, 而集合可以有多个值 当然我们之前提到的 数组, 元组, 也是可以存储多个值, 但是他们是将数据存储在 栈 上的, 之前我们说过, 栈上的数据是需要在分配时就指定其大小, 所以对于动态的可变的数据集合, 最好还是存在堆上, 集合就是这样, 所以一般而言, 使用本篇介绍的集合结构的时候通常比较多, 本篇介绍3个在 Rust程序中被广泛使用的集合 vector可以一个接一个的存储一系列数量可变的值 字符串(string)是字符的集合 哈希 map(hash map)可以将值和特定的键绑定, 和 python 的 dict 以及 golang的 map 类似 vector vector 类型是Vec&lt;T&gt;, vector 的特点是他的多个值都在内存中彼此相邻的排列在一起, 这样会提高查找和操作的速度, 一个 vec 下的所有值的类型必须相同 Vec in std::vec - Rust (rust-lang.org) 新建 可以使用Vec::new来新建一个空的Vec 1let v: Vec&lt;i32&gt; = Vec::new(); // 新建一个 Vec, Vec 内部的值类型是 i32, 现在还没有具体的值 这一句的作用是新建一个空的 Vec 类型, 此时因为没有给 Vec 设置指定的值, 所以 Rust 是不知道这个 Vec 需要存储的值的类型, 这里我们在新建时就使用Vec&lt;i32&gt;来设置里面存储的值的类型 还有一种方法 1let v = vec![1, 2, 3]; // 新建一个 Vec. 在创建时就插入3个值 1, 2, 3 注意到, vec!这是一个宏, 这个宏会根据我们提供的值来创建 Vector, 同时自己判断值的类型并给这个 vec 进行设置, 这里就是自己推断出是 i32 类型 更新 使用push里可以项 vec 里增加值 123456let mut v: Vec&lt;i32&gt; = Vec::new(); // 新建一个 Vec, Vec 内部的值类型是 i32, 现在还没有具体的值let mut v1 = Vec::new(); // 空的 vec, 类型还没有指定let mut v2 = vec![1, 2]; // vecv.push(3); // 新增v1.push(3); // 这里是先获取到值的类型, 设置 vec 的类型, 再新增到 v1v2.push(3); // 新增 push可以更新 vec 的值, 准确说是追加 这里的 v1 , 在新建时没有指定类型, 而是在 push 时靠 rust 自己判断, 也是可以的 释放 vector在其离开作用域时会被释放掉 123456{ let v = vec![1, 2, 3, 4]; // 处理变量 v} // &lt;- 这里 v 离开作用域并被丢弃 当 vector 被丢弃, 里面的值也会被丢弃 读取 读取 vector 的值可以使用索引和get 123456789let v = vec![1, 2, 3, 4, 5];let third: &amp;i32 = &amp;v[2]; // 获取索引2的值println!(\"The third element is {}\", third);match v.get(2) { // 使用 get 获取索引2的值, 没有就是 None, 这里使用 match 判断 Some(third) =&gt; println!(\"The third element is {}\", third), None =&gt; println!(\"There is no third element.\"),} 对于直接获取索引的方式, 如果索引超出了范围, 比如只有3个值, 结果你获取索引3, 就会导致程序发生 panic, 直接崩溃 使用get, 如果超出索引, 只会返回None, 所以一般使用 get 来防止程序崩溃 下面再看一个代码 1234567let mut v = vec![1, 2, 3, 4, 5]; // 可变的 veclet first = &amp;v[0]; // 借用 v 的第0个值v.push(6); // 给 v 追加值6println!(\"The first element is: {}\", first); // 触发了 panic 这个代码实际上会报错 123456789101112➜ t_vec git:(master) ✗ cargo run Compiling t_vec v0.1.0 (/Users/Work/Code/Rust/student/t_vec)warning: unused variable: `first` --&gt; src/main.rs:4:9 |4 | let first = &amp;v[0]; | ^^^^^ help: consider prefixing with an underscore: `_first` | = note: `#[warn(unused_variables)]` on by default Finished dev [unoptimized + debuginfo] target(s) in 0.32s Running `target/debug/t_vec` 之前在所有权那里, 你已经知道了, 可变引用和不可变是无法同时存在的, 这里的 first 是不可变引用, 随后 v 自己进行了追加操作, 而后再打印 first (不可变引用)就触发了冲突, 为什么对 v 进行 push 会对所有权进行转移? 这是因为 vector 之前说过, 里面的每个值在内存中是相邻的, 但是系统的内存分配并不受 rust 控制, 会出现这种情况, 本来这个 vec 长度为3, 于是 rust 在内存中存储了长度为3的数据, 此时别的软件也向系统申请了内存, 在你的数据之后, 与你的数据相邻, 此时你获取了索引为0的地址, 而后进行 push 操作, 新增一个值, 此时因为内存中你的相邻处已经被其他值占领, 于是rust 只能再请求一个新的长度为4的地址,把4个值重新放入新的地址保证相邻, 你再去访问之前的索引为0的地址, 此时这个地址的所有权就不在你的手上了, 所以 rust 不允许你进行操作了. 遍历 如果想要依次访问 vector 中的每一个元素, 我们可以对这个 vec 进行遍历 1234let v = vec![100, 32, 57];for i in &amp;v { println!(\"{}\", i);} 也可以遍历时对齐进行修改 1234let mut v = vec![100, 32, 57];for i in &amp;mut v { *i += 50; // 值增加50} 搭配枚举使用 vector 还有一个方便的特点是, 他也可以存储相同枚举的值, 因为他认为枚举也是同一个类型, 如果我们想要在一个 vec 中存储不同类型的值, 可以将这些类型设置为同一个枚举的成员 1234567891011enum SpreadsheetCell { Int(i32), Float(f64), Text(String),}let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\"blue\")), SpreadsheetCell::Float(10.12),]; // 可行, 此时他的类型是枚举 SpreadsheetCell 其他 vector 还有很多其他的方法, 比如pop可以删除最后一位值, 具体的可以查看 api 文档 字符串 我们之前使用过字符串, 而本章我们会深入的了解字符串 什么是字符串 你真的了解字符串吗? rust 中只有一种字符串类型, 那就是str, 对于字符串slice, 他通常是 str 的借用, 也就是&amp;str string类型是标准库提供的, 并没有写进核心语言部分, 他是可以增长的, 可以变动的, 有所有权的, 编码是 UTF-8的字符串类型 新建 1let mut s = String::new(); 上面的代码是新建了一个空的字符串 s, 然后我们可以给 s 填充数据, 但是通常我们会直接初始化失败时指定数据, 例如 1234567let data = \"initial contents\"; // 字符串字面值let s = data.to_string(); // 使用 to_string 方法// 该方法也可直接用于字符串字面值：let s = \"initial contents\".to_string(); // 更加简单的写法let s = String::from(\"initial contents\"); // 更加简单的写法2 只要某个类型实现了Display类型, 他就可以使用 to_string 方法来转换成字符串 对于这两种简单写法, 并没有什么优劣, 所以按需使用 rust 中的字符串编码为utf-8, 所以他能放入任何可以正确编码的数据 更新 string的大小可以增加, 内容也可以修改 使用push_str和push来追加字符串 使用push_str来追加字符串 slice 12let mut s = String::from(\"foo\");s.push_str(\"bar\"); // s 为 foobar 这里对 s 使用push_str, 对 s 进行字符串的追加, 同时, 为了保证所有权不转移, push_str使用的是字符串 slice 使用push来追加字符(不是字符串) 12let mut s = String::from(\"lo\");s.push('l'); // s = lol 使用 + 运算符或者 fromat! 宏拼接字符串 你还可以使用+方便的组合字符串 123let s1 = String::from(\"Hello, \");let s2 = String::from(\"world!\");let s3 = s1 + &amp;s2; // 注意 s1 被移动了，不能继续使用 这里的 s3 会成为 Hello, world! , 注意代码 s1 + &amp;s2, 这是因为+使用的函数定义为 1fn add(self, s: &amp;str) -&gt; String { 其中, self 是 s1, s 为 &amp;s2, 这里要求参数是引用, 避免参数 s 的所有权发生转移. 其次, 我们注意这个参数类型是 str 的引用, 而 s2是 String 类型, 为什么能编译运行呢? 这是因为&amp;String可以被强转成&amp;str, 在调用+时, Rust 使用了强制转换, 将其变成&amp;str 这里说的 s1的所有权被移动了, 是因为参数self获取了所有权, 此时所有权到了add中, 所以下面使用 s1会造成错误 还可以使用宏format! 12345let s1 = String::from(\"tic\");let s2 = String::from(\"tac\");let s3 = String::from(\"toe\");let s = format!(\"{}-{}-{}\", s1, s2, s3); 类似于 golang 的 fmt.Printf, 就是格式化字符串 索引字符串 很多类型都可以使用索引来访问其中某个元素, 但是对于字符串, 则是不行的, 字符串并不支持使用索引语法 内部实现 String是一个Vec&lt;u8&gt;的封装, 比如字符串Hola在Rust 中的长度是四个字节, 这是正确的, 因为每个字母的 utf8 编码都占用1格子姐, 那么字符串дравствуйте则不同, 字符串дравствуйте的长度为22, 这是因为дравствуйте的每一个字符需要两个字节存储, 他是unicode 编码, 但是按照索引来获取, 是按照字节去寻址, 那么问题就出现了, 你获取дравствуйте的索引0, 不是д, 而是д的一部分, 这就不是你想要获取到的结果了 所以 rust 为了避免出现问题, 将这个功能屏蔽了 其实 rust 也可以分辨出哪些存储多少字节, 而在你获取索引时对不同情况做特殊的处理, 但是这样的话势必会造成性能的损耗, rust 还需要多次的判断和遍历才能获取到你想要的结果, 而 Rust 期望获取值的时间为(O(1)) 使用字符串 slice 如果我们就是想要使用索引, 这里有一个危险的方法 123let hello = \"дравствуйте\";let s = &amp;hello[0..4]; // др 获取дравствуйте的前4个字节, 之前说过俄语是两个字节为一个字符, 所以这里是前两个字符 如果你获取的是 [0..1], 因为顾头不顾尾原则, 实际上获取的是д的一部分, 那么此时会导致Panic 1thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `дравствуйте`', src/libcore/str/mod.rs:2188:4 所以非常不推荐使用这个方法 遍历字符串 Rust 提供了一种方法可以让你遍历字符串, 这是安全的, 而且是按照字符遍历而不是字节 123456fn main() { let s = String::from(\"дравствуйте\"); for c in s.chars(){ println!(\"{}\", c) }} 运行 1234567891011дравствуйте 而当你想遍历每一个原始字节, 使用.bytes() 123456fn main() { let s = String::from(\"дравствуйте\"); for c in s.bytes(){ println!(\"{}\", c) }} 12345678910111213141516171819202122208180209128208176208178209129209130208178209131208185209130208181 这里的每个数字都是每个字节的 ascii 对照 哈希 map 哈希 map 其他语言也有, 比如 golang 的 map, python 的 dict, 在 Rust 中他是HashMap&lt;k, v&gt;, 他的结构是一个键类型k对应一个值类型v, 他通过哈希函数来实现两者的映射管理, 你可以很方便的通过某个 k 找到对应的 v 新建 使用new创建一个空的HashMap, 使用insert来增加元素 123456use std::collections::HashMap;let mut scores = HashMap::new(); // hashmapscores.insert(String::from(\"Blue\"), 10); // Blue: 10scores.insert(String::from(\"Yellow\"), 50); // Yellow: 50 因为 hashmap 相对于 vector 和 string 来说并不是那么常用, 所以并没有默认就导入, 所以需要通过 use std::collections::HashMap; 来导入到当前的代码中 我们之前说过集合都是将数据存放在堆上的 所以可以方便的进行扩容, 而与 vector 相同的是, 哈希 map 是同质的, 所有的键都必须是相同的类型, 值也是 另一种构建哈希 map 的方式调用一个 vector 的collect方法, 这个 vector 必须是元组类型, 例如 123456use std::collections::HashMap;let teams = vec![String::from(\"Blue\"), String::from(\"Yellow\")];let initial_scores = vec![10, 50];let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect(); 这里是使用 zip 将两个 vector 组合, 再使用collect将其转换成一个 hashmap HashMap&lt;_, _&gt; 是必须要标记的, 他代表 collect 输出的结构. 必须要显式的指定才可以, 其中的_代表占位 所有权 hashmap 也有所有权, 对于像i32这种实现了Copy的 trait 的类型, 其值可以拷贝进哈希 map. 对于像string的拥有所有权的值, 其值将被移动到哈希 map 中, 成为这个值的所有者 123456789use std::collections::HashMap;let field_name = String::from(\"Favorite color\");let field_value = String::from(\"Blue\");let mut map = HashMap::new();map.insert(field_name, field_value); // 插入// 这里 field_name 和 field_value 不再有效，// 尝试使用它们看看会出现什么编译错误！ 而将值的引用插入到哈希 map 中时, 这些值本身不会被移动到 map 中 访问哈希 map 值 get 使用 get 123456789use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10); // 插入scores.insert(String::from(\"Yellow\"), 50);let team_name = String::from(\"Blue\");let score = scores.get(&amp;team_name); // 获取key Blue 的值 如果 key blue 不存在, 则会返回None 循环 使用 for 循环来遍历键值对 12345678910use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);scores.insert(String::from(\"Yellow\"), 50);for (key, value) in &amp;scores { println!(\"{}: {}\", key, value);} 特别注意, 因为是 hash 的方式, 所以 hashmap key是无序的 更新哈希 map 覆盖 对于已经存在的 key, 我们可以直接覆盖这个 key 下的值, 直接使用insert即可 12345678use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);scores.insert(String::from(\"Blue\"), 25);println!(\"{:?}\", scores); // 25 只新建不覆盖 你可以能注意, 使用insert会直接覆盖值, 那么如果我们想只在这个 key 不存在时才插入的话, 配合使用entry即可 123456789use std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(\"Blue\"), 10);scores.entry(String::from(\"Yellow\")).or_insert(50); // 不存在再插入scores.entry(String::from(\"Blue\")).or_insert(50);println!(\"{:?}\", scores); entry 返回了一个枚举Entry, 其有一个方法or_insert在建对应的值存在时就返回这个值的可变引用, 如果不存在就将参数作为新值插入并返回可变引用 根据旧值更新 比如对值进行+1而不关注这个值本来的值 123456789101112use std::collections::HashMap;let text = \"hello world wonderful world\";let mut map = HashMap::new();for word in text.split_whitespace() { // 遍历每个字符 let count = map.entry(word).or_insert(0); // 这个字符作为 key 不存在就 set 成0 *count += 1; // +1}println!(\"{:?}\", map); 之前说过, entry不管怎样都会返回值的可变引用, 所以我们直接修改这个引用的值即可 获取可被修改的值 有时候hashmap 重点值存储的可能是 vector 这种集合, 而我们想要获取值并进行 push 或者其他的追加操作, 可以使用get_mut 1234let mut company = HashMap::new();company.insert(\"c1\", vec![1, 2]);let c1 = company.get_mut(\"c1\"); // 获取值的可变引用c1.unwrap().push(3) // unwrap 是将类型剥离出来, 使用get_mut可以获得值的可变引用, 以便我们直接对其进行修改 同时, unwrap也必不可少, 不使用unwrap时, 运行报错 1no method named `push` found for enum `std::option::Option&lt;&amp;std::vec::Vec&lt;{integer}&gt;&gt;` in the current scope 此时可以看出来, c1的类型变成了 std::option::Option&lt;&amp;std::vec::Vec&lt;{integer}&gt;&gt;, 被包裹在了Option 中, 我们必须要调用unwrap将其剥离出来, 类型变回&amp;std::vec::Vec&lt;{integer}&gt; 即可 练习题 求平均数 给定一系列数字，使用 vector 并返回这个列表的平均数（mean, average）、中位数（排列数组后位于中间的值）和众数（mode，出现次数最多的值；这里哈希 map 会很有帮助） 1234567891011121314151617fn average(v: &amp;Vec&lt;f64&gt;) -&gt; f64 { let mut sum = 0.0; for i in v{ sum += i } sum / v.len() as f64 // len 返回长度, 类型是 usize, 通过 as 转换成 f64 // / 是除}fn main() { let v0 = vec![1.0, 2.0, 3.0, 5.0]; let v1 = vec![-1.0, -2.0, -3.0]; let v0average = average(&amp;v0); let v1average = average(&amp;v1); println!(\"v0 res = {}\", v0average); println!(\"v1 res = {}\", v1average)} 这里有之前没有写到博客里的 vector 的 len 方法, 返回长度 字符串转换 将字符串转换为 Pig Latin，也就是每一个单词的第一个辅音字母被移动到单词的结尾并增加 “ay”，所以 “first” 会变成 “irst-fay”。元音字母开头的单词则在结尾增加 “hay”（“apple” 会变成 “apple-hay”）。牢记 UTF-8 编码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647fn pig_lation(g: &amp;str) -&gt; String { // 因为 str 必须要在初始化时就要知道其大小, 所以返回 string // 转换成 string let general = g.to_string(); let mut is_vowel = false; let vowel = vec!['a', 'i', 'y', 'o', 'u']; // 获取首字母, 查看是元音还是辅音 // 不能粗暴的直接获取索引0, 需兼容其他语言 for i in general.chars(){ for k in &amp;vowel{ if i.to_string() == k.to_string() { is_vowel = true } } break } if is_vowel{ // 首字母是元音 return format!(\"{}-hey\", general) }else{ let mut p = String::new(); let mut is_first = true; let mut first_word = String::new(); for i in general.chars(){ if is_first{ // 第一次 first_word = i.to_string(); is_first = false; continue }else{ p = p+&amp;i.to_string() } } return format!(\"{}-{}ay\", p, first_word) }}fn main() { let t0 = \"apple\"; let t1 = \"first\"; let t2 = \"苹果\"; let r0 = pig_lation(t0); let r1 = pig_lation(t1); let r2 = pig_lation(t2); println!(\"r0 = {}\", r0); println!(\"r1 = {}\", r1); println!(\"r2 = {}\", r2)} 部门控制 使用哈希 map 和 vector，创建一个文本接口来允许用户向公司的部门中增加员工的名字。例如，“Add Sally to Engineering” 或 “Add Amir to Sales”。接着让用户获取一个部门的所有员工的列表，或者公司每个部门的所有员工按照字典序排列的列表。 123456789101112131415161718192021222324252627use std::{io, collections::HashMap}; // 引入标准库fn main(){ println!(\"CRM\"); let mut company = HashMap::new(); loop{ println!(\"输入所在部门-&gt;\"); let mut class = String::new(); // 创建一个字符串变量 class io::stdin() // 调用函数stdin .read_line(&amp;mut class) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 println!(\"输入用户名-&gt;\"); let mut name = String::new(); // 创建一个字符串变量 name io::stdin() // 调用函数stdin .read_line(&amp;mut name) // 调用stdin的方法read_line获取输入值 .expect(\"读取失败\"); // 如果获取错误打印警告 let ns = company.get_mut(&amp;class); // 获取可变引用 if ns == None{ company.insert(format!(\"{}\", class), vec![format!(\"{}\", name)]); // 防止所有权转移, 使用 format 重新制造一个 str }else{ ns.unwrap().push(name) // 直接 push } for i in company.get_mut(&amp;class).unwrap(){ println!(\"{}\", i) } }}","link":"/2021/11/26/rust_programming_language(7)/"},{"title":"记一次破解 gitbook_lock 密码的过程","text":"前言 不知道啥时候起的歪风邪气, 国内人写的文章都会在下面标二维码, 是赞助的也就算了, 还整个公众号, 我也关注了几个公众号, 日推90%都是卖课, 找点营养简直是💩里淘金, 你放广告可以, 我不关注就行, 结果后来越来越离谱, 渐渐的有些变成了关注公众号才能看见内容, 大无语了. 就是类似于这样 今天就突发奇想, 看看能不能绕过这种机制, 结果还真发现挺简单的, 几分钟就搞定了, 于是这里小小的记录一下排查过程 下面的\"作者\"代表的是我们要破解的这个网站的作者, 而本人以\"我\"代称 思考作者的实现方式 一上来就去实操是不明智的, 一个人很容易走入死胡同, 我习惯在解决问题前先思考问题, 期望能了解原因和目的 作者在这里写的是\"获取注册码后永久免费观看文章\", 首先我随便输入一个验证码, 点击提交, 发现并没有要求我登录, 这说明这个验证码是通用的, 可能只有一个或者有限的几个, 不然我不登录, 他怎么知道这个验证码属于我呢? 而且我在第一家公司做过一些需要对接微信接口的功能, 我知道对于微信公众号来讲, 要想做一些比较开放的操作, 比如做到不同的人在公众号发送同样的消息, 回复不同的内容, 需要企业开发者开发的公众号才可以, 个人的开发者只能做到在后台设置用户发送某个消息你自动回复某个消息, 消息是固定的, 只有接自己的接口才可以做到随机生成, 而一般这种公众号都是个人公众号, 企业的很少 而且网站本身不支持登录, 没有办法这个微信用户与当前正在浏览的用户建立关系. 那么就有两种可能 这个验证码就放到了网页之中, 我的意思是作者靠 JS 去判断验证码是否正确, 这就代表正确答案也在某个文件中 这个验证码的校验是通过 HTTP 请求来做的, 这种需要自己有服务器写 api, 可能性不大 如果是可能2, 那么就很难去做了, 我们要先看一下是哪一种, 校验的方式很简单, f12打开看一下点击提交时有没有发送请求 很幸运, 并没有, 因为绝大部分都不是自己写 api, 这是因为: 一般博客都使用现成的博客框架, 比如 hexo 这些, 自己写前端的人很少, 对于使用框架的人来讲, 这种🔒的机制都是通过别人写的组件来做的, 而别人写组件不会考虑你自己的 api 是怎么实现的, 接口怎么走, 返回的数据是什么, 所以公开的组件除了接入出名的服务, 比如谷歌统计这些, 剩下的都是本地实现的 那么到这里就明了了, 这里的作者使用了某个博客框架的某个组件, 这个组件可以做到将文章隐藏部分, 只有输入正确的验证码才能解锁, 而这个正确的验证码也是写进前端中的, 由本地去做校验 查找正确的验证码 我先使用 f12 定位到提交按钮的前端元素 1&lt;button onclick=\"bc()\" id=\"btw-submit-btn\" style=\"padding: 0 20px; height: 32px; font-size: 14px; outline: none; border: none; color: rgb(255, 255, 255); background: rgb(222, 104, 109); cursor: pointer;\"&gt;提 交 &lt;/button&gt; 看到这里写了点击按钮时触发函数bc, 但是这个函数名太短了, 我先尝试一下能不能找到这个函数. 依旧是打开 f12, 在点击 tab 源代码 一栏, 这里会展示页面所有的资源 鼠标移动到 top, 右键有一个选项: 在所有文件中搜索, 点击这个选项, 搜索 bc( 搜索出了4个匹配, 第一个一看就是百度统计, hm.baidu.com/hm.js太熟悉了, 直接跳过 第二个, 看这个 js 名: gitbook-plugin-lock/lock.js, 这应该就是我们需要的, 查看这个 js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394require(['gitbook', 'jQuery'], function(gitbook, $) { let lockTokenKey; let wechatName; let wechatQr; let verificationCode; let thisCode; let thisValue; let allPage; let articleHeightPercent; function insertPageLock(e) { let authToken= localStorage.getItem(lockTokenKey) if (authToken!==isNaN(0)||authToken!==\"\"||authToken!==undefined) { for (let i in verificationCode) { if (verificationCode[i][\"value\"] === authToken) { return true; } } } const cla = document.getElementById(\"book-search-results\"); const article = cla, height = article.scrollHeight; const halfHeight = height * articleHeightPercent; cla.style.height= halfHeight + 'px'; cla.style.overflow = 'hidden' const html = '&lt;div id=\"page-lock-wrap\" style=\"position: absolute; bottom: 0; z-index: 9999; width: 100%; margin-top: -100px; font-family: PingFangSC-Regular, sans-serif;\"&gt;' + '&lt;div id=\"page-lock-mask\" style=\"position: relative; height: 200px; background: -webkit-gradient(linear, 0 0%, 0 100%, from(rgba(255, 255, 255, 0)), to(rgb(255, 255, 255)));\"&gt;&lt;/div&gt;' + '&lt;div class=\"info\" style=\"position: absolute;left: 50%;top: 70%;bottom: 30px;transform: translate(-50%, -50%);font-size: 15px;text-align: center;background: -webkit-gradient(linear, 0 0%, 0 100%, from(rgba(255, 255, 255, 0)), to(rgb(255, 255, 255)));\"&gt;\\n' + ' &lt;div&gt;扫码或搜索：&lt;span style=\"color: #E9405A; font-weight: bold;\"&gt;'+wechatName+'&lt;/span&gt;&lt;/div&gt;\\n' + ' &lt;div&gt;\\n' + ' &lt;span&gt;发送 &lt;/span&gt;&lt;span class=\"token\" style=\"color: #e9415a; font-weight: bold; font-size: 17px; margin-bottom: 45px;\"&gt;'+thisCode+'&lt;/span&gt;\\n' + ' &lt;/div&gt;\\n' + ' &lt;div&gt;\\n' + ' 即可&lt;span style=\"color: #e9415a; font-weight: bold;\"&gt;立即永久&lt;/span&gt;解锁本站全部文章\\n' + ' &lt;/div&gt;\\n' + ' &lt;div id=\"btw-modal-input-code\" style=\"margin-top: 20px; background: rgb(255, 255, 255);\"&gt;&lt;input '+ ' id=\"btw-modal-input\" type=\"text\" maxLength=\"10\" placeholder=\"请输入验证码\" '+ ' style=\"width: 160px; height: 32px; line-height: 32px; padding: 0 10px; margin: 0 10px; font-size: 13px; text-rendering: auto; text-transform: none; cursor: text; outline: none; box-sizing: border-box; border: 1px solid rgb(221, 221, 221); appearance: textfield; background-color: white; -webkit-rtl-ordering: logical;\"&gt;'+ ' &lt;button onclick=\"bc()\" id=\"btw-submit-btn\" '+ ' style=\"padding: 0 20px; height: 32px; font-size: 14px; outline: none; border: none; color: rgb(255, 255, 255); background: rgb(222, 104, 109); cursor: pointer;\"&gt;提 '+ ' 交'+ ' &lt;/button&gt;&lt;/div&gt;\\n '+ ' &lt;div&gt;\\n' + ' &lt;img class=\"code-img\" style=\"width: 300px;display:unset\" src=\"'+wechatQr+'\"&gt;\\n' + ' &lt;/div&gt;\\n' + '&lt;/div&gt;' + '&lt;/div&gt;'; const child = document.createElement('div') child.innerHTML = html cla.appendChild(child) bc = function () { const val = document.getElementById('btw-modal-input').value if (val === thisValue) { cla.style.height = height + 'px'; cla.style.overflow = 'visible'; const rm = document.getElementById(\"page-lock-wrap\") rm.parentNode.removeChild(rm) localStorage.setItem(lockTokenKey, thisValue) } else if (val === \"\" || val === undefined || val === isNaN(0)) { return false; } else { alert(\"验证码不正确!\") } } } gitbook.events.bind('start', function(e, config) { lockTokenKey = config.lock.lockTokenKey || 'lock-token'; wechatName = config.lock.wechatName || ''; wechatQr = config.lock.wechatQr || ''; verificationCode = config.lock.verificationCode || ''; allPage = config.lock.allPage || false; articleHeightPercent = config.lock.articleHeightPercent || 0.5; if (articleHeightPercent &gt;= 1 || articleHeightPercent &lt;= 0) { articleHeightPercent = 0.5 } const rand = Math.floor(Math.random() * verificationCode.length) thisCode = verificationCode[rand][\"key\"] thisValue = verificationCode[rand][\"value\"] }); gitbook.events.bind('page.change', function(e) { const place = document.getElementsByClassName(\"page-lock-place\") if (allPage || place.length !== 0) { insertPageLock(e); } });}); 这里我们看到了函数bc, 比对是这里 if (val === thisValue), 相等则将结果展示, 不想等就弹出验证码不正确, 明确了thisValue就是正确的验证码 我在这个 js 中搜索 thisValue , 总共四处, 有一处是这里 123const rand = Math.floor(Math.random() * verificationCode.length) thisCode = verificationCode[rand][\"key\"]thisValue = verificationCode[rand][\"value\"] 从代码来看, 是获取的verificationCode, 这个verificationCode是一个列表, 然后随机获取一个列表内的 key 和 value, 这里的 key 就是图上的1024, value 就是正确的验证码了, 这里并没有定义具体的值, 这也是正确的, 因为既然是组件, 肯定不会让组件的开发者写死正确的验证码, 有一个配置文件放置正确的验证码, 这里应该是加了点花样, 每次还是会随机获取一个 key 和 value, 我刷新了一下页面, 果然提示的要给公众号发送的 key 已经变成另一个了, 我猜测, verificationCode的结构应该是 12345[ {\"key\": \"1024\", \"value\": \"正确的验证码\"}, {\"key\": \"面试\", \"value\": \"正确的验证码\"}, ...] 所以我全部文件搜索 verificationCode, 果然在一个 html 文件中查到了信息 123456&lt;script&gt; var gitbook = gitbook || []; gitbook.push(function() { gitbook.page.hasChanged({\"page\":{\"title\":\"基础\",\"level\":\"2.1\",\"depth\":1,\"next\":{\"title\":\"个人学习笔记\",\"level\":\"2.2\",\"depth\":1,\"path\":\"Golang/学习笔记.md\",\"ref\":\"Golang/学习笔记.md\",\"articles\":[]},\"previous\":{\"title\":\"@xzghua\",\"level\":\"1.2\",\"depth\":1,\"url\":\"https://www.github.com/xzghua\",\"ref\":\"https://www.github.com/xzghua\",\"articles\":[]},\"dir\":\"ltr\"},\"config\":{\"plugins\":[\"accordion\",\"pageview-count\",\"copy-code-button\",\"click-reveal\",\"expandable-chapters\",\"donate\",\"anchor-navigation-ex\",\"hide-element\",\"statistics\",\"github-buttons\",\"lightbox\",\"custom-favicon\",\"-lunr\",\"-search\",\"search-pro\",\"insert-logo\",\"splitter\",\"gitalks\",\"lock\",\"mermaid-gb3\",\"theme-comscore\"],\"styles\":{\"website\":\"styles/website.css\",\"pdf\":\"styles/pdf.css\",\"epub\":\"styles/epub.css\",\"mobi\":\"styles/mobi.css\",\"ebook\":\"styles/ebook.css\",\"print\":\"styles/print.css\"},\"pluginsConfig\":{\"statistics\":{\"bd_url\":\"https://hm.baidu.com/hm.js\",\"cnzz_url\":\"https://s95.cnzz.com/z_stat.php\",\"google_url\":\"https://www.googletagmanager.com/gtag/js\",\"bd_token\":\"efcf1af531176f98a2ecd0648da80892\",\"cnzz_id\":1278118665},\"gitalks\":{\"flipMoveOptions\":{},\"clientID\":\"1cf16fa2a845aab2bfa4\",\"number\":-1,\"perPage\":10,\"proxy\":\"https://withered-block-2317.interview.workers.dev/?https://github.com/login/oauth/access_token\",\"admin\":[\"chuhsent\",\"xzghua\"],\"createIssueManually\":false,\"distractionFreeMode\":false,\"repo\":\"interview-comment\",\"owner\":\"wzcu\",\"enableHotKey\":true,\"clientSecret\":\"25fdef949a46bdc9507ecdea23c21ce745b56cf0\",\"pagerDirection\":\"last\",\"labels\":[\"Gitalk\"]},\"splitter\":{},\"search-pro\":{},\"accordion\":{},\"lock\":{\"verificationCode\":[{\"key\":\"1024\",\"value\":\"2048\"},{\"key\":\"666\",\"value\":\"6666\"},{\"key\":\"面试\",\"value\":\"造火箭\"},{\"key\":\"2048\",\"value\":\"1024\"}],\"lockTokenKey\":\"lock-token-key\",\"wechatName\":\"技术抛光\",\"wechatQr\":\"http://interview.wzcu.com/static/qrcode.jpg\",\"allPage\":false,\"articleHeightPercent\":0.6},\"donate\":{\"alipay\":\"http://www.iphpt.com/static/uploads/images/alipay.jpeg\",\"alipayText\":\"支付宝打赏\",\"button\":\"赏\",\"title\":\"\",\"wechat\":\"http://www.iphpt.com/static/uploads/images/wechat2.jpeg\",\"wechatText\":\"微信打赏\"},\"hide-element\":{},\"fontsettings\":{\"theme\":\"white\",\"family\":\"sans\",\"size\":2},\"click-reveal\":{},\"highlight\":{},\"mermaid-gb3\":{},\"anchor-navigation-ex\":{\"associatedWithSummary\":true,\"float\":{\"floatIcon\":\"fa fa-navicon\",\"level1Icon\":\"\",\"level2Icon\":\"\",\"level3Icon\":\"\",\"showLevelIcon\":false},\"mode\":\"float\",\"multipleH1\":true,\"pageTop\":{\"level1Icon\":\"\",\"level2Icon\":\"\",\"level3Icon\":\"\",\"showLevelIcon\":false},\"printLog\":false,\"showGoTop\":true,\"showLevel\":true},\"favicon\":\"./static/red_rocket02.png\",\"lightbox\":{\"jquery\":true,\"sameUuid\":false},\"theme-comscore\":{},\"pageview-count\":{},\"github-buttons\":{\"buttons\":[{\"user\":\"wzcu\",\"repo\":\"interview-comment\",\"type\":\"star\",\"size\":\"small\",\"count\":true},{\"user\":\"wzcu\",\"repo\":\"interview-comment\",\"type\":\"watch\",\"size\":\"small\",\"count\":true}]},\"custom-favicon\":{},\"copy-code-button\":{},\"mygitalk\":{\"clientID\":\"1cf16fa2a845aab2bfa4\",\"clientSecret\":\"25fdef949a46bdc9507ecdea23c21ce745b56cf0\",\"repo\":\"interview-comment\",\"owner\":\"wzcu\",\"admin\":[\"chuhsent\",\"xzghua\"],\"distractionFreeMode\":false,\"proxy\":\"https://withered-block-2317.interview.workers.dev/?https://github.com/login/oauth/access_token\"},\"sharing\":{\"facebook\":true,\"twitter\":true,\"google\":false,\"weibo\":false,\"instapaper\":false,\"vk\":false,\"all\":[\"facebook\",\"google\",\"twitter\",\"weibo\",\"instapaper\"]},\"theme-default\":{\"styles\":{\"website\":\"styles/website.css\",\"pdf\":\"styles/pdf.css\",\"epub\":\"styles/epub.css\",\"mobi\":\"styles/mobi.css\",\"ebook\":\"styles/ebook.css\",\"print\":\"styles/print.css\"},\"showLevel\":false},\"insert-logo\":{\"style\":\"background: none; max-height: 30px; min-height: 30px\",\"url\":\"/static/red_rocket01.jpg\"},\"expandable-chapters\":{}},\"theme\":\"default\",\"pdf\":{\"pageNumbers\":true,\"fontSize\":12,\"fontFamily\":\"Arial\",\"paperSize\":\"a4\",\"chapterMark\":\"pagebreak\",\"pageBreaksBefore\":\"/\",\"margin\":{\"right\":62,\"left\":62,\"top\":56,\"bottom\":56}},\"structure\":{\"langs\":\"LANGS.md\",\"readme\":\"README.md\",\"glossary\":\"GLOSSARY.md\",\"summary\":\"SUMMARY.md\"},\"variables\":{},\"links\":{\"sidebar\":{\"Home\":\"http://interview.wzcu.com\"}},\"gitbook\":\"*\"},\"file\":{\"path\":\"Golang/基础.md\",\"mtime\":\"2021-08-29T03:42:36.050Z\",\"type\":\"markdown\"},\"gitbook\":{\"version\":\"3.2.3\",\"time\":\"2021-12-05T02:37:19.012Z\"},\"basePath\":\"..\",\"book\":{\"language\":\"\"}}); }); &lt;/script&gt; 这里发现了 verificationCode的值是 1\"lock\":{\"verificationCode\":[{\"key\":\"1024\",\"value\":\"2048\"},{\"key\":\"666\",\"value\":\"6666\"},{\"key\":\"面试\",\"value\":\"造火箭\"},{\"key\":\"2048\",\"value\":\"1024\"}] 也就是说有4个 key, 分别是1024, 2048, 造火箭, 666 至于正确的验证码就是其对应的 value 我本次的 key 是1024, 所以我输2048点击提交果然成功了 正确凭证存储在了哪里 其实这个也很简单. 看函数bc的代码, 在验证码正确时那部分 1localStorage.setItem(lockTokenKey, thisValue) 这里是将数据保存在 localStorage 中, key 暂时不知道是什么, 而 value 则是正确的验证码 而lockTokenKey在全部文件搜索后, 发现跟verificationCode在一起定义了 1\"lockTokenKey\":\"lock-token-key\" 那么我们为了校验, 打开 f12, 查看 应用程序 的 tag, 果然找到了 我们将其删除后刷新页面, 发现果然又需要重新输入验证码了 总结 其实这是很简单的一次破解, 几分钟搞定, 没有做更细致的查找, 比如流程逻辑, 因为你的目的只是想看文章而已, 而类似这种没有自己的用户体系, 但是又告诉你关注公众号发送指定的消息获取永久验证码访问内容, 基本也都是这样的讨论 希望以这种方式来给自己的公众号引流的博客越来越少, 主要是你内容都是卖课, 都是垃圾内容, 实在是让人反感","link":"/2021/12/21/skip_gitbook_lock/"},{"title":"折腾腾讯云服务器","text":"前言 最近真的很忙, 生活上买的房子要网签, 办贷款拉流水啥的. 工作上老板觉得工作量不够又开始995, 同时工作量也多很多, 只能周末写写博客了, 真是蚌埠住了 😅 双11的时候啥都在做活动, 各大云厂商也是, 但是阿里的属于是 “老用户与狗不能入内”, 相比之下腾讯就很良心了, 不到200块钱买了3年的2核4G的轻量应用服务器, 香香香 😍 升级系统到Debian11 购买完就是折腾了, 因为平时打 Docker 都是用 Debian, 所以当然是用它了. 但是预装的只有 10.2, 有点老了, 所以ssh登录之后的第一件事, 当然是更新系统了 将 Debian10.2 升级到最新的稳定版 Debian11, 因为在国内, 所以去找了一下腾讯云自己的镜像, 结果发现没有11, 我果然还是喜欢 USTC 首先升级 10.2 到 10 的最新版 1apt update &amp;&amp; apt upgrade -y 再替换仓库地址到 USTC 的 11 1vim /etc/apt/sources.list 将原有的地址注释掉 (在前面加 # ), 然后粘贴新的仓库地址 1234567891011deb https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-freedeb-src https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-freedeb https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-freedeb-src https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-freedeb https://mirrors.ustc.edu.cn/debian/ bullseye-backports main contrib non-freedeb-src https://mirrors.ustc.edu.cn/debian/ bullseye-backports main contrib non-freedeb https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main contrib non-freedeb-src https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main contrib non-free 然后按 ESC :wq 保存 保存后更新系统和软件 1apt update &amp;&amp; apt full-upgrade 提示是否升级, 输入 Y 确认 升级过程其实不慢, 可能是因为屏幕滚动的很快, 有黑客帝国的感觉 之后apt会输出要更新的软件包, 此时输入 q 选择跳过 之后会出现几个选择界面, 大致上是问你需不需要更新例如ssh配置文件等到最新的版本等, 提供的默认选项也可以使用, 我们使用 回车键 确认即可, 但是因为我的服务器本身就是刚开的, 所以我每次会使用方向键来选择第一个选项 覆盖 当更新完成后, 我们需要删除更新留下的残留信息 1apt --purge autoremove 1apt autoclean 这样就大体完成了, 我需要进行最后的重启 1reboot 升级系统到Debian Testing 升级到 Debian 11 后, 我又纠结到了软件版本里, 因为我的目的是把这个服务器当作开发测试使用, 所以我需要更新的软件版本, Debian 11 的 Golang 才 1.13 , 现在正常的最新已经是 1.17.2 当然, 更新到 Testing 的前提是先更新到最新的 stable, 现在也就是 11 与升级到 11 差不多, 步骤是一样的, 只是仓库的链接更新到 Testing, 当然还是 USTC 1vim /etc/apt/sources.list 内容为 12345678deb https://mirrors.ustc.edu.cn/debian/ bookworm main contrib non-freedeb-src https://mirrors.ustc.edu.cn/debian/ bookworm main contrib non-freedeb https://mirrors.ustc.edu.cn/debian/ bookworm-updates main contrib non-freedeb-src https://mirrors.ustc.edu.cn/debian/ bookworm-updates main contrib non-freedeb https://mirrors.ustc.edu.cn/debian-security/ bookworm-security main contrib non-freedeb-src https://mirrors.ustc.edu.cn/debian-security/ bookworm-security main contrib non-free 剩下的步骤与上面的一致, 不多赘述了 安装相关的开发环境 python3 1apt install -y python3 1apt install -y python3-pip 果然 Testing 版本的 python 是 3.9.8, 比稳定版高. 而且他的更新也是很快的 golang 1apt install golang 此时的 golang 版本是 1.17.1 , 相信很快会更新出 1.17.2 rust rust不是通过 apt 进行安装, 而是根据 rust 官网的指导 安装 Rust - Rust 程序设计语言 (rust-lang.org) 执行命令 1curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 令人高兴的是, 这个脚本需要下载的资源在国内也有速度, 大概 300kb/s 左右 以后更新 rust 使用命令 1rustup update","link":"/2021/11/11/tencent_cloud/"},{"title":"浅谈双重认证","text":"什么是双重认证 两步认证是一个概念, 并不是指必须经过某种方式去实现, 而是指对于鉴权来讲, 在之前的通过账号密码的方式再加一层校验, 至于怎么加, 加的方式是什么并不是规定的, 当然, 目前国外比较通用的是使用 谷歌身份验证器/微软认证器 等来做, 国内的有使用短信的, 本文着重来说 谷歌身份验证器/微软认证器 等一些国外的认证流程, 因为他们都遵循了统一的标准(统一的算法) 为什么需要双重认证 传统的一步认证一般是账号密码, 因为账号密码是固定的, 所以如果密码泄露, 基本这个账户的一切都不再属于你, 而双重认证的原理决定了他是动态的, 是每一段时间变化一次的(一般30秒), 所以他相对来说比较安全, 如果你的密码暴露了但是二次认证生成的Code无法获取到照样无法进行操作, 所以双重认证的安全性更高 双重认证流程 一般的双重认证采用 TOTP 算法, 其算法保证了相同Key的情况下每一段时间内都可以生成同样的一个6位Code, TOTP算法资料可看 百度百科 wiki TOTP具体实现可看github 以 atlassian 为例, 来我们开启走流程开启双重认证, 当我们选择开启时 可以看到该网站提供了一个二维码给我们, 此时我们需要在手机上下载 谷歌身份验证器 app, 打开可以看到添加一个双重认证的方式有两种, 扫描二维码和手动输入, 我们来提取这个二维码的信息, 发现里面是一个链接, 类似于 1otpauth://totp/user@example.com?secret=PVKG6TZFHJUEMSK5ORYD3LI&amp;issuer=Atlassian 我们按照规则来解析, 实际上是 1otpauth://totp/认证项目名称?secret=唯一KEY&amp;issuer=签发者 需要注意的是, 我们每次重新申请开启双重认证时出现的二维码解析出的Key都是变化的 当我们使用 谷歌身份验证器 扫描后, 会出现一条新的记录 你也可以按照此规则编出来一个链接通过生成二维码的小工具让软件扫扫看 我们还原此过程, 当app扫到码之后, 获取到项目名称和Key与签发者, 按照TOTP算法生成6位Code, 展示出来, Code是30s一变, 但是注意, 此时网站与App并无联系, App也并不负责对Key等信息校验真实性 而我们需要将生成的Code输入进网站的下方验证码这里, 通过后才会与App建立绑定关系(网站端单纯的建立逻辑的绑定关系) 还原此过程, 网站端并不知道App有没有生成, 但是因为App都遵循统一的 TOTP 算法, 因此网站端也可以生成当时的正确Code, 当我们提交的Code与网站端生成的Code相符时, 即网站将该Key绑定(也就是图上说的 连接后，我们会记住您的手机，以便您每次登录时都可以使用。), 绑定后, 网站对这个通过的Key进行记录, 每次需要验证时网站根据Key生成Code, 与用户提交的Code比对, 通过即可 通过上述流程, 我们可以发现, 实际上App端只掌握了一个Key, 但是App本身并不知道Key是否是正确的, 他们两个实际上永远没有交流, 这样就很安全 经测试, 网站一般会只允许一个Key存活, 也就是当我们重新申请一个Key, 原先的Key则失效, 当然对于App是不知道的, 但是当我们提交认证时网站就会报错.","link":"/2021/09/04/two_auth/"},{"title":"uber go code 规范(性能)","text":"前言 从接触 Golang 到现在, 感觉到的很深的一点是, go 的代码无论是大佬还是菜鸟写出的代码, 都有着大体统一的 格式/流程, 这也是 Go 被开发者喜爱的一个原因, 但是还有一些, 比如变量的命名方式等, 可以称之为 风格 的东西, 却不尽相同, 我在开发中, 其实也希望有一个相对权威的指导意见, 后来就找到了 uber 团队出品的开发规范. uber 是众多公司中, 比较早使用 go 语言的了, 其本身也开源了一些优质的模块, 有机会的话希望也能向大家展示一下, 而在 uber 内部开发中, 经过持续的迭代, 开源了自己的代码规范, 这里给大家解读一下 需要特别指出的是, 下面的内容并不是一定需要遵守, 这里你可以选择自己认为正确的可行的规范. 团队内使用统一的风格, 可以提高代码的可读性 本篇记录性能部分, 旨在特定情况下提高程序的性能 优先使用 strconv 而不是 fmt 将 int 转换成 string 时, 使用 strconv 的方法比 fmt 的速度更快 错误的 12345678910111213141516package mainimport ( \"fmt\" \"strconv\" \"time\")func main() { start := time.Now() for i := 0; i &lt; 10000; i++ { fmt.Sprintln(i) } fmt.Println(time.Now().Sub(start))} 查看耗时 12➜ test go run main.go872.779µs 正确的 123456789101112131415package mainimport ( \"fmt\" \"strconv\" \"time\")func main() { start := time.Now() for i := 0; i &lt; 10000; i++ { strconv.Itoa(i) } fmt.Println(time.Now().Sub(start))} 查看耗时 12➜ test go run main.go233.211µs 避免字符串转换成字节 不要频繁的从固定字符串转换成字节, 而是只创建一次并将结果保存, 反复使用 错误的 123456789101112131415package mainimport ( \"fmt\" \"time\")func main() { start := time.Now() for i := 0; i &lt; b.N; i++ { w.Write([]byte(\"Hello world\")) } fmt.Println(time.Now().Sub(start))} 正确的 12345678910111213141516package mainimport ( \"fmt\" \"time\")func main() { start := time.Now() data := []byte(\"Hello world\") for i := 0; i &lt; b.N; i++ { w.Write(data) } fmt.Println(time.Now().Sub(start))} 初始化 Map 和切片时预估长度 在初始化 map 和切片时, 就指定其长度, 防止 go 进行动态扩容 map 使用 make 进行初始化时提供容量信息 1make(map[T]T, len) 这可能会减少动态扩容的次数, 因为 go 的 map 容量不是一定准确判断, 所以只是可能减少 错误的 123456m := make(map[string]os.FileInfo)files, _ := ioutil.ReadDir(\"./files\")for _, f := range files { m[f.Name()] = f} 正确的 1234567files, _ := ioutil.ReadDir(\"./files\")m := make(map[string]os.FileInfo, len(files)) // 直接指定长度for _, f := range files { m[f.Name()] = f} 指定切片容量 在创建切片时, 尽可能的提供容量信息 1make([]T, length, capacity) go 对切片的处理, 当切片长度够用时, 一定不会出现分配操作, 节省时间 错误的 123456for n := 0; n &lt; b.N; n++ { data := make([]int, 0) // 长度为0 for k := 0; k &lt; size; k++{ data = append(data, k) // 长度不够时进行扩容 }} 正确的 123456for n := 0; n &lt; b.N; n++ { data := make([]int, 0, size) // 指定 size for k := 0; k &lt; size; k++{ data = append(data, k) // 永远不会扩容 }}","link":"/2022/04/18/uber_guide_performance/"},{"title":"uber go code 规范(指导原则)","text":"前言 从接触 Golang 到现在, 感觉到的很深的一点是, go 的代码无论是大佬还是菜鸟写出的代码, 都有着大体统一的 格式/流程, 这也是 Go 被开发者喜爱的一个原因, 但是还有一些, 比如变量的命名方式等, 可以称之为 风格 的东西, 却不尽相同, 我在开发中, 其实也希望有一个相对权威的指导意见, 后来就找到了 uber 团队出品的开发规范. uber 是众多公司中, 比较早使用 go 语言的了, 其本身也开源了一些优质的模块, 有机会的话希望也能向大家展示一下, 而在 uber 内部开发中, 经过持续的迭代, 开源了自己的代码规范, 这里给大家解读一下 需要特别指出的是, 下面的内容并不是一定需要遵守, 这里你可以选择自己认为正确的可行的规范. 团队内使用统一的风格, 可以提高代码的可读性 本篇记录原则部分 原则 原则部分, 在 uber 内部是必须遵守的, 其目的是提高代码的健壮性, 让一些可能的错误能在编写时就暴露出来 结构体中包含接口指针 接口可以包含任何类型的值, 但是, 将结构体的某个值的类型设置为接口的指针则会出现问题, 例如: 1234567891011121314151617package maintype Brace interface{} // 空接口type Round struct { // 结构体 prev Brace // 值 prev 的类型为接口值 prev_ *Brace // 值 prev_ 的类型为接口指针}type Square struct{} // 空结构体func main() { var r Round var s Square r.prev = s // OK: 这里 ok r.prev_ = &amp;s // ERR: 想要将 s 的指针赋值给 prev_, 会报错} 开发者很少需要在结构体中设置某个值的类型为接口的指针, 而应该将接口作为值进行传递, 类似于上面的 prev, 如果你真的需要将接口指针设置为结构体的某个值, 也不需要将其类型设置为指针, 例如: 1234567891011121314151617package maintype Brace interface{} // 空接口type Round struct { // 结构体 prev Brace // 值 prev 的类型为接口值 prev_ Brace // 值 prev_ 的类型为接口值}type Square struct{} // 空结构体func main() { var r Round var s Square r.prev = s // OK: 这里 ok r.prev_ = &amp;s // OK: 想要将 s 的指针赋值给 prev_, 可以赋值} 而一般情况下, 我们对结构体的方法的结构体部分传参, 大多数都是结构体的指针()指针方法, 此时可以使用结构体指针赋值给接口的方式, 例如: 1234567891011121314package maintype Brace interface { Length()}type Round struct { // 结构体}func (r *Round) Length() {}func main() { b := []Brace{&amp;Round{}} // OK: *Round 实现了 Brace 接口, 而不是 Round} interface 合理性验证 对于接口的实现, 在我们编写代码时, 可能会因为种种原因没有实现好对应接口, 而这个错误只有在真正调用时才会被发现, 例如: 1234567891011121314package maintype Brace interface { Length()}type Round struct { // 结构体}func (r *Round) Long() {}func main() { _ = []Brace{&amp;Round{}} // ERR: 这里会报错, 因为 &amp;Round 没有实现 Brace} 所以, 我们可以在编写时使用一个无用的空值, 来让编译器帮助我们判断是否实现了接口, 例如: 1234567891011121314151617package maintype Brace interface { Length()}type Round struct { // 结构体}var _ Brace = &amp;Round{} // OK: 利用 var 一个无用的值, 让编译器检测 &amp;Round 是否实现了 Brace 接口func (r *Round) Long() {}func (r *Round) Length() {}func main() {} 接收器与接口 对于结构体的值来讲, 结构体的指针方法与值方法不能一起调用, 例如: 1234567891011121314151617181920212223package maintype S struct { data string}func (s S) Read() string { // 值方法 return s.data}func (s *S) Write(str string) { // 指针方法 s.data = str}func main() { sVals := map[int]S{1: {data: \"A\"}} // OK: 你只能通过值调用 Read sVals[1].Read() // ERR: 这里会出现问题, 因为方法为指针方法 sVals[1].Write(\"test\")} 而对于结构体的指针来讲, 可以调用值方法和指针方法, 例如: 123456789101112131415161718192021package maintype S struct { data string}func (s S) Read() string { // 值方法 return s.data}func (s *S) Write(str string) { // 指针方法 s.data = str}func main() { sPtrs := map[int]*S{1: {data: \"A\"}} // 存储结构体的指针 // OK: 通过指针既可以调用 Read(值方法)，也可以调用 Write 方法(指针方法) sPtrs[1].Read() sPtrs[1].Write(\"test\")} 同样的道理, 对于接口来讲, 也可以使用指针接收器来实现接口 12345678910111213141516171819202122232425262728package maintype F interface { f()}type S1 struct{}func (s S1) f() {} // 值方法type S2 struct{}func (s *S2) f() {} // 指针方法func main() { s1Val := S1{} // 结构体值 s1Ptr := &amp;S1{} // 结构体指针 s2Val := S2{} // 结构体值 s2Ptr := &amp;S2{} // 结构体指针 var i F // 接口 i = s1Val // OK: S1的值实现了值方法 i = s1Ptr // OK: S1的指针实现了值方法 i = s2Ptr // OK: S2的指针实现了指针方法 // ERR: 不行, 因为S2是指针方法 i = s2Val} 零值 Mutex 对于sync 的锁包, sync.Mutex和sync.RWMuntex, 他的零值也是有效的, 不需要通过new关键字来生成指针 123456789101112package mainimport \"sync\"func main() { mu := new(sync.Mutex) // ERR: 生成 Mutex 的指针, 多此一举 mu.Lock() var mu1 sync.Mutex // OK: Mutex 的零值也可以正常使用, 正确的用法 mu1.Lock()} 如果将 Mutex 作为结构体中的一部分, 那么其应该作为值类型, 而不是指针类型. 并且, 结构体的 Mutex 应该由包内部控制, 不要被外部修改, 所以不要把 mutex 直接嵌入到结构体中(匿名字段的方式Go 编程语言规范 - Go 编程语言). 错误示例: 12345678910111213141516171819202122package mainimport \"sync\"type SMap struct { sync.Mutex // 没有 key, 在 struct 中视为匿名字段和提升字段, 提升字段会导致暴露方法给外部调用者 data map[string]string}func NewSMap() *SMap { return &amp;SMap{ // 因为 Mutex 零值直接可以使用, 所以初始化时不需要初始化 Mutex data: make(map[string]string), }}func (m *SMap) Get(k string) string { m.Lock() defer m.Unlock() return m.data[k]} 正确示例: 12345678910111213141516171819202122package mainimport \"sync\"type SMap struct { mu sync.Mutex // 设置为普通字段, 设置为私有的, 防止外部调用, 只能让模块内部调用 data map[string]string}func NewSMap() *SMap { return &amp;SMap{ // 因为 Mutex 零值直接可以使用, 所以初始化时不需要初始化 Mutex data: make(map[string]string), }}func (m *SMap) Get(k string) string { m.mu.Lock() defer m.mu.Unlock() return m.data[k]} 拷贝 Slices 和 Maps Slices 和 Maps 内部保存的事指向底层数据的指针, 因此涉及到他们的复制时, 需要特别的注意 将 Slices 作为函数参数和返回值 当 map 和 slice 作为函数参数使用时, 如果存储了他们的引用, 则外部对他的修改, 也会造成内部的数据错乱 123456789101112131415161718192021222324252627282930package mainimport \"fmt\"type Driver struct { trips []int}func (d *Driver) SetTrips(trips []int) { // 直接将slice存储进自身 d.trips = trips // ERR: 存在外部修改可能}func (d *Driver) GetTrips() []int { // 直接返回 slice return d.trips // ERR: 存在外部修改可能}func main() { d := Driver{} gt := []int{0, 1, 2, 3} d.SetTrips(gt) fmt.Println(d.GetTrips()) // [0 1 2 3] gt[0] = 5 // ERR: 在外部修改了 Driver 的数据, 这是你想要的吗? fmt.Println(d.GetTrips()) // [5 1 2 3] rgt := d.GetTrips() // 获取内部的 slice rgt[0] = 6 // ERR: 在外部修改了 Driver 的数据, 这是你想要的吗? fmt.Println(d.GetTrips()) // [6 1 2 3]} 我们可以借用copy函数, 进行 copy, 防止引用出现 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"type Driver struct { trips []int}func (d *Driver) SetTrips(trips []int) { d.trips = make([]int, len(trips)) // 创建长度为参数长度的新切片 copy(d.trips, trips) // OK: 使用 copy, 复制值而不是直接引用}func (d *Driver) GetTrips() []int { res := make([]int, len(d.trips)) // 创建长度为参数长度的新切片 copy(res, d.trips) // 使用 copy, 复制内部值而不是直接返回内部引用 return res // OK: 外部修改不会影响内部}func main() { d := Driver{} gt := []int{0, 1, 2, 3} d.SetTrips(gt) fmt.Println(d.GetTrips()) // [0 1 2 3] gt[0] = 5 // OK: 在外部修改了 Driver 的数据, 不影响内部 fmt.Println(d.GetTrips()) // [0 1 2 3] rgt := d.GetTrips() // 获取内部的 slice rgt[0] = 6 // OK: 在外部修改了 Driver 的数据, 不影响内部 fmt.Println(d.GetTrips()) // [0 1 2 3]} 将 map 作为函数参数和返回值 同样的, map 也有这个问题 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"type Driver struct { trips map[string]int}func (d *Driver) SetTrips(trips map[string]int) { // 直接将 map 存储进自身 d.trips = trips // ERR: 存在外部修改可能}func (d *Driver) GetTrips() map[string]int { // 直接返回 map return d.trips // ERR: 存在外部修改可能}func main() { d := Driver{} gt := make(map[string]int) gt[\"0\"] = 0 gt[\"1\"] = 1 d.SetTrips(gt) fmt.Println(d.GetTrips()) // map[0:0 1:1] gt[\"0\"] = 5 // ERR: 在外部修改了 Driver 的数据, 这是你想要的吗? fmt.Println(d.GetTrips()) // map[0:5 1:1] rgt := d.GetTrips() // 获取内部的 map rgt[\"0\"] = 6 // ERR: 在外部修改了 Driver 的数据, 这是你想要的吗? fmt.Println(d.GetTrips()) // map[0:6 1:1]} 对于 map, 没有内置的 copy 函数, 我们可以手动赋值达到效果 123456789101112131415161718192021222324252627282930313233343536package mainimport \"fmt\"type Driver struct { trips map[string]int}func (d *Driver) SetTrips(trips map[string]int) { d.trips = make(map[string]int, len(trips)) // make for k, v := range trips { // 使用循环来赋值 d.trips[k] = v }}func (d *Driver) GetTrips() map[string]int { res := make(map[string]int, len(d.trips)) for k, v := range d.trips { res[k] = v } return res}func main() { d := Driver{} gt := make(map[string]int) gt[\"0\"] = 0 gt[\"1\"] = 1 d.SetTrips(gt) fmt.Println(d.GetTrips()) // map[0:0 1:1] gt[\"0\"] = 5 // OK: 在外部修改了 Driver 的数据, 这是你想要的吗? fmt.Println(d.GetTrips()) // map[0:0 1:1] rgt := d.GetTrips() // 获取内部的 map rgt[\"0\"] = 6 // OK: 在外部修改了 Driver 的数据, 这是你想要的吗? fmt.Println(d.GetTrips()) // map[0:0 1:1]} 使用 defer 释放资源 defer 在函数返回之前执行, 所以我们可以利用 defer 进行资源的释放 错误示例 123456789101112package mainimport \"sync\"func test(count int) int { mu := sync.Mutex{} mu.Lock() count++ mu.Unlock() // ERR: 手动关闭, 很容易遗忘, 且针对多个分支处理, 容易遗忘 // 当有多个 return 分支时，很容易遗忘 unlock return 1} 正确示例 1234567891011package mainimport \"sync\"func test(count int) int { mu := sync.Mutex{} mu.Lock() defer mu.Unlock() // OK: 注册 defer, 后续无需操心解锁时机 count++ return 1} defer 对于程序的开销非常小, 只有确定真的对函数的执行时间控制为纳秒单位时, 才不使用 defer. 普通情况下, 使用 defer 来保持代码整洁性是十分推荐的. channel 的 size 设置为无缓冲或者1 channel 的 size 通常是1或者是无缓冲的, 默认情况下, channel 应该是无缓冲的, 因为 channel 的大小是无法改变的, 所以一般我们尽可能的希望其中不要存储数据, 只作为传输. 可以设置为 1 做一个最小的冗余, 而设置为其他大小时, 必须要考虑是什么让你必须选择有其他缓冲长度的通道? 是否可以通过别的方式解决? 错误示例 12345package mainfunc test(count int) { c := make(chan int, 1024) // ERR: 为什么要这样做?} 正确示例 123456package mainfunc test(count int) { c := make(chan int, 1) // OK: 只设置1个冗余 c1 := make(chan int) // OK: 无缓冲} 枚举从 1 开始 go 中使用枚举的方式是声明一个自定义的类型和一个iota的const组, 因为变量默认值为0, 因此枚举的一组通常以0值开始, 但是有时候, 0 有着特殊的意义, 比如 int 的默认值就为0, 因此将枚举设置为1开始可以防止可能出现的错误值进行枚举 错误示例 123456789101112131415161718192021222324252627282930313233package mainimport \"fmt\"type Operation int // int 类型枚举const ( Add Operation = iota Subtract Multiply)// Add=0, Subtract=1, Multiply=2func (o Operation) ToString() string { res := \"\" switch o { case Add: res = \"Add\" case Subtract: res = \"Subtract\" case Multiply: res = \"Multiply\" } return res}func main() { var o Operation // 默认为0 // 这里因为遗漏, 没有正确的对 o 进行赋值 fmt.Println(o.ToString()) // ERR: 解出来却是 Add, 只是因为int 默认为0} 正确示例 从1开始 123456789101112131415161718192021222324252627282930313233package mainimport \"fmt\"type Operation int // int 类型枚举const ( Add Operation = iota + 1 Subtract Multiply)// Add=1, Subtract=2, Multiply=3func (o Operation) ToString() string { res := \"\" switch o { case Add: res = \"Add\" case Subtract: res = \"Subtract\" case Multiply: res = \"Multiply\" } return res}func main() { var o Operation // 默认为0 // 这里因为遗漏, 没有正确的对 o 进行赋值 fmt.Println(o.ToString()) // OK: 解出来是空, 代表错误了, 避免了 o 是默认值而错误的找到了枚举} 使用 time 类型处理时间 time package - time - pkg.go.dev 时间的处理与计算总是复杂的, 在开发者的认知中, 可能存在以下错误: 一天总有24小时 地球上的一天有多长？ (timeanddate.com) 一年总有365天 年份 - 维基百科，自由的百科全书 (wikipedia.org) 更多-&gt;程序员相信时间的谬误 不要试图自己实现时间的计算逻辑, 时间的计算实际上是很复杂的, 而 golang 内置的 time 包已经提供了很丰富的方法, 而且可以保证准确性. 使用time.Time表示某个瞬间时间 使用time.Time类型表示某一刻的时间, 在 时间比较/计算 时使用内置的方法 错误示例 1234// 判断时间是否在某个时间段内func isActive(now, start, stop int) bool { return start &lt;= now &amp;&amp; now &lt; stop} 正确示例 1234567// 判断时间是否在某个时间段内func isActive(now, start, stop time.Time) bool { // time.Time 类型 // start.Before(now) 判断 start 是否在 now 之前 // start.Equal(now) 判断 now 是否与 start 相同 // now.Before(stop) 判断 now 是否在 stop 之前 return (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)} 使用time.Duration表达时间段 使用time.Duration来表达某个时间段, 而不是其他数据类型 错误示例 123456789101112131415package mainimport \"time\"func poll(delay int) { for { // sleep delay 毫秒 time.Sleep(time.Duration(delay) * time.Millisecond) }}func main() { poll(10) // 调用者只能通过注释和查看源代码来确认参数 delay 代表毫秒还是秒} 正确示例 123456789101112131415package mainimport \"time\"func poll(delay time.Duration) { for { // ... time.Sleep(delay) }}func main() { poll(10 * time.Second) // 调用者自己决定 sleep 多久} 时间加减 时间的加减一定不要自己实现, 需要考虑的情况太多了 对于日期的加减, 我们可以使用 time.Time的AddDate方法, 而对于时间的加减, 使用Time.Add 正确示例 1234567891011121314151617181920package mainimport ( \"fmt\" \"time\")func main() { t := time.Now() // 获取当前时间 fmt.Println(t) newDay := t.AddDate(0 /* years */, 1 /* months */, 1 /* days */) // +1月+1天 fmt.Println(newDay) newDay1 := t.AddDate(0 /* years */, -1 /* months */, 1 /* days */) // +1月-1天 fmt.Println(newDay1) maybeNewDay := t.Add(24 * time.Hour) // +24h fmt.Println(maybeNewDay) maybeNewDay1 := t.Add(-24 * time.Second) // -24s fmt.Println(maybeNewDay1)} 输出结果: 123452022-05-17 16:27:33.394981 +0800 CST m=+0.0000591142022-06-18 16:27:33.394981 +0800 CST2022-04-18 16:27:33.394981 +0800 CST2022-05-18 16:27:33.394981 +0800 CST m=+86400.0000591142022-05-17 16:27:09.394981 +0800 CST m=-23.999940886 在对外部的系统中使用time.Time和time.Duration 尽可能的在与外部系统的交互中使用time.Time和time.Duration, 例如: Command-line 标志:&nbsp;flag&nbsp;通过&nbsp;time.ParseDuration&nbsp;支持&nbsp;time.Duration JSON:&nbsp;encoding/json&nbsp;通过其&nbsp;UnmarshalJSON&nbsp;method&nbsp;方法支持将&nbsp;time.Time&nbsp;编码为&nbsp;RFC 3339&nbsp;字符串 SQL:&nbsp;database/sql&nbsp;支持将&nbsp;DATETIME&nbsp;或&nbsp;TIMESTAMP&nbsp;列转换为&nbsp;time.Time，如果底层驱动程序支持则返回 YAML:&nbsp;gopkg.in/yaml.v2&nbsp;支持将&nbsp;time.Time&nbsp;作为&nbsp;RFC 3339&nbsp;字符串，并通过&nbsp;time.ParseDuration&nbsp;支持&nbsp;time.Duration 对于time.Time, 其他语言一般也都会支持解析, 因为他是统一的标准, 而对于time.Duration, 如果不支持, 请使用int或者float64, 并且在字段名称中包含单位. 例如, json不支持time.Duration, 因此使用int替代, 并且将单位包含在名称中, 提高可读性 错误示例 12345678910111213141516171819202122232425package mainimport ( \"encoding/json\" \"log\" \"time\")type Task struct { StartTime time.Time `json:\"start_time\"` Timeout int `json:\"timeout\"` // 这里是秒还是毫秒?}func main() { t := Task{ StartTime: time.Now(), Timeout: int((time.Second * 30).Seconds()), } s, err := json.Marshal(t) if err != nil { log.Fatalln(err) } log.Println(string(s))} 12022/05/17 17:05:42 {\"start_time\":\"2022-05-17T17:05:42.356961+08:00\",\"timeout\":30} 正确示例 12345678910111213141516171819202122232425package mainimport ( \"encoding/json\" \"log\" \"time\")type Task struct { StartTime time.Time `json:\"start_time\"` TimeoutSecond int `json:\"timeout_second\"` // 字段名就可以明白是秒}func main() { t := Task{ StartTime: time.Now(), TimeoutSecond: int((time.Second * 30).Seconds()), } s, err := json.Marshal(t) if err != nil { log.Fatalln(err) } log.Println(string(s))} 12022/05/17 17:07:26 {\"start_time\":\"2022-05-17T17:07:26.147585+08:00\",\"timeout_second\":30} 当在这些交互中不能使用&nbsp;time.Time&nbsp;时, 除非达成一致, 否则使用&nbsp;string&nbsp;和&nbsp;RFC 3339&nbsp;中定义的格式时间戳. 默认情况下, Time.UnmarshalText&nbsp;使用此格式, 并可通过&nbsp;time.RFC3339&nbsp;在&nbsp;Time.Format&nbsp;和&nbsp;time.Parse&nbsp;中使用 需要注意的是, \"time\"&nbsp;包不支持解析闰秒时间戳8728, 也不在计算中考虑闰秒15190, 如果比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。 Errors 对于 error 的使用, 有几种方式, 有各自的优缺点, 在选择之前, 先考虑具体的情况: 对于调用者, 是否需要匹配错误信息以便处理? 如果需要, 则必须通过声明顶级的错误变量或者自定义类型来支持errors.Is或errors.As函数 错误消息是静态的字符串, 还是存储有上下文信息的动态字符串? 如果是静态字符串, 可以使用errors.New, 如果是动态, 必须使用fmt.Errorf或者自定义的错误类型 错误是否是我们的下游返回的错误? 如果是, 参阅之后的错误包装部分 是否需要错误匹配 错误类型 使用 NO 静态 errors.New NO 动态 fmt.Errorf YES 静态 errors.New 或者自定义顶级错误 YES 动态 自定义错误类型 不需要错误匹配的静态错误 1234567891011121314151617package mainimport \"errors\"// 假设这是你写的一个包func Open() error { return errors.New(\"could not open\") // new 一个静态的错误返回}func main() { // 假设这是调用者 if err := Open(); err != nil { panic(\"unknown error\") }} 不需要错误匹配的动态错误 1234567891011121314151617181920package mainimport ( \"fmt\")// 假设这是你写的一个包func Open(file string) error { return fmt.Errorf(\"file %q not found\", file) // 返回 format 后的错误}func main() { // 假设这是调用者 if err := Open(\"demo.txt\"); err != nil { // Can't handle the error. panic(\"unknown error\") }} 需要错误匹配的静态错误 1234567891011121314151617181920212223package mainimport \"errors\"// 假设这是你写的一个包var ErrCouldNotOpen = errors.New(\"could not open\") // 定义一个静态错误类型, 需要是可以导出的func Open() error { return ErrCouldNotOpen // 返回指定的错误类型}func main() { // 假设这是调用者 if err := Open(); err != nil { if errors.Is(err, ErrCouldNotOpen) { // errors.Is 判断错误是否是指定的错误类型 // handle the error } else { panic(\"unknown error\") } }} 需要错误匹配的动态错误 123456789101112131415161718192021222324252627282930313233package mainimport ( \"errors\" \"fmt\")// 假设这是你写的一个包type NotFoundError struct { // 定义一个结构体, 为错误使用, 需要设置为外部可使用 File string // 动态部分}func (e *NotFoundError) Error() string { // error 方法, 传出 format 后的错误信息 return fmt.Sprintf(\"file %q not found\", e.File) // 动态信息 format}func Open(file string) error { return &amp;NotFoundError{File: file} // return时发现是 error类型, 会自动调 Error 方法}func main() { // 假设这是调用者 if err := Open(\"demo.txt\"); err != nil { var notFound *NotFoundError if errors.As(err, &amp;notFound) { // errors.As 判断错误是否是这个结构体的方法 // handle the error } else { panic(\"unknown error\") } }} 错误包装 当这个错误是我们的下游返回的错误, 我们需要将错误返回给更上级时, 我们有三种选择: 按照原样返回错误 使用 fmt.Errorf 搭配 %w 将错误添加进上下文后返回 使用 fmt.Errorf 搭配 %v 将错误添加进上下文后返回 如果你没有需要添加的其他上下文, 则直接原样返回错误即可, 这样保留了原始错误类型和消息, 适合上游进行错误追踪, 非常适合底层的错误 否则, 则需要尽可能的在错误消息里添加上下文, 这样可以防止模糊的错误信息, 比如connection refused之类的, 他应该是更详细的, 例如call service foo: connection refused 此时你需要使用fmt.Errorf来生成一个包含上下文的错误, 那么如何选择%w和%v? 如果调用者可以访问底层的错误, 使用%w, %w可以在传递之后, 外部的调用者依旧可以使用errors.Is来进行错误的匹配, 更多情况下, %w更推荐使用 %v会将下游错误进行混淆,导致上游无法进行错误匹配, 如果可以修改, 将他切换到%w 在生成错误信息时, 记得避免加上failed to 之类的描述来保证错误信息的简洁, 因为他在返回时, 就已经默认是错误信息, 不需要特别的指出, 另外当错误通过堆栈一层层向上返回时, 加入过多的描述会导致错误信息错乱不堪, 无法辨认 %v导致的错误示例: 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"errors\" \"fmt\")// 假设这是最下游的一个包var ErrCouldNotOpen = errors.New(\"could not open\") // 定义一个静态错误类型, 需要是可以导出的func Open() error { return ErrCouldNotOpen // 返回指定的错误类型}// 这是中层的包func Demo() error { if err := Open(); err != nil { return fmt.Errorf(\"open: %v\", err) // 返回给上层, %v 将错误信息覆盖 } return nil}func main() { // 假设这是调用者 if err := Demo(); err != nil { if errors.Is(err, ErrCouldNotOpen) { // errors.Is 判断错误是否是指定的错误类型, %v 覆盖了错误类型, 导致判断失败, Panic // handle the error } else { panic(\"unknown error\") } }} 正确示例 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"errors\" \"fmt\")// 假设这是最下游的一个包var ErrCouldNotOpen = errors.New(\"could not open\") // 定义一个静态错误类型, 需要是可以导出的func Open() error { return ErrCouldNotOpen // 返回指定的错误类型}// 这是中层的包func Demo() error { if err := Open(); err != nil { // 加入的上下文只有 open: 让调用者知道是 open 时的错误即可 return fmt.Errorf(\"open: %w\", err) // 返回给上层, %v 将错误信息带入返回 } return nil}func main() { // 假设这是调用者 if err := Demo(); err != nil { if errors.Is(err, ErrCouldNotOpen) { // errors.Is 判断错误是否是指定的错误类型, 判断成功 // handle the error } else { panic(\"unknown error\") } }} 需要注意的是, 如果错误信息需要传送到另一个系统, 例如日志收集, 就需要明确告诉这是个错误信息 另外, 遇到错误, 不要选择忽略他不要只是检查错误，而是优雅地处理它们|戴夫·切尼 (cheney.net) // TODO, 这里有空翻译一下 错误命名 对于存储为全局变量的错误类型, 根据是否需要导出, 统一加入前缀Err或者err 123456789101112var ( // 导出以下两个错误，以便此包的用户可以将它们与 errors.Is 进行匹配。 // 统一使用 Err 作为前缀 ErrBrokenLink = errors.New(\"link is broken\") ErrCouldNotOpen = errors.New(\"could not open\") // 这个错误没有被导出，因为我们不想让它成为我们公共 API 的一部分。 我们可能仍然在带有错误的包内使用它。 // 统一使用 err 作为前缀 errNotFound = errors.New(\"not found\")) 对于自定义的错误类型, 统一加入后缀Error 12345678910111213141516171819// 同样，这个错误被导出，以便这个包的用户可以将它与 errors.As 匹配。type NotFoundError struct { File string}func (e *NotFoundError) Error() string { return fmt.Sprintf(\"file %q not found\", e.File)}// 并且这个错误没有被导出，因为我们不想让它成为公共 API 的一部分。 我们仍然可以在带有 errors.As 的包中使用它。type resolveError struct { Path string}func (e *resolveError) Error() string { return fmt.Sprintf(\"resolve %q\", e.Path)} 断言处理失败 go 的类型断言会在失败时, 以单一返回值形式返回 panic, 因此, 使用 , ok 方式防止 panic 错误示例 1234567891011package mainimport \"fmt\"func main() { var s interface{} s = 1 t := s.(string) // panic fmt.Println(t)} 正确示例 1234567891011121314151617package mainimport ( \"fmt\" \"log\")func main() { var s interface{} s = 1 t, ok := s.(string) // !ok, 不会 panic if !ok { log.Fatalln(\"error\") } fmt.Println(t)} 不要使用 panic 在生产环境运行的代码必须避免出现 panic, panic 会导致整个程序崩溃, 如果发生错误, 函数必须捕捉并返回错误, 让调用方来进行处理 错误示例 12345678910func run(args []string) { if len(args) == 0 { panic(\"an argument is required\") // panic, 程序崩溃 } // ...}func main() { run(os.Args[1:])} 正确示例 1234567891011121314func run(args []string) error { if len(args) == 0 { return errors.New(\"an argument is required\") // 不符合预期的逻辑, 捕捉以 error 方式返回, 而不是 panic } // ... return nil}func main() { if err := run(os.Args[1:]); err != nil { // 调用方处理错误 fmt.Fprintln(os.Stderr, err) os.Exit(1) }} panic/recover不是经常使用的错误处理策略, 仅仅在发生不可恢复的事情(比如空指针)时才 panic, 有一个例外: 程序的初始化时发生某些致命错误可能会 panic(比如数据库连接解析错误) 即使在测试代码中, 也不要使用 panic, 应该使用t.Fatal或者t.FailNow来确保失败被标记 错误示例 123456// func TestFoo(t *testing.T)f, err := ioutil.TempFile(\"\", \"test\")if err != nil { panic(\"failed to set up test\")} 正确示例 123456// func TestFoo(t *testing.T)f, err := ioutil.TempFile(\"\", \"test\")if err != nil { t.Fatal(\"failed to set up test\")} 使用 go.uber.org/atomic go 语言内置了一部分原始数据类型的原子操作功能, 实现在包 &nbsp;sync/atomic 中, 原子操作可以防止资源竞争导致可能出现的错误, 但是开发者很容易忘记使用这些原子操作. go.uber.org/atomic&nbsp;通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的atomic.Bool类型 避免可变的全局变量 在初始化完成后, 应该尽量避免改变全局变量, 这样会导致可能会出现的, 其他地方修改这个全局变量, 从而发生预期值外的错误. 正确示例 12345678910111213141516171819// sign.govar _timeNow = time.Now // 设置一个全局变量func sign(msg string) string { now := _timeNow() // 函数中使用这个全局变量 return signWithTime(msg, now)}// main.gofunc Sign(t *testing.T) { oldTimeNow := _timeNow _timeNow = func() time.Time { // 覆盖了全局变量 // 此时其他地方调用 sign 会导致出现问题 return someFixedTime } defer func() { _timeNow = oldTimeNow }()} 错误示例 1234567891011121314151617181920212223242526272829// sign.go// 设定结构体, 将原本的全局变量设置为结构体的某一个字段type signer struct { now func() time.Time}func newSigner() *signer { // 新建一个新的 singer, 而不是全局变量, 是这个对象私有的属性 return &amp;signer{ now: time.Now, }}func (s *signer) Sign(msg string) string { // 调用时, 只使用自己的私有的属性 now := s.now() return signWithTime(msg, now)}// main.gofunc Signer(t *testing.T) { s := newSigner() // 创建一个新的 singer s.now = func() time.Time { // 对属性进行修改, 不影响其他使用 return someFixedTime }} 避免在公共结构中嵌入类型 直接在公共结构体中嵌入类型会导致这个类型的实现细节暴露出去, 导致分层失败, 同时还会对以后可能的迭代产生阻碍, 同时不利于文档的编写 假设有一个结构体 AbstractList, 实现了Add和Remove方法 123456789101112131415type AbstractList struct{}func (l *AbstractList) Add(s string) { // ...}func (l *AbstractList) Remove(s string) { // ...}func (l *AbstractList) Clean() { // ...} 当开发者需要在上游的结构体中使用该类型时, 注意不要直接嵌入这个类型, 例如 错误示例 12345678910111213141516171819202122232425262728293031package maintype AbstractList struct{}func (l *AbstractList) Add(s string) { // ...}func (l *AbstractList) Remove(s string) { // ...}func (l *AbstractList) Clean() { // ...}// ConcreteList 是一个实体列表。// ConcreteList 是公开的结构体type ConcreteList struct { *AbstractList // 直接嵌入类型}func main(){ c := ConcreteList{} c.Add(\"1\") // 外部可以直接调用 *AbstractList 的方法, 导致分层失败 c.Remove(\"1\") c.Clean()} 正确示例 正确的做法应该是作为结构体的某一个字段使用 123456789101112131415161718192021222324252627282930313233343536373839404142package maintype AbstractList struct{}func (l *AbstractList) Add(s string) { // ...}func (l *AbstractList) Remove(s string) { // ...}func (l *AbstractList) Clean() { // ...}// ConcreteList 是一个实体列表。// ConcreteList 是公开的结构体type ConcreteList struct { list *AbstractList // 直接嵌入类型}// 分层func (l *ConcreteList) Add(s string) { // 做一些其他事情, 例如校验 l.list.Add(s)}// 分层func (l *ConcreteList) Remove(s string) { // 做一些其他事情, 例如校验 l.list.Remove(s)}func main() { c := ConcreteList{} c.Add(\"1\") // 调用的是 *ConcreteList 本身的方法 c.Remove(\"1\") c.Clean() // 调用失败, 因为我不希望你使用} 分层可以为之后可能出现的其他逻辑留下空间, 避免之后新的需求到来之时对现有的代码进行结构上的破坏性改动, 同时也可以避免将某些其他的方法暴露出来 即使AbstractList是接口, 也应该保持同样的做法, 道理是一样的 避免使用内置的名称 Go&nbsp;语言规范&nbsp;概述了几个内置的， 不应在 Go 项目中使用的&nbsp;预先声明的标识符。 根据上下文的不同，将这些标识符作为名称重复使用， 将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。 在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。 错误示例 1234567891011121314151617181920212223var error string // 覆盖了 error// `error` 本身的作用域隐式覆盖// 在函数里 error 也被覆盖func handleErrorMessage(error string) { // `error` 作用域隐式覆盖}type Foo struct { // 虽然这些字段在技术上不构成隐式覆盖，但`error`或`string`字符串在使用中可能会出现覆盖 error error string string}func (f Foo) Error() error { // `error` 和 `f.error` 在视觉上是相似的 return f.error}func (f Foo) String() string { // `string` and `f.string` 在视觉上是相似的 return f.string} 正确示例 123456789101112131415161718192021var errorMessage string// `error` 不会被覆盖func handleErrorMessage(msg string) { // `error` 不会被覆盖}type Foo struct { // `error` and `string` 现在是明确的。 err error str string}func (f Foo) Error() error { return f.err}func (f Foo) String() string { return f.str} 注意, 编译器在使用预先分隔的标识符时不会生成错误, 但是诸如go vet之类的工具会正确地指出这些和其他情况下的隐式问题 避免使用 init() 开发者的代码中应该避免使用init(), 当你认为init()是必须需要的, 你应该先确认: 函数内的处理结果无论程序环境或调用如何, 都是完全确定的 避免依赖于其他init()函数的顺序或结果. 虽然此刻多个init()顺序是明确的, 但代码可能被更改, 因此init()函数之间的关系可能会使代码变得脆弱和容易出错. 避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等 避免I/O，包括文件系统、网络和系统调用 错误示例 1234567891011121314151617181920212223242526// package atype Foo struct { // ...}var _defaultFoo Foofunc init() { // init 中初始化变量 _defaultFoo = Foo{ // ... }}// package btype Config struct { // ...}var _config Configfunc init() { // 获取当前目录 cwd, _ := os.Getwd() // 读取目录下文件 raw, _ := ioutil.ReadFile( path.Join(cwd, \"config\", \"config.yaml\"), ) yaml.Unmarshal(raw, &amp;_config)} 正确示例 1234567891011121314151617181920212223242526var _defaultFoo = Foo{ // ...}// 使用函数来进行初始化var _defaultFoo = defaultFoo()func defaultFoo() Foo { return Foo{ // ... }}type Config struct { // ...}// 开发者手动调用相关函数而不是让其自动执行func loadConfig() Config { cwd, err := os.Getwd() // handle err raw, err := ioutil.ReadFile( path.Join(cwd, \"config\", \"config.yaml\"), ) // handle err var config Config yaml.Unmarshal(raw, &amp;config) return config} 考虑到上述情况，在某些情况下，init()可能更可取或是必要的，可能包括： 不能表示为单个赋值的复杂表达式。 可插入的钩子，如database/sql、编码类型注册表等。 对 Google Cloud Functions 和其他形式的确定性预计算的优化, 例如regexp.MustCompile(编译正则表达式) 切片追加时优先指定容量 在切片需要追加时, 尽可能的预先估算出最大容量, 并在 make 时就指定其容量 目的是减少切片动态扩容带来的时间损耗 错误示例 12345678910111213141516171819package mainimport ( \"fmt\" \"time\")func main() { s := time.Now() size := 100000000 data := make([]int, 0) fmt.Println(cap(data)) for k := 0; k &lt; size; k++ { data = append(data, k) } fmt.Println(cap(data)) fmt.Println(time.Since(s)) // 所需时长} 12301147484161.532827648s 正确示例 12345678910111213141516171819package mainimport ( \"fmt\" \"time\")func main() { s := time.Now() size := 100000000 data := make([]int, 0, size) // 指定容量为 size fmt.Println(cap(data)) for k := 0; k &lt; size; k++ { data = append(data, k) } fmt.Println(cap(data)) fmt.Println(time.Since(s)) // 所需时长} 123100000000100000000333.793275ms 主函数的退出方式 go 程序使用os.Exit或者log.Fatal来进行立即退出, 永远记住, 不要使用panic来进行退出 并且, 只在main()中调用os.Exit和log.Fatal, 对于其他函数的退出, 要将错误信息返回出来 错误示例 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"io/ioutil\" \"log\" \"os\")func main() { body := readFile(\"a.txt\") fmt.Println(body)}func readFile(path string) string { defer func() { fmt.Println(\"假如这里进行一些其他清理操作\") }() f, err := os.Open(path) if err != nil { log.Fatal(err) } b, err := ioutil.ReadAll(f) if err != nil { // 发送错误, 使用 log.Fatal 退出 log.Fatal(err) } return string(b)} 运行后, 发现, defer 中注册的操作无法执行 122022/06/13 19:21:11 open a.txt: no such file or directoryexit status 1 在其他函数中通过以上两种方式直接退出程序有几个隐患: 不明显的控制流: 任何函数都可以导致程序退出, 因此很难对处理逻辑进行控制和分析 难以测试: 如果你的test 测试代码调用了函数, 而在函数内导致程序退出, 同样导致整个测试流程退出, 无法继续进行 跳过清理: 一般的, 我们使用 defer 来进行一些资源清理操作, 例如连接的关闭, 文件句柄关闭等, 但是当函数直接退出时, defer 中的代码不会被执行 正确示例 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( \"errors\" \"fmt\" \"io/ioutil\" \"log\" \"os\")func main() { if err := run(); err != nil { // 主函数进行退出 log.Fatal(err) }}func run() error { defer func() { fmt.Println(\"资源回收\") }() args := os.Args[1:] if len(args) != 1 { return errors.New(\"missing file\") } name := args[0] f, err := os.Open(name) if err != nil { return err } defer f.Close() b, err := ioutil.ReadAll(f) if err != nil { return err } // ... fmt.Println(b) return nil} 123资源回收2022/06/13 19:30:29 missing fileexit status 1 一次性退出 如果可以的话, 在每个main()中最多调用一次os.Exit或者log.Fatal, 如果有多个错误场景, 应该将程序结束, 此时应该将逻辑单独放置在单独的错误函数中, 通过返回错误来让 main 来进行退出, 这样会缩短 main 函数, 同时将关键业务逻辑放置在了单独的, 可以进行测试的函数中 错误示例 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"io/ioutil\" \"log\" \"os\")func main() { args := os.Args[1:] if len(args) != 1 { log.Fatal(\"missing file\") } name := args[0] f, err := os.Open(name) if err != nil { // fatal log.Fatal(err) } defer f.Close() defer func() { fmt.Println(\"清理\") }() b, err := ioutil.ReadAll(f) if err != nil { // defer 同样并不会被执行 log.Fatal(err) } // ... fmt.Println(b)} 正确示例 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"errors\" \"fmt\" \"io/ioutil\" \"log\" \"os\")func main() { if err := run(); err != nil { // 统一进行判断 log.Fatal(err) }}func run() error { args := os.Args[1:] if len(args) != 1 { // err 0 return errors.New(\"missing file\") } name := args[0] f, err := os.Open(name) if err != nil { // err 1 return err } defer f.Close() b, err := ioutil.ReadAll(f) if err != nil { // err 2 return err } // ... fmt.Println(b) return nil} 在序列化的结构体中使用 tag 任何序列化到 json/YAML 或者其他支持基于 tag 来进行字段命名的格式, 都应该使用 tag 来进行注释 因为, 结构的序列化方式, 是不同系统之间交流的约定, 而对字段的修改会导致破坏约定. 使用加入 tag 的方式, 可以使约定更加明确和易读. 并且在重构和重命名字段时, 只要不动 tag, 就无需重新约定结构 错误示例 12345678910111213141516171819202122package mainimport ( \"encoding/json\" \"fmt\")func main() { type Stock struct { // json 在没有 tag 时默认按照字段名 // 当后续字段名有调整导致 json 结构发生变化 Price int Name string } bytes, err := json.Marshal(Stock{ Price: 137, Name: \"UBER\", }) fmt.Println(err) fmt.Println(string(bytes))} 正确示例 12345678910111213141516171819202122package mainimport ( \"encoding/json\" \"fmt\")func main() { type Stock struct { // json 根据 json tag 来进行命名 // 当后续字段名调整, 只要 tag 不动, 则无需重新约定 json 结构 Price int `json:\"price\"` Name string `json:\"name\"` } bytes, err := json.Marshal(Stock{ Price: 137, Name: \"UBER\", }) fmt.Println(err) fmt.Println(string(bytes))}","link":"/2022/04/18/uber_guide_principles/"},{"title":"Vue3 从入门到入土(TypeScript入门)","text":"前言 公司需要写一些简单的前端代码, 说起前端, 那可就大了去了, 我不是专业的, 也没打算干这个, 只能说挑一个简单能用的框架来学了. 在很早之前, 写过一些前端, 那时候还是 Bootstrap 一把梭, 印象比较深的就是自适应栅格, 现在的话, 用的比较多的应该是 Vue 了, 希望一切顺利. 本次 Vue 的学习过程, 主要是参考了视频 尚硅谷Vue.JS教程快速入门到项目实战（Vue3/VueJS技术详解）_哔哩哔哩_bilibili, 视频自带的文档在 Vue3+TS 快速上手 (24kcs.github.io) , 在此对作者和视频网站提出感谢!, 这个文档一眼看去就是 Vueprocess 搭建的, 作为某一个专门的知识分享, 确实很不错, 之前博客使用过这种方式, 缺点是作为博客使用的话, 太过简洁了. 什么是 TypeScript 简称为 TS, 我们之前知道 JS, 而 TS 是 JS 的一个超集, TS 最终会被编译成 JS 代码 可以简单的理解为, TS 包括 JS, 但是又不止 JS, TS 本身有自己的新特性, 比如泛型/ 接口/ 强制类型, 正是因为如此, TS 比 JS 更加的强大 TS 的代码. 需要通过 TS 自己的编译器, 编译成 JS 代码, 因为浏览器支持的最好的还是 JS 代码, 当然, 不排除以后浏览器会完善对 TS 的支持 TS 由微软发布(2013年), 本身是跨平台的语言 TypeScript 的优点 TS 的优点(特点)主要有3种 完美的兼容 JS: TS 可以编译成 JS 代码, 可以在任何支持 JS 的浏览器上运行 强大的类型系统: 允许开发者在开发时, 指定变量的类型, 提高开发效率, 减少 BUG 先进的 JS: TS 完美兼容 JS, 包括 JS 最新的特征和以后的新特征 安装 TS 需要先安装 NodeJS, 安装 NodeJS 查看 中文网 Node.js 中文网 (nodejs.cn) 安装完成 NodeJS 后, 使用 npm 安装 TS(-g 为全局安装) 1npm install -g typescript 当然, 如果你是 mac. 直接使用 brew 更方便 1brew install typescript 安装完成后, 执行命令打印出 TS 版本. 成功即可 12➜ ~ tsc -VVersion 4.6.3 第一个 TS 程序 博主日常开发的话都使用 VSCode, 幸好 UP 主也是 VsCode 需要安装插件 JavaScript and TypeScript Nightly - Visual Studio Marketplace, 以提供对 TS 文件的支持 hello_world.ts 新建一个目录, 目录下新建一个以 ts 结尾的文件, 例如hello_world.ts, 编写代码如下 123456789101112(()=&gt;{ // 创建函数 helloWorld // 传入参数 name, 类型为 string function helloWorld(name: string){ // 将参数 name 和 hello 拼接返回 return \"hello \"+name } // 创建变量 w 值为 world let w = 'world' // 调用函数, 将 w 传入, 同时打印结果 console.log(helloWorld(w))})() // 自制性函数(类似于匿名函数立即执行) 当然我们知道, JS 要想在浏览器运行, 也需要在 html 中引入才行, 于是我们在同级目录下新增文件 index.html, 编写如下 在 VSCode 中, 使用 html5 可生成 html5的基本代码 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 引入本地的 ts 文件 --&gt; &lt;script src=\"./hello_world.ts\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 此时我们右键, 选择在浏览器中打开(没有的, 下载插件 open in browser - Visual Studio Marketplace) 打开的应该是一个空白页面, 因为 html 中没有任何内容, 只是引入了 TS 文件, 此时我们打开浏览器的 f12调试的控制台, 发现有个报错 1Uncaught SyntaxError: Unexpected token ':' 这是因为, 我们上面说过. 目前浏览器还不直接支持 TS 代码, 而在 JS 中, 不可以指定变量的类型, 因此, 代码function helloWorld(name: string){中的:string无法识别, 我们尝试把TS 代码修改为 123456789101112(()=&gt;{ // 创建函数 helloWorld // 传入参数 name, 类型为 string function helloWorld(name){ // 将参数 name 和 hello 拼接返回 return \"hello \"+name } // 创建变量 w 值为 world let w = 'world' // 调用函数, 将 w 传入, 同时打印结果 console.log(helloWorld(w))})() // 自制性函数(类似于匿名函数立即执行) 重新刷新页面, 发现就可以正常的输出 1hello world 当然, 我们之前也说过, TS 可以编译为 JS 代码, 我们的目的也不是让大家写 JS 代码 手动编译 ts 文件到 js 代码 我们可以手动的编译代码为 JS, 在命令行中, 进入我们 ts 代码的所在目录, 执行 1tsc hello_world.ts 可以发现, 运行完成后, 在当前文件夹下, 生成了 hello_world.js, 里面代码如下 123456789101112(function () { // 创建函数 helloWorld // 传入参数 name, 类型为 string function helloWorld(name) { // 将参数 name 和 hello 拼接返回 return \"hello \" + name; } // 创建变量 w 值为 world var w = 'world'; // 调用函数, 将 w 传入, 同时打印结果 console.log(helloWorld(w));})(); // 自制性函数(类似于匿名函数立即执行) 已经生成了 JS 格式的代码, 然后 HTML 中引入修改为生成的 JS 代码, 也可以正常运行了 TS的类型注解 python 的3.8之后也有这个 类型注解是一个轻量级的为函数和变量增加的约束, 实际上就是增加一个类型声明. 声明这个变量是什么类型, 供开发者和 IDE 进行辨认和处理 例如, 我们将hello_world.ts代码修改为 1234567891011121314(()=&gt;{ // 创建函数 helloWorld // 传入参数 name, 类型为 string function helloWorld(name: string){ // 将参数 name 和 hello 拼接返回 return \"hello \"+name } // 创建变量 w 值为 world // let w = 'world' // 这里修改 w 的值为数字 let w = 123 // 调用函数, 将 w 传入, 同时打印结果 console.log(helloWorld(w))})() // 自制性函数(类似于匿名函数立即执行) 可以看到, 我们在函数helloWorld中, 指定了变量name的类型为string, 而此时把value为number的值传入, 会发生什么呢? 首先是 VSCode 自己会飘红, 在 调用函数的位置, 提示你 1类型“number”的参数不能赋给类型“string”的参数。ts(2345) 我们在尝试将 TS 转成 JS 时也会报错 12345678hello_world.ts:12:28 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.12 console.log(helloWorld(w)) ~Found 1 error in hello_world.ts:12 这就是类型注解的好处, 如果你没有真正编写项目的开发经验, 你可能认为反而麻烦了, 而如果你真正的写过业务, 你就会明白为什么这样更好, 一个很重要的一点是, 他会在编译或者开发阶段就将错误排查出来, 以免在运行时发生出乎意料的结果(BUG), 找 BUG 是最痛苦的. 并且, 还可以提高代码的可读性. 接口 接口可以看作是若干类型注解的集合, 类似于 golang 的结构体 123456789101112131415161718192021// 接口也是一种约束(()=&gt;{ // 定义一个接口 Person interface Person{ firstName: string, // 姓 lastName: string, // 名 } // 输出姓名的函数 // 接收参数 p, 类型为接口 Person // 返回 string function showFullName(p: Person) { return p.firstName+\"_\"+p.lastName } // 定义对象, 其类型为 Person const userA: Person = { firstName: \"AF\", lastName: \"AL\", } // 传入参数 console.log(showFullName(userA))})() 接口的存在, 可以更加方便的进行开发和约束 需要注意的是, 不遵守接口规范, 比如传递一个其他的接口类型, 或者接口中的某一个属性不设置, 在直接运行 TS 时会出现问题, 但是在转到 JS 时可以正常转, 这是因为 JS 本身很随便 当然, 我更推荐按照标准去写, 这样能提高代码的健壮性, 如果你使用 TS, 你就应该遵守其规则 类 类这个概念, 如果是后端开发, 想必会非常熟悉, 我直接上代码 123456789101112131415161718192021222324252627282930// 接口也是一种约束(()=&gt;{ // 定义一个接口 Person interface Person{ firstName: string, // 姓 lastName: string, // 名 } // 定义一个类 User class User{ firstName: string // 姓 lastName: string // 名 fullName: string // 全称 // 类的构造函数, 在类创建时执行 constructor(firstName: string, lastName: string){ this.firstName = firstName this.lastName = lastName this.fullName = this.firstName+\"_\"+this.lastName } } // 创建类的对象 function greeter (person: Person) { return 'Hello, ' + person.firstName + ' ' + person.lastName } // 创建 user 对象 let user = new User('Yee', 'Huang') // 因为 类 User 属性包括了接口 Person, 所以也可以使用 console.log(greeter(user))})() 这里的接口和对象的使用, 有些人可能会感觉到疑惑, 其实接口是抽象的概念, 任何结构, 只要有接口的对应字段, 就可以调用接口, 比如 123456789101112131415161718192021222324252627// 接口也是一种约束(()=&gt;{ // 定义一个接口 Person interface Person{ firstName: string, // 姓 lastName: string, // 名 } interface P1{ firstName: string, // 姓 lastName: string, // 名 } // 输出姓名的函数 // 接收参数 p, 类型为接口 Person // 返回 string function showFullName(p: Person) { return p.firstName+\"_\"+p.lastName } // 定义对象, 其类型为 P1 const userA: P1 = { firstName: \"AF\", lastName: \"AL\", } // 传入参数 // 也可以正常的使用 // 因为接口是抽象的 console.log(showFullName(userA))})() webpack 打包 TS 项目 一个项目, 肯定不止一个文件, 都是由特定的规则和目录组成 初始化 在写一个新项目之前, 找一个新的文件夹, 执行 npm init -y 会在最上层目录生成 package.json, 这里是 npm 的配置文件 再执行 tsc --init 命令, 生成 tsconfig.json 文件, 这个是 TS 的配置 随后我们新建几个文件, 目录如下 1234567891011.├── build│ └── webpack.config.js├── package.json├── public│ └── index.html├── src│ └── main.ts└── tsconfig.json3 directories, 5 files 目录结构和代码 其中, src目录中存放具体的代码, 我们这里就单独放一个main.ts, 内容如下 这里需要说明的是, 在视频中, 讲解人这里代码是document.write('Hello Webpack TS!'), 可以在 html 中动态的添加数据, 但是新的浏览器, 默认是禁止异步加载的 js 修改 document 结构的, 需要额外设置, 这里为了专心学习打包, 选择了 console.log 1console.log(\"webpack\") public目录存放 html和其他静态资源等, 这里的index.html内容为 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; build目录存放打包构建时的文件, 这里存放一个 webpack 打包时需要的配置文件webpack.config.js, 内容为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const {CleanWebpackPlugin} = require('clean-webpack-plugin')const HtmlWebpackPlugin = require('html-webpack-plugin')const path = require('path')const isProd = process.env.NODE_ENV === 'production' // 是否生产环境function resolve (dir) { return path.resolve(__dirname, '..', dir)}module.exports = { mode: isProd ? 'production' : 'development', entry: { app: './src/main.ts' // TS 的起始文件位置 }, output: { path: resolve('dist'), // 打包后的文件保存目录 filename: '[name].[contenthash:8].js' // 文件名格式 }, module: { rules: [ { test: /\\.tsx?$/, use: 'ts-loader', include: [resolve('src')] } ] }, plugins: [ new CleanWebpackPlugin({ }), new HtmlWebpackPlugin({ template: './public/index.html' }) ], resolve: { extensions: ['.ts', '.tsx', '.js'] }, devtool: 'eval-cheap-module-source-map', // 这里兼容 webpack 新版本, 修改了参数 devServer: { host: 'localhost', // 主机名 port: 8081, // 端口 open: true // 自动打开端口 },} 安装必要依赖 而后, 我们需要为项目安装几个依赖 123456yarn add -D typescript # TS 依赖yarn add -D webpack webpack-cli # webpack 打包yarn add -D webpack-dev-server # dev 环境测试yarn add -D html-webpack-plugin clean-webpack-plugin # 删除之前打包的文件yarn add -D ts-loader # tsyarn add -D cross-env # 跨平台打包 安装完成后, 会新增加一个目录node_models, 存放着若干个依赖文件, 这里的东西不需要自己修改 修改package.json, 主要是修改启动时的参数(json 的 scripts 部分), 同时也可以发现, 刚才 add 的几个依赖, 也已经自动加入到了 json 文件中 123456789101112131415161718192021222324{ \"name\": \"01\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js\", \"build\": \"cross-env NODE_ENV=production webpack --config build/webpack.config.js\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": { \"clean-webpack-plugin\": \"^4.0.0\", \"cross-env\": \"^7.0.3\", \"html-webpack-plugin\": \"^5.5.0\", \"ts-loader\": \"^9.2.8\", \"typescript\": \"^4.6.3\", \"webpack\": \"^5.71.0\", \"webpack-cli\": \"^4.9.2\", \"webpack-dev-server\": \"^4.7.4\" }} 运行 dev 环境 1yarn dev 会自动唤醒浏览器, 打开页面, 打开调试, 发现打印出了webpack 运行 build 1yarn build 完成后, 会生成文件夹dist, 其中存放了打包好的代码 12345.├── app.7e4f7be0.js└── index.html0 directories, 2 files 这里的代码都已经被压缩过了, 目的是减少网络传输时间, 有兴趣的可以自行格式化查看","link":"/2022/03/27/vue_01_helloWorld/"},{"title":"Vue3 从入门到入土(TypeScript数据类型)","text":"数字/字符串/布尔 123456789101112131415161718192021222324// 基础类型(()=&gt;{ // let 变量名: 变量类型 = 值 // 对于已经定义了类型的变量, 可以重复赋值为相同类型的值, 但是不能赋值为不同类型 // bool let ok: boolean = true // 数字 // 可以存放四种进制, 但是在打印时都会转成十进制 let count0: number = 10 // 十进制 let count1: number = 0b1010 // 二进制 let count2: number = 0o12 // 八进制 let count3: number = 0xa // 十六进制 // 字符串类型 let str0: string = \"str0\" let str1: string = \"str1\" // 字符串 format console.log(`${str0}, ${str1}, ${count0}`) // 字符串和数字拼接 console.log(str0+count1) // str010})() undefined/null 12345678 // 基础类型(()=&gt;{ // undefined 和 null 是不同的类型 // 默认的时候, undefined 和 null 是所有类型的子类型 let u: undefined = undefined let n: null = null // 默认情况下, 不能将其他类型的变量赋值为 undefined 或者 null})() 数组类型 12345678910111213141516171819// 基础类型(()=&gt;{ // 数组类型 // 数组里的每个变量类型必须相同, 且符合定义数组时设置的数据类型 // 数据类型[] // number[] 代表一个数组, 里面的类型为 number let arr0: number[] = [1, 2, 3, 4, 5, 6] // 数组类型的另一种定义方法 // Array&lt;数据类型&gt; let arr1: Array&lt;number&gt; = [1, 2, 3] // 元组类型 // 元组可以存储不同的数据类型, 但是必须在定义时设置好元组的长度和每个的类型 // [元组0位的类型, 元组1位的类型, ....] let arr3: [string, number, boolean] = [\"s\", 0, false]})() 枚举 12345678910111213141516171819202122232425262728293031323334// 基础类型(()=&gt;{ // 枚举 // 枚举中的每一个数据值都可以叫做元素, 每个元素都有自己的编号, 默认编号从0开始, 依次递增+1 enum Color{ red, // 0 green, // 1 blue, // 2 } let color: Color = Color.red // 0 // 枚举可以指定其每个元素的值, 但是必须是 number 类型 enum Color1{ red = 100, // 100 green, // 101 blue, // 102 } enum Color2{ red, // 0 green = 100, // 100 blue, // 101 } enum Color3{ red = 1, // 1 green = 3, // 3 blue = 100, // 100 } // 从元素拿到值 console.log(Color2.red) // 0 // 从值拿到元素 console.log(Color2[100]) // green})() any 1234567891011// 基础类型(()=&gt;{ // any // any 对应任意类型, 在不确定当前是什么类似时使用 // 因为编译器并不能确定具体的类型, 所以要慎用 any, any 可能会导致错误在运行时才暴露出来 let str: any = 100 str = \"string\" str = false let arr: any[] = [100, \"str\", false]})() void 123456789101112// 基础类型(()=&gt;{ // void // void 一般在函数没有返回值时使用, 标识该函数无返回值 function show():void{ console.log(\"func show\") } show() // void 与 undefined // void 类型的变量, 可以接受一个 undefined 的值, 一般不使用 let vd:void = undefined})() object 1234567891011121314151617// 基础类型(()=&gt;{ // object // object类型 function getObject(obj:object):object{ console.log(obj) return { name: \"18\", age: 19, } } console.log(getObject({ age: 18, name: \"text\" }))})() 联合类型/类型断言 12345678910111213141516171819202122232425262728293031323334// 基础类型(()=&gt;{ // 联合类型 // 类似泛型 // 联合类型表示取值为多种类型中的某一种 // 定义函数getStr接收参数 str, 类型为 number 或 string, 返回 string function getStr(str:number|string):string{ return str.toString() // 将参数转成 string 类型返回 } console.log(getStr(1)) console.log(getStr(\"tttt\")) // 配合类型断言使用 // 类型断言, 告诉编译器, 这个变量是什么类型 // (&lt;类型&gt;变量) 则代表告诉编译器, x 是 string 类型 function getLen(x:number|string):number{ if ((&lt;string&gt;x).length){ // 只有 string 有.length 方法, 这里如果没有, 则是 number 类型 return (&lt;string&gt;x).length }else{ // number 类型 需要 toString 再输出长度 return x.toString().length } } // 类型断言的第2种语法 // 等同于方法1 function getLen1(x:number|string):number{ if ((x as string).length){ // 只有 string 有.length 方法, 这里如果没有, 则是 number 类型 return (x as string).length }else{ // number 类型 需要 toString 再输出长度 return x.toString().length } }})() 类型推断 123456789// 基础类型(()=&gt;{ // 类型推断 // 类型推断, TS 在没有明确的自动类型时推测出一个类型, 编译器自己会进行类型推断, 自动判断出变量的类型 // 当定义变量且赋值时, 会根据值进行推断类型 // 当定义变量但是不赋值时, 推断为 any 类型 let t = 100 // 编译器自己推断成 number let a; // 自己推断成 any})()","link":"/2022/04/03/vue_02/"},{"title":"Vue3 从入门到入土(TypeScript接口)","text":"前言 在上一章, 我们就写过简单的接口, 本章更深入的了解接口 接口是对象的状态(属性)和行为(方法)的抽象(描述) 接口 以例子来了解, 我们有这样的需求 12345定义一个对象存放用户信息, 有四种属性- id 是 number 类型, 必须有, 并且只读- age 是 number 类型, 必须有- name 是 string 类型, 必须有- sex 是 string 类型, 可以没有 可选/只读属性 1234567891011121314151617181920212223242526(()=&gt;{ // 接口是一种类型/规范/规则/能力/约束 // 定义一个接口 IUser // 接口一般以 I 开头 interface IUser{ readonly id: number, // 在定义时, 指定 readonly 代表这个属性是只读的 name: string, age: number, sex?: string, // 在定义时, 指定 ? 代表这个属性是可为空的, 不指定默认必须存在 } // 定义一个对象 const u1:IUser={ id: 1, name: \"u1\", age: 18, } const u2:IUser={ id: 2, name: \"u2\", age: 19, sex: \"男\", } // u2.id = 3 // 在实例化后, 无法对只读属性进行重新赋值})() 函数类型 上面的接口都是作为对象使用, 其实他也可以作为函数的类型使用 123456789101112131415(()=&gt;{ // 接口是一种类型/规范/规则/能力/约束 // 定义一个接口 SearchFunc, 作为函数约束使用 interface SearchFunc{ // 传入两个参数, 都是字符串, 返回 bool (source: string, subString: string): boolean } // 定义一个函数, mySearch, 遵守接口 SearchFunc const mySearch: SearchFunc = function(source: string, sub: string): boolean{ return source.search(sub) &gt; -1 } console.log(mySearch(\"abcd\", \"bc\"))})() 类实现接口 123456789101112131415161718192021222324252627282930313233343536373839404142(()=&gt;{ // 接口是一种类型/规范/规则/能力/约束 // 一个类可以实现多个接口 // 一个接口可以继承多个接口 // 定义接口 Alarm interface Alarm{ // 实现 alert 方法 alert(): any; } // 定义接口 Light interface Light{ // 实现 lightOn 方法 lightOn(): void; // 实现 lightOff 方法 lightOff(): void; } // 定义类 Car, 实现接口 Alarm // implements 关键字, 指定继承接口 Alarm class Car implements Alarm{ // 继承后必须实现接口定义的方法 alert() { console.log(\"alert\"); } } // 定义类 Car1, 实现接口 Alarm 和 Light class Car1 implements Alarm, Light{ // 必须同时实现接口 Alarm 和 Light 的方法 alert() { console.log(\"alert\"); } lightOff(): void { console.log(\"off\"); } lightOn(): void { console.log(\"on\"); } }})() 接口继承接口 12345678910111213141516171819202122232425262728293031323334353637383940(()=&gt;{ // 接口是一种类型/规范/规则/能力/约束 // 接口继承接口 // 定义接口 Alarm interface Alarm{ // 实现 alert 方法 alert(): any; } // 定义接口 Light interface Light{ // 实现 lightOn 方法 lightOn(): void; // 实现 lightOff 方法 lightOff(): void; } // 接口 LightAlarm 继承 Alarm 和 Light interface LightAlarm extends Alarm, Light{ simple(): void; } // 定义类 Car1, 实现接口 LightAlarm class Car1 implements LightAlarm{ // 必须同时实现接口 Alarm 和 Light 和 LightAlarm 的方法 alert() { console.log(\"alert\"); } lightOff(): void { console.log(\"off\"); } lightOn(): void { console.log(\"on\"); } simple(): void{ console.log(\"simple\") } }})()","link":"/2022/04/04/vue_03_interface/"},{"title":"大型网站技术架构-笔记(1)","text":"大型业务的系统特点 高并发 大流量 高可用 海量数据 用户分布广泛 网络情况负载 安全环境恶劣 需求快速变更 快速迭代 最初的小型业务的架构 LAMP = Linux+Apache+MySQL+PHP 网站的架构变化 一台服务器放置LAMP 三台服务器存放 应用/文件服务/数据库服务 增加本地缓存/分布式缓存服务器 应用服务器增加集群 数据库读写分离 CDN和反向代理 分布式文件系统和分布式数据库 使用NOSQL和ES 将业务进行拆分 根据业务来确定网站架构, 多大的业务量决定使用什么架构, 合适的才是最好的 技术架构为业务服务, 切勿本末倒置 网站架构的设计误区 一味追寻大公司的解决方案 为了技术而技术, 脱离实际情况 企图使用技术解决所有问题(为什么不试试调整业务呢?) 网站架构模式 分层 应用层: 负责具体业务和视图展示, 网站首页和搜索输入和结果展示(前段) 服务层: 为应用层提供服务支持, 用户管理服务, 购物车服务(接口) 数据层: 数据的存储和访问服务, 数据库/缓存/文件/搜索(数据) 分割 将网站按照模块进行分割, 逻辑与物理都分割, 提高并发处理能力和功能扩展能力 分布式 将分割后的模块进行分布式部署 好处 提高并发与数据处理能力 问题 网络通讯造成的性能损耗 某一个服务器宕机造成的网站可用性降低 数据在分布式环境中的数据一致性问题 事务问题 网站依赖关系复杂, 开发/管理/维护困难 分布式方案 分布式应用和服务: 将分割后的接口进行分布式部署, 可以改善网站性能和并发性,有利于业务功能扩展, 对于开发这个模块的人来说, 可以加快开发速度 分布式静态资源: 将静态资源独立分布式部署, 动静分离, 加快加载速度, 优化用户体验 分布式数据和存储: 将数据分布式存储, 提高效率 分布式计算: 将对计算要求高的逻辑使用分布式计算框架分配到其他机器进行计算, 提高效率 缓存 CDN: 将一些静态资源和较少变化的数据和热点数据存放在缓存中, 用户访问时优先访问缓存 反向代理: 反向代理服务配置缓存 本地缓存: 在应用程序设计的本地存放缓存, 一般是存放在内存中 分布式缓存: 将缓存存放在分布式缓存集群中 什么时候适合使用缓存: 需要频繁访问的数据/在某个时段内有效的数据 异步 将要处理的数据存放进队列中, 由消费者去消费 提高系统可用性: 消费者发生问题时生产者可以继续入队 加快响应速度: 耗时的操作不需要等待即可返回, 减少响应延迟 消除并发访问高峰: 访问量大的时候也由消费者依次处理, 减轻压力 异步要和产品的业务相关, 有些时候无法使用异步 冗余 某个服务器宕机时一定要保持重要数据的不丢失, 所以需要一定数量的服务器 冗余运行, 目的是在正常情况下, 这些服务器是不参与正常的业务流程的, 当线上的服务器发生故障时, 再启动对应的冗余服务器承接业务, 保证服务的正常运行, 一般的, 像网关之类的(一台服务器即可, 但是挂掉对整个架构的影响较大)服务必须要设置冗余 冗余可以实现服务的高可用 备份 冷备份:数据库中的数据也需要定时备份与存档, 这叫数据冷备份 热备份:数据库的高可用就是总从分离, 数据库会进行同步更新数据, 这种随时更改随时同步的方法叫热备份 灾备数据中心:特别大的业务, 为了抵御遇到大停电/地震/海啸等不可抗力导致的业务瘫痪, 在各地有灾备数据中心, 尽可能的减少损失 自动化 发布过程自动化: 自动化发布系统, 减少发布过程因为人为失误导致的问题 自动化代码管理: 代码版本控制/分支控制等自动化 自动化测试: 提交测试后由系统进行自动化用例测试 自动化安全检测: 通过安全检测工具检测代码 自动化部署: 自动部署到线上环境 自动化监控: 对线上的各项指标进行监控, 通过服务中心对集群机器性能进行监控 自动化报警: 检测到指标达到某一个阀值时自动向相关人员通过短信/手机等方式报警 自动化失效转移: 检测到集群的某个服务器挂掉后自动将其剥离出业务, 等待开发人员修复 自动化失效恢复: 监测到服务正常后自动加入到业务中 自动化降级: 网站持续告警时, 关闭一些不重要的服务, 将资源释放出来給重要的服务保障业务的安全可用 核心架构要素 性能 一个打开缓慢的网站会导致严重的用户流失, 除非是没的选择 优化措施: 前端利用浏览器缓存/页面压缩/合理布局页面/减少cookie传输来改善性能 架构使用CDN/反向代理/缓存热点文件来加快响应速度减轻服务器压力 后端使用本地缓存和分布式缓存加快请求处理过程,减轻数据库压力 是否可以将业务修改为异步 集群/多线程/SQL优化等 可用性 网站宕机/服务不可用属于重大失误, 轻则影响网站声誉, 重则摊上官司. 而且大概率会损失金钱和用户 优化措施: 冗余, 应用部署在多个服务器同时提供服务, 数据在多个服务器互相备份 服务集群, 负载均衡, 前提是应用服务器不能保存请求的会话信息以免出现问题切换到另一台机器时无法完成业务处理 数据库集群, 数据采用冷备份和热备份同时运行的方式 伸缩性 伸缩性指通过不断向集群中加入服务器来缓解不断上升的业务量和数据存储需求 衡量伸缩性的主要标准就是是否可以使用堕胎服务器构建集群, 是否容易向集群中添加新的服务器, 加入新的服务器后是否可以提高和原来的服务器无差别的服务, 集群中可以容纳的总服务器数量是否有限制 应用服务器集群: 服务器上不保存数据, 所有服务器都是对等的, 通过使用合适的负载均衡设备就可以向集群中不断加入服务器 缓存服务器集群: 加入新的服务器可能导致缓存路由失败, 导致集群中大部分缓存数据无法访问. 虽然缓存的数据可以通过数据库重新加载, 但是如果应用严重依赖缓存, 可能会导致整个网站崩溃, 需要改进缓存的路由算法保证缓存数据的可访问性 关系型数据库: 数据库本身很难做到大规模集群的可伸缩性,所以必须在数据库外实现, 例如通过逻辑分区将某一部分逻辑的多个数据库服务器组成集群 NoSQL: 天生就为海量的数据而生, 因此对伸缩性支持很好 扩展性 网站的扩展性架构直接关注网站的功能需求, 网站的功能快速迭代, 扩展性的提高可以使其快速响应需求的变化 衡量网站架构性的标准是在网站增加新的业务产品时, 是否影响现有产品, 是否不需要改动或很少改动现有产品即可上线新的产品, 不同产品之间是否很少耦合, 一个产品的改动是否对其他产品有影响, 其他产品是否不需要改动 优化措施: 事件驱动架构: 事件驱动通常使用消息队列实现, 消息产生后加入队列, 由消费者服务进行消费, 通过这种方式将消费者和生产者分开, 透明的增加新的生产者或消费者 分布式服务: 将业务和可复用服务分离, 通过分布式框架调用, 新增产品通过调用可复用的服务实现自身的业务逻辑, 对现有的产品没有任何影响. 可复用服务升级时要注意多版本的兼容, 实现透明升级 大的网站为了保持市场地位和覆盖率, 会提供开放平台接口供第三方开发者调用 安全性 互联网是开放的, 任何人在任何地方都可以访问网站, 网站的安全架构就是保护网站不受恶意访问和攻击, 保护重要数据不被窃取","link":"/2021/09/04/website_architecture(1)/"},{"title":"大型网站技术架构-笔记(2)","text":"瞬时响应: 网站的高性能架构 A网站在100并发的时候, 接口响应时间是1s, 200并发时是10s B网站在100并发时是1.5s, 200并发是还是1.5s 这种情况下, 用户认为哪个网站访问快呢? 网站性能是客观的指标, 可以具体到响应时间/吞吐量等技术可以衡量的技术指标, 同时也是使用者的主观感受, 感受这个东西就比较微妙, 不好用技术指标来统计 网站性能测试 性能测试是性能优化的前提和基础, 也是性能优化结果的检查的度量标准. 不同视角下的网站性能有不同标准和优化手段 用户视角 从用户角度, 网站性能指用户在浏览器上直观的感受慢还是快, 那么, 用户感受到的时间, 其实流程是: 用户点击鼠标 &gt; 计算机浏览器解析指令 &gt; 找到需要发生的请求 - 发起请求 &gt; 网络通信 &gt; 服务器端接收到请求 &gt; 返回结果 &gt; 网络通信 &gt; 浏览器接收到结果 &gt; 解析结果 &gt; 展示到浏览器上 所以, 不同的浏览器/不同的计算机/不同的网络情况 可能导致用户感受到的延迟远远大于服务器请求的耗时. 在实际情况, 考虑使用前端手段优化速度, 比如 优化HTML样式 利用浏览器缓存 使用CDN/反向代理 目的是使浏览器更快显示用户感兴趣的内容, 尽可能近的获取页面内容, 即使不优化程序和架构, 也可以很大程度改善用户视角下的网站性能 开发人员视角 开发人员主要考虑程序本身及相关子系统的性能, 包括 响应延迟/系统吞吐量/并发处理能力/系统稳定性 等技术指标. 在实际情况, 考虑使用技术方面的优化手段, 比如 使用缓存加速数据读取 使用集群提高吞吐 使用异步加快请求响应与实现削峰 使用代码优化手段 运维人员视角 运维人员更关心基础设施的性能和资源利用率, 比如网络带宽/服务器硬件配置/数据中心网络架构/服务器/资源利用率 优化手段有: 建设骨干网络提高带宽 使用高性价比服务器 利用虚拟化技术提高资源利用率 性能测试指标 不同视角下有不同的性能标准, 不同标准有不同的指标 响应时间 一般指执行一个操作需要的时间, 从请求发送到收到最后的响应需要的时间, 是重要的指标, 直接反映系统的‘快慢’ 测试响应时间需要请求很多次, 比如一万次, 计算其平均值 并发数 指系统同时处理请求的数目, 可反映系统的负载特性 测试并发数时一般通过多线程模拟多个用户来模拟用户进行操作, 为了更加真实, 通常在两个请求间加入一个随机的等待时间, 这个时间被称作思考时间 吞吐量 指单位时间内系统处理的请求数量, 体现系统的整体处理能力. 常用的量化指标有: TPS-每秒事务数-事务指一系列正常操作(最常用) HPS-每秒HTTP请求数-并发 QPS-每秒查询数 在系统并发数由小到大的过程中. 服务器资源消耗也逐渐增大, 一般的, 系统吞吐量应该先逐渐增加, 到一定极限后继续增加会导致吞吐量下降, 然后到达崩溃点后资源耗尽, 吞吐量为0 对应的, 响应时间先是小幅度的上升, 到达吞吐量极限后快速的上升, 到达崩溃点后失去响应 网站优化需要尽量提高系统吞吐量, 最大限度利用服务器资源 性能计数器 是描述服务器和操作系统性能的一些指标, 包括 线程数量/内存使用/CPU使用/网络IO/磁盘占用 等指标, 当发现指标超过预定的报警阀值时应及时联系运维与开发人员处理 性能测试方法 性能测试 以系统设计时的性能指标为目标, 对系统不断施加压力, 验证系统在资源的可接受范围内是否能达到性能预期 负载测试 向系统不断的增加并发请求来增加系统压力, 一直到系统的某项或者多项性能指标达到安全临界值, 安全临界值的表现为超过该值之后系统处理能力会下降 压力测试 超过安全负载的情况下继续对系统施加压力, 直到系统崩溃 稳定性测试 被测试的系统在指定的 硬件/软件/网络环境 下, 给系统加载一定的业务压力, 使系统运行较长时间来观测系统是否稳定 性能优化策略 问题分析 如果有用户上报网站使用起来‘慢’, 必须对请求经历的各个环节进行排查, 定位问题 必须检查请求处理的各个环节的日志, 分析响应时间, 检查监控数据, 分析问题是代码问题还是硬件或者网络问题 Web前端优化 一般指网站业务逻辑前的部分, 比如: 浏览器加载/网站视图模型/图片服务/CDN服务 等 减少HTTP请求 - HTTP是无状态的应用层协议, 每次HTTP都要去建立链接和传输, 所以减少HTTP请求数量可提高性能, 比如合并 CSS/JS/图片 等资源 使用浏览器缓存 - 一般的, CSS/JS/ICON 等静态资源文件更新频率较慢, 将这些文件缓存在浏览器中可以很大的改善性能. 可以设置 HTTP 头的 Cache-Control 和 Exprise 属性来控制. 还要保证在发生更改时需要及时同步到用户的客户端中(不使用缓存), 可放置一个新的JS并更改主页面的HTML的JS引用将其引用到新的JS中, 需要更新N个JS时, 最好一次更新几个或一个避免访问量激增造成的网络堵塞 启用压缩 - 对文件(JS/CSS/HTML…)进行压缩, 在浏览器端进行解压缩可减少网络传输时间, 但是会对服务器和浏览器产生一定的压力 CSS放在页面最上面, JS放在页面最下面 - 浏览器在下载完CSS才会对页面进行渲染, 所以将CSS放置在页面最上方让浏览器尽快下载, JS在加载后立刻执行, 有可能对页面进行阻塞, 造成页面显示缓慢, 因此JS放在页面最下面. 例外是页面解析需要使用JS, 那么就不要放置在底部 减少Cookie传播 - Cookie一般保存一些用户的信息, 有可能比较大, 会对数据的传输造成负担, 因此要对写入Cookie的数据进行慎重考虑, 同时为了避免访问静态资源时也携带Cookie造成无意义的损耗, 可将静态资源设置成独立域名避免请求静态资源时发生Cookie CDN加速 CDN(内容分发网络)的本质是一个缓存, 将缓存放置在离用户最近的地方(物理), 使用户最快的获取数据 CDN部署在网络运营商的机房, 运营商又是终端用户的网络服务提供商, 因此用户请求数据会先到达CDN服务器, 当CDN存在用户需要的数据时直接从CDN返回, 这样可以加快用户访问速度, 同时减少数据中心的负载 CDN一般缓存静态资源, 比如图片/文件/css/JS等, 将其缓存到CDN会极大改善网页速度 反向代理 用户的请求发送到反向代理服务器, 反向代理服务器再转发到内部的服务, 因此, 反向代理服务器也可以保护网站的安全, 来自于互联网的请求必须经过代理服务器, 相当于在Web服务器和网络之间建立了一堵墙, 现在一般使用 Nginx 作为反向代理的服务, 可以完成多个操作, 比如 使用缓存 - 用户第一次访问静态资源时将该资源缓存到反向代理服务器中, 另一位用户访问时直接从代理服务器返回, 也可以将弱动态数据(博客/帖子/词条等一些实时性不强的数据)存储在缓存中, 当有数据变化时内部通知反向代理服务器将该缓存失效 负载均衡 - 如某个功能有多台服务器处理, 可将请求按照规则转发到某一台服务器, 提高系统处理能力和性能 应用服务器性能优化 分布式缓存 缓存一般指将数据存储在访问速度相对较高的存储介质中供系统使用, 缓存的访问速度快, 可以减少数据的访问时间, 另一方面如果缓存的数据是经过计算得到的, 那么该数据无需每次重新计算即可直接使用, 还起到了减少计算时间的作用 但是以下几种情况不适合使用缓存 频繁修改的数据 - 一般来说数据的读写比在2:1以上才需要加入缓存 没有热点的访问 - 访问量不大的数据没必要放置进缓存 数据不一致/脏读 - 缓存有过期时间, 有可能会出现缓存还没有过期时实际的数据已经更新的情况, 所以缓存的过期时间需根据实际情况确定, 有一种策略是数据更新时立即更新缓存, 这会带来更多系统开销和事务一致性的问题 缓存可用性 缓存的目的是提高数据读取性能, 理论上讲, 缓存数据的丢失或者不可用不会影响到程序的处理 但是随着业务的发展, 缓存会承担大部分的数据访问压力, 此时数据库的架构有可能会更多的依赖缓存, 如果缓存服务崩溃, 数据从数据库读取, 数据库可能会因为巨大的压力而宕机, 这种一般叫做缓存雪崩 为避免这种情况, 有的方法是对缓存进行热备, 但是这种设计本末倒置, 缓存本来就不应该当作可靠的数据源使用 比较好的方法是建立分布式缓存服务集群, 将缓存数据分布式存储. 就算其中一台宕机也不会对数据库产生多大压力 产品在设计之初就需要一个明确的定位, 什么产品实现什么功能, 什么不是产品的特征, 在产品的生命周期中, 会有很多困难和诱惑来修改产品的发展方向. 左右摇摆/什么都想做 的产品, 最后很有可能会成为一个没有生命力的四不像 缓存预热 缓存中存放热点数据, 热点数据是缓存系统使用LRU(最近最久未使用算法)对数据筛选淘汰出来的, 这个过程时间较久, 新启动的缓存系统在重建缓存数据的过程中, 对性能和数据库的提升都不高, 所以最好在缓存系统启动时把热点数据加载好, 这种手段叫 缓存预热, 比如 省市区三级联动/类目信息 等, 可以在缓存系统启动时加载到系统中 缓存穿透 对于不恰当的业务, 或者遭受到了恶意的攻击, 持续的高并发的请求某个不存在的数据, 缓存没有获取到这个不存在的数据, 那么会到数据库检索, 导致数据库压力大, 一般的对策是在这个频繁访问的数据到达阀值后将该数据也加入缓存, 其Value为Null Memcached https://www.memcached.org/ Memcached 是非常出名的分布式缓存框架, 被大量网站使用. 他的优点是 设计简单/服务器集群间互不通信/海量数据可伸缩 通信协议 Memcached使用TCP协议进行通信, 其序列化协议是基于文本的自定义协议, 非常简单, 大概是以一个命令关键字开头, 后面是命令操作 丰富的客户端 因其通信协议很简单, 因此主流的语言都有对应的客户端, 开发很方便 高性能的网络通信 服务端的通信模块基于 Libevent, Libevent是一个支持事件触发的网络通信库©, 其有 稳定/轻量/快速 等特点 高效的内存管理 使用固定内存分配, 避免了内存碎片管理的问题 集群架构互不通信 其分布式架构, 多台节点之间互不通信, 由客户端分布式算法来确定缓存存放在哪个节点, 取时根据key确定存储机器再进行获取, 我们可以将其比喻成一个圆, 有两个节点就相当于将这个圆分两半, 通过客户端hash一致性算法计算出来key是哪一个区间. 当添加或者减少某个节点, 也只影响这个节点相关的一个节点的数据 异步操作 任何可以晚点做的事情都应该晚点再做 异步一般搭配消息队列, 不仅可改善网站的扩展性. 还可以改善网站的性能. 需要注意的是, 用户在接收到返回时可能只是入了队列还未执行完成, 因此业务要相应的进行调整 使用集群 将业务搭载在集群中, 由负载均衡服务进行任务的分配, 比如我有三台机器进行负载均衡, 那么每台机器的压力则为全部的 3/1, 能有效提高效率和减少负载 代码优化 多线程 多线程带来的是效率的提升, 但是随之而来的是BUG的难以调试和线程安全问题, 线程安全的解决一般如下 将对象设计为无状态 使用局部对象 并发访问资源时使用锁 资源复用 系统运行时, 一定要减少开销很大的系统资源的创建和销毁, 比如 数据库的连接/网络通信连接/线程/复杂对象 等, 资源复用有两种模式 单例模式 对象池 数据结构 pass 垃圾回收 现在好多语言自己处理垃圾回收 存储性能优化 使用SSD(固态硬盘), 但是成本会提高","link":"/2021/09/04/website_architecture(2)/"},{"title":"大型网站技术架构-笔记(3)","text":"网站可用性度量 业界通过用多少个9来衡量网站的可用性 网站不可用时间 = 故障修复时间点 - 故障发现(报告)时间点 网站年度可用性指标 = (1 - 网站不可用时间 / 年度总时间) x 100% 达到4个9就很难了(99.99%) 高可用的网站架构 典型的网站设计通常为三层的架构模型, 即 应用层/服务层/数据层 (从上到下) 各层之间具有相对独立性 应用层负责具体业务逻辑的处理 服务层负责提供可复用的服务 数据层负责数据的存储与访问 大型网站的分层架构及物理服务器的分布式部署使得位于不同层次的服务器具有不同的可用性, 关闭服务器或者宕机时产生的影响也不一样. 高可用的解决方案也差异很大 应用层 - 通过负载均衡将一组服务器组成集群对外提供服务, 当负载均衡设备通过心跳等方式检测到某台服务器不可用时将其从集群列表中剔除来实现高可用 服务层 - 通过集群方式实现高可用, 只是这些服务被上层的应用层调用, 分布式服务调用框架会在应用层客户端内实现软件负载均衡, 并通过服务注册中心对提供服务的服务器进行心跳检测, 如服务不可用则通知客户端程序修改服务访问列表, 将不可用的服务器剔除 数据层 - 为保证数据不丢失, 需要在数据写入时进行数据的同步复制, 将数据写入到多个服务器上实现冗余备份. 服务器宕机时切换到备份服务器 高可用应用 应用层处理网站应用的业务逻辑, 所以也有人叫业务逻辑层, 应用的一个显著的特点是应用到的无状态性 无状态性指应用服务器不保存业务的上下文信息, 而是根据每次请求提交的数据进行业务处理, 多个服务器之间完全对等, 请求提交到任何服务器, 处理的结果都是一样的 通过负载均衡进行无状态服务的失效转移 对于无状态服务来说, 将某个请求交给哪个服务器都是一样的处理结果, 那么, 我们可以通过搭建集群来进行负载均衡, 同时, 当某台服务器出现问题时, 负载均衡服务器通过心跳检测发现该服务器异常, 将其从提供服务的列表中删除, 因为服务是无状态的所以不会影响最终的处理结果 负载均衡实际上在应用层起到了高可用的架构, 因此健全的架构应该是即使某个服务访问量非常少, 一台服务器足够处理, 也最好至少部署两台服务器加上负载均衡技术构建一个小型的集群 集群架构的Session管理 应用服务器的高可用架构主要基于服务无状态这一特征, 但是实际中业务总是有状态的, 比如说有的电商网站可能会有服务是购物车商品的加减等, 这种多次请求修改使用的上下文对象称之为会话(Session), 在负载均衡中, 由于负载均衡服务会将请求分发到集群中的任何一台服务器上, 所以对Session的处理比单机复杂得多, 一般有以下几种方法 Session复制 早期的应用系统使用较多的是在集群里的服务器之间开启Session的同步机制, 达到在每台服务器之间都保存所有用户的Session信息, 即使请求分配到不同的服务器也不会对结果产生影响 这种方法虽然简单粗暴, 从本机直接获取Session也是最快的途径, 但是如果集群的规模变大时服务器间仅仅同步Session就需要占用很大的资源和带宽, 系统不堪重负, 而且每台服务器都保存了这个集群每个用户的Session, 也可能会出现内存不够用的情况, 而且同步需要耗费时间, 有可能出现同步不及时导致的异常情况 Session绑定 负载均衡服务一般自带的有根据来源地址Hash算法来将同一来源的IP请求分发到同一台服务器, 也可以根据Cookie识别, 这个时候负载均衡服务必须工作在HTTP协议层之上, 这样集群中的某个服务器只需保存到达本机的Session即可. 这种又被称作 会话粘滞 但是如果集群中的某个服务器宕机则该机器上面的Session则丢失, 原有的用户被分配到新的服务器, 此时Session丢失, 对业务就产生了影响 利用Cookie记录Session 也有方法是将Session保存在客户端中(以Cookie的形式), 在请求时携带給服务端 这样每次都需要携带Cookie, 影响性能, 同时浏览器可手动阻止Cookie的传输造成请求不正常. Session服务器 推荐的方法是部署一套Session服务器(最好是集群)来管理Session, 每次请求进入业务服务器后服务器根据逻辑去Session服务器请求获取Session再进行逻辑处理即可 对于Session服务器, 简单的方法是使用分布式缓存(redis/…)实现. 但是如果对Session管理有比较高的要求, 比如SSO(单点登录)等可能需要开发专门的Session服务平台 高可用服务 对于基础的公共服务, 大型网站中通常将其独立出来分布式部署来被具体的逻辑应用远程调用, 可复用的服务也是无状态的, 所以可以使用负载均衡技术的失效转移来实现高可用 分级管理 在服务部署时, 将核心的应用和服务优先分配给更好的硬件, 在运维过程中优先级也更高, 比如购物网站, 付款比评论优先级更高 同时在服务的部署上也进行必要的隔离, 避免发生连锁反应. 比如将低优先级的服务部署在虚拟机上, 高优先级的部署在物理机上等 超时设置 设置调用的超时, 如果在指定时间内被调用的服务没有响应, 此时通信框架应抛出异常, 根据服务调度策略重试漷请求转移 异步调用 对于某些业务, 比如注册, 背后可能需要多步操作, 比如像用户邮箱发送注册成功邮件, 开通对应权限等, 其中邮件服务一般是不具有同步性的. 此时应将邮件服务设置为异步调用, 不对整体的服务产生影响 并不是所有的业务都能通过异步来完成, 因此是否使用需要根据具体的业务来判断 服务降级 在网站访问的高峰期, 服务可能会因为大量的请求而导致性能的下降, 严重时可能会引发宕机. 所以为了保证高峰时核心应用和服务的正常运行, 需要对服务进行降级, 一般有拒绝服务和关闭服务两种 拒绝服务 拒绝低优先级的应用调用, 减少调用并发数量, 确保核心应用的正常使用. 当达到并发数量限制时新进入的请求返回错误给客户端. 或者是随机拒绝请求, 随机ban掉一些请求给客户端, Twitter喜欢这样 关闭功能 直接将服务的入口关闭, 或在服务内部关闭, 让所有用户都无法访问该功能, 淘宝在双11时会关闭 评价/确认收货 等功能保证核心服务顺利完成 幂等性设计 当应用调用服务失败时, 会将调用请求重新发送到其他服务器, 但是这个调用失败有可能失败在了中间一步, 有可能逻辑已经走了一半, 此时发送到其他服务器, 其他服务器重新执行流程可能会出现意想不到的问题 但是服务的重复调用是无法避免的, 应用层也不需要关心服务是否真的失败了, 只要没有接收到调用成功的响应即认为失败, 因此必须在服务层保证服务重复调用和调用一次产生的结果相同, 即服务具有 幂等性 高可用的数据 数据是最宝贵的物质资产, 保护网站的数据就是保护网站的命脉 因此数据的存储和高可用对网站很重要, 对于数据的保存, 一般使用专门的数据存储服务器, 当这个数据存储服务器宕机时, 数据的访问请求一般不能任意的切换到其他的数据服务器上 对于数据存储来讲, 一般使用数据的备份和失效转移机制, 数据备份即保证一份数据有多个副本, 任意副本的失效都不会导致数据的永久丢失. 从而实现数据完全的持久化, 失效转移即当一个数据副本不可访问时, 可以快速切换访问数据的其他副本保证系统可用. 对于缓存服务来说, 业内有两种观点, 一种是随着缓存的大量使用, 缓存的数据也成为了网站数据的一部分, 因此缓存也需要和数据一样实现高可用 一种是缓存部署数据存储服务, 缓存服务器宕机引发缓存数据丢失导致服务器压力高应该通过其他手段解决, 因为缓存本来就是只作用于提高访问速度, 而不是存储数据 CAP原理 在讨论高可用数据服务架构之前, 必须先知道, 为了保证数据的高可用, 网站通常会牺牲一定的数据一致性 什么是高可用? 数据持久性 保证数据可以持久的存储, 在任何情况下都不会丢失数据, 即在写入数据时写入到持久性的存储硬件中, 同时将数据备份到多个副本中, 存放在不同的物理硬件上保证数据不丢失 数据可访问性 如果一个数据存储设备损坏, 需要尽快将数据访问切换到另外一个存储设备上, 在切换期间, 该数据无法被访问 数据一致性 在数据有多个副本的情况下, 如果网络出现故障, 导致部分副本数据写入成功, 部分副本失败, 就会导致数据不一致的问题. CAP的C为数据一致性, A为数据可用性, P为分区耐受性(跨网络分区的伸缩性) 需要知道的是, CAP不可能面面俱到 具体来说, 数据一致性分为下面几种 数据强一致性 各个副本的数据在物理存储中总是一致的, 数据的更新操作结果和操作响应总是一致的, 即操作响应通知更新失败时数据一定没有更新, 而不是处于不确定的状态 数据用户一致 数据在物理存储中的各个副本的数据不一定是一致的, 但是用户访问时通过纠错和校验机制, 可以确定一个一致的正确的数据返回给用户 数据最终一致 这是数据一致性中比较弱的一种, 即物理存储的数据可能是不一致的, 终端用户访问到的数据也可能是不一致的, 但是系统经过一段时间的自我修正后数据会最终一致 因为现实情况里很难满足数据的强一致性, 所以网站通常会综合成本/技术/业务场景等条件综合考虑来保障数据的正确性 数据备份 数据备份是最有效的数据保护手段, 早期的数据备份手段是冷备份, 即定期将数据复制到某种物理的存储介质中并存档保管, 如果系统存储损坏泽从冷备份的数据中恢复 冷备的优点是简单和廉价, 成本和技术难度都较低, 缺点则是无法保证数据的最终一致性, 由于数据是定期复制, 导致备份中的火速句永远比系统的数据陈旧. 如果系统的数据丢失, 那么从上次备份到系统数据损坏中的数据会永久丢失, 不能从备份中恢复. 同时也无法保证数据可用性, 而且从冷备份中恢复数据需要时间较长, 并且恢复中时无法访问数据, 系统也不可用 因此, 数据的冷备份作为一种传统的方案, 依然在使用, 但是还需要热备份双管齐下以提高数据的可用性 热备份可分为两种: 异步热备份与同步热备份 异步热备 异步指多份数据副本的写入操作异步完成, 应用程序收到数据服务系统返回成功时, 实际上只写成了一份, 然后再异步的同步到其他副本中(也有可能会失败) 在异步的情况下, 存储服务器分为主存储和从存储, 正常情况下应用只链接主存储服务器, 数据写入时写入到主存储中, 然后返回成功, 再异步的同步到从存储服务器中 同步热备 每份数据副本同时写入成功后再返回成功, 也有可能出现写入失败其实已经有几个成功的情况 为了提高速度, 应用程序在接收到指令后同时向多个存储服务器写入数据, 等待所有存储服务器都返回成功后再通知程序写入成功 此种情况下, 存储服务器之间没有主次之分, 完全对等, 便于管理和维护. 失效转移 若数据服务器集群中的其中一个服务器宕机, 那么应用程序针对这个服务器的所有读写操作都需要重新路由到其他的机器, 保证数据访问不失败, 这个过程叫做失效转移, 失效转移一般分下面几步 失效确认 系统首先要确认这个服务器是否宕机, 大多是有两种: 心跳检测和应用程序访问失败报告 一般的, 如果应用程序报告访问失败, 控制中心还需要发送一次心跳进行确认, 避免一次错误的判断导致触发失效转移, 因为失效转移过程复杂 访问转移 确认某台服务器宕机后, 就需要将数据读写的访问请求重新路由到其他正常的服务器上, 如果存储服务器之间完全对等, 其中一台宕机可根据配置重新切换到对等的服务器上. 如果存储不对等, 则需要重新计算出对等的路由选择存储服务器 数据恢复 某台服务器宕机后, 数据存储的副本数量 -1, 应当在后续将副本的数量恢复上, 才能保证访问转移 高可用的网站软件质量保证 在网站的实践中, 除了硬件可能导致的风险外, 还有软件本身的问题 网站发布 网站通常需要保证 7X24 的高可用运行, 同时网站需要不断的发布新功能来吸引用户以维持运营, 很多网站需要一周发布一到两个版本, 在刚上线的时期可能更加的频繁 不管发布的功能是修改了一个按钮布局还是增加一个业务, 都需要关闭原有的应用在重新部署新的应用再启动, 相当于给飞行中的飞机更换一个引擎, 既不能让飞机有剧烈的晃动(影响用户体验), 也不能让飞机降落(停机维护), 也不能让飞机坠毁(宕机) 网站的发布的过程其实和网站的服务器宕机效果一致, 对其系统可用性的影响也差不多, 所以在设计之初就需要考虑服务器宕机其实不是概率上的一年一两次, 而是快速迭代造成的一周一两次, 那么用户可以接受一周一两次的宕机吗? 对于网站的发布来说, 在发布之前肯定可以提前预知到服务器会宕机, 所以针对发布, 我们可以预先制定好流程来尽量减少对用户的影响 一半采用分批更新的策略, 一次更新一小批服务器, 更新完成后再将其重新加入到负载均衡中供使用 自动化测试 代码在发布到线上之前需要进行严格的测试, 测试一般需要的时间和人力较多, 我们也可以使用自动化测试来减少一些人工的工作量 目前大部分网站都适用自动化测试技术, 比如网站端使用 Selenium 技术模拟访问和点击, 大型网站也会自己开发测试工具 预发布验证 在自动化测试和测试人员测试完成后, 还需要进行预发布验证, 因为线上环境多种多样, 并不能保证一定不出问题, 所以也需要预发布验证的步骤 在网站发布时, 并不是直接发布到线上服务器, 而是先发布到预发布服务器, 由开发工程师和测试工程师进行验证, 即执行一些典型的业务流程, 确定无问题再发布 预发布服务器应与正式服务器一致, 唯一的不同就是预发布服务器无法被外网用户访问 因为预发布环境与正式环境连接的同一个数据库, 一些操作可能会引起正式环境的数据出现问题, 因此必须注意 代码控制 对于大型网站, 核心应用系统和公用业务系统涉及到多个团队和开发工程师, 很大概率会一个项目由多个团队参与的情况, 如果代码控制环节出现问题会导致系统故障 网站代码控制核心是如何进行代码管理, 即能保证代码稳定又能保证不同团队直接开发互不影响 一般的使用GIT来进行版本控制 一般使用 git flow 的形式来进行版本管理 自动发布 网站的版本发布频繁, 发布过程需要很多团队一起合作, 首先在发布前可能会出现代码冲突, 其次, 各个团队之间的逻辑也可能出现了变化, 发布又相当于一次宕机事故, 因此网站的发布过程险象环生 一般的会将更新日期放在周三或周四, 这是因为发布之前的时间可以用来准备, 发布后留有一到两天时间可以修复问题 有人提出了一个 火车发布模型 ,即将每一次发布都看作是一次火车旅行, 每个修改的功能点视作旅行间的站台, 发布时对每一站都进行检查, 不通过的则不向车上装载, 确保到达终点时车上都是通过检查的功能 然而理想很美好, 现实中有可能会出现所有都有问题的现象, 或者某个功能点是领导迫切需要的, 其他的必须等着他等等问题 因为火车发布模型是基于规则的, 所以这个流程可以做到自动化, 自动构建代码分支来进行自动化测试和合并 灰度发布 自动化测试并不是万能的, 有的问题只有到了线上才能暴露出来, 这个时候就需要回滚, 即将老的版本上线, 等待开发人员修复问题, 但是大型网站的集群规模庞大, 回滚是很难的事情, 所以一般会进行灰度发布 即将集群分为很多部分, 第一次上一点点服务器, 查看问题是否出现, 没发现问题再上另一点点服务器, 一直到稳定后再全部更新, 如果发现问题回滚的机器就不多了 有时候, 上线一个新的功能, 可能有多个版本, 需要查看用户的反馈再决定上哪一个版本,此时就需要给一部分人看某个版本, 这也是小批量的, 业内称为 AB 测试, 其逻辑和灰度差不多 网站运行监控 网站的运行监控对于网站的结构和运维极为重要 监控数据采集 网站监控是一个广义的概念, 其包括了很多种类 用户行为日志 指用户在浏览器上做的所有操作及其所在的环境,包括 浏览器版本/OS/IP/地址/网络运营商/访问路径/停留时间 等等,这些数据可以统计出 PV/UV, 分析用户行为, 优化网站设计等, 搜集日志分为两个途径 服务端搜集: 负载均衡都带有日志系统, 所以很简单, 但是有些信息并不是真实的, 比如爬虫可以伪造请求参数 客户端搜集: 一般使用JS来记录和回传, 但是这样对服务器的压力很大, 因为是客户端搜集所以比服务端可靠性高, 因为并发很大所以一般使用分布式实时计算框架 Strom 来做或者是基于 Storm 自己开发 服务器性能监控 搜集服务器的实时 内存/CPU 等信息, 方便运维人员查看, 一般带有自动报警机制 比较出名的框架有 Ganglia 运行数据报告 比如缓存命中率/平均响应时间等数据,一般由运维人员部署 监控管理 监控的目的并不是简单的看, 还需要更加自动化 系统报警 当监控系统检测到某个指标超出阀值, 会向指定的邮箱发送告警邮件, 更高级的还有手机短信/语言等 失效转移 当某个服务器发生问题时, 自动的通知调度系统将此服务器下线 自动降级 当负载很高时, 通知调度系统将其服务降级或者暂时关闭","link":"/2021/09/04/website_architecture(3)/"},{"title":"zap包简单使用","text":"zap 是 uber 开源的一个日志记录的包, uber 在 go 的领域建树颇多, zap 更是优秀, 相比于自带的 log ,他有更多的功能, 当然, 最显眼的还是他很快, 本文介绍 zap 模块的基本使用 简单使用 zap的使用由 编码器 和 初始化 组成, 编码器表示输出的格式, DEMO如下(使用默认的编码器) 1234567891011package toolimport ( \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\")// Log zapLog对象var Log *zap.LoggerLog, _ = zap.NewProduction() 使用方法为直接调用生成的 Log, 比如 123456_, err := tools.DB.Exec(sqlStr, formPassWord, time.Now(), formPhone)if err != nil { tools.Log.Error(\"1002\", zap.Error(err)) // log tools.FormatError(c, 1002, \"error\") return} 将日志保存在本地 如果项目有日志服务进行日志收集那么到这里就结束了, 如果需要将日志写在本地你还需要看下去 我们使用第三方包来达到这个效果 lumberjack 该包可以自己进行日志的切割, 避免日志推挤过多, 当然你不需要日志切割等高级功能的话你完全可以直接使用 os.Create 来适配 结合 zap 使用如下 1234567891011121314151617181920212223242526272829303132333435363738394041package toolsimport ( \"github.com/natefinch/lumberjack\" \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\")// Log zapLog对象var Log *zap.Logger// 日志切割设置func getLogWriter() zapcore.WriteSyncer { lumberJackLogger := &amp;lumberjack.Logger{ Filename: \"api.log\", // 日志文件位置 MaxSize: 10, // 日志文件最大大小(MB) MaxBackups: 5, // 保留旧文件最大数量 MaxAge: 30, // 保留旧文件最长天数 Compress: false, // 是否压缩旧文件 } return zapcore.AddSync(lumberJackLogger)}// 编码器func getEncoder() zapcore.Encoder { // 使用默认的JSON编码 encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewJSONEncoder(encoderConfig)}// InitLogger 初始化Loggerfunc InitLogger() { writeSyncer := getLogWriter() encoder := getEncoder() core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) Log = zap.New(core, zap.AddCaller())} 使用方法与上方一致 Log.Error 代表生成一条 Error 的log, 参数一是 msg 内容, 这个是自定义的, 根据团队的规范来, 参数二是 err 信息, 使用 zap.Error 包装可生成额外的信息比如报错的路径/文件/行 等信息, 输出的日志类似 1{\"level\":\"ERROR\",\"ts\":\"2020-04-19T12:38:14.587+0800\",\"caller\":\"property/view.go:464\",\"msg\":\"1002\",\"error\":\"Error 1054: Unknown column 'propertyid' in 'on clause'\"}","link":"/2021/09/04/zap/"},{"title":"身份证号码缩小方案","text":"前言 最近拿到了比较心怡的 offer, 苏州某旅游集团的, 感觉对自己的成长较大, 还是相对满意的 当然了, 成长大, 其实也是挑战大, 所以以后要更加的努力了, 加油 本篇文章是水群里有人问怎么把身份证号(18位)压缩成更少的位数, 群里大佬真的牛批, 说能压到6位, 并大致简述了一下思路, 我觉得还是可行的. 于是自己抄袭思路实现了一下功能, 测试了一下, 可以压缩到6-7位, 应该有更好的压缩方法, 这里只是记录一下我自己的版本 局限 这里我想提前说的是, 在真正的开发中, 极少数需要对身份证号码进行压缩的, 因为节省了空间, 带来的是很差的可读性, 而且对于一些数据筛选更是困难, 这里也仅仅是做参考和示例使用 思路 号码结构 对于身份证号码, 百度上有很多组成部分的解析, 这里摘抄一下百度百科公民身份证号码_百度百科 (baidu.com) 1．号码的结构 公民身份号码是特征组合码，由十七位数字本体码和一位校验码组成。排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 2．地址码 表示编码对象常住户口所在县（市、旗、区）的行政区划代码，按GB/T2260的规定执行。 3．出生日期码 表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日代码之间不用分隔符。 4．顺序码 表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。 5．校验码 根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。 以身份证号码130424200208110128 来讲, 其分为几部分: 130424: 地址码 20020811: 出生年月日 012: 出生顺序和性别 8: 校验码 地址码 我们一步步来尝试压缩, 首先是地址码, 地址码在身份证号码中占据了6位, 地址码既然是标记了出生地, 那么就不可能是随机的, 其实中国很大, 我相信地址码也不会有999999个, 于是我查询了相关资料, 找到了民政部的公开资料www.mca.gov.cn/article/sj/xzqh/2020/20201201.html, 稍微查看了一下有不超过4000个, 因此, 如果我们自己设置一个映射关系, 比如将地址码654202在数据库中设置一个唯一 id, 因为总共不超过4000个, 因此 id 最长也4位, 这样就可以减少2位 ###出生日期码 出生日期, 在身份证中占据了6位, 分别是YYYYMMDD, 这个怎么去优化呢? 有大佬认为可以将年的前两位分为2种19/20, 然后月的第一位只有两种0/1, 日的第一位只有0/1/2/3, 这几个可以按位存储 我认为, 这样比较复杂, 而且19/20范围太小了, 我的思路是, 将其按照天数存储, 例如, 19000102可以存储为0000001, 即存储从1900年0101开始到该用户出生日期的天数, 设计为最长7位, 我测试了一下, 支持到8888年也没有问题, 这样极大的提高了兼容性, 这里减少1位 顺序码 顺序码, 记录了顺序和性别, 思考了一下, 感觉这里无从下手, 于是顺序码没有进行简化 校验码 校验码本身占用一位, 但是校验码我查看了一下, 是通过前17位数字计算得来的, 计算规则为身份证校验码计算公式及实例计算-百度经验 (baidu.com): 第一步：将身份证号码的第1位数字与7相乘；将身份证号码的第2位数字与9相乘；将身份证号码的第3位数字与10相乘；将身份证号码的第4位数字与5相乘；将身份证号码的第5位数字与8相乘；将身份证号码的第6位数字与4相乘；将身份证号码的第7位数字与2相乘；将身份证号码的第8位数字与1相乘；将身份证号码的第9位数字与6相乘；将身份证号码的第10位数字与3相乘；将身份证号码的第11位数字与7相乘；将身份证号码的第12位数字与9相乘；将身份证号码的第13位数字与10相乘；将身份证号码的第14位数字与5相乘；将身份证号码的第15位数字与8相乘；将身份证号码的第16位数字与4相乘；将身份证号码的第17位数字与2相乘。 第二步：将第一步身份证号码1~17位相乘的结果求和，全部加起来。 第三步：用第二步计算出来的结果除以11，这样就会出现余数为0，余数为1，余数为2，余数为3，余数为4，余数为5，余数为6，余数为7，余数为8，余数为9，余数为10共11种可能性。 第四步：如果余数为0，那对应的最后一位身份证的号码为1；如果余数为1，那对应的最后一位身份证的号码为0；如果余数为2，那对应的最后一位身份证的号码为X；如果余数为3，那对应的最后一位身份证的号码为9；如果余数为4，那对应的最后一位身份证的号码为8；如果余数为5，那对应的最后一位身份证的号码为7；如果余数为6，那对应的最后一位身份证的号码为6；如果余数为7，那对应的最后一位身份证的号码为5；如果余数为8，那对应的最后一位身份证的号码为4；如果余数为9，那对应的最后一位身份证的号码为3；如果余数为10，那对应的最后一位身份证的号码为2。 既然是计算的, 那么这里的校验位存储时可以舍去, 等还原时再进行计算和填充, 这里减少1位 进制转换 走到这里, 我们发现, 只减少了4位, 剩下14位, 还要怎么压缩呢? 这里使用大杀器, 进制转换 众所周知, 从低进制向高进制进行转换, 可以减少位数, 因为高进制每一位可以表示更多种数据可能, 这里不考虑数据库等等的兼容性, 直接使用 ascii 的所有可见字符, 94个, 也就是说将身份证号码转换为94进制, 达到压缩的目的 代码 当然是写完代码才有的这一个博客输出的喽, 地址码 地址码这里, 虽然翻看了 github 上有别人抓好的数据, 但是看更新日志有些年头了, 于是我自己写了一个 py 脚本, 进行数据抓取并保存在本地的 sqlite 文件中, py 文件如下(脚本依赖 python3) 依赖如下: 12beautifulsoup4==4.10.0requests==2.27.0 脚本代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import codeimport loggingimport sqlite3import requestsfrom bs4 import BeautifulSoup# 中华人民共和国民政部官网-&gt;民政数据-&gt;行政区划代码mca_url = \"http://www.mca.gov.cn/article/sj/xzqh/2020/20201201.html\"logger = logging.getLogger()logger.setLevel(logging.DEBUG)def get_response(): # 获取行政区划网页数据 response = requests.get(url=mca_url) if response.status_code != 200: logger.warning(\"获取数据时出现问题, 网页返回状态码: %s\" % response.status_code) return return response.contentdef parse_response(content: str): # 解析response soup = BeautifulSoup(content, \"html.parser\") tab = soup.find(name=\"table\") if not tab: logger.warning(\"解析失败, 没有找到 table 元素\") return trs = tab.find_all(name=\"tr\") if len(trs) == 0: logger.warning(\"解析失败, 没有找到 tr 元素\") return codes = [] for i in range(len(trs)): if i &lt;= 2: # 前3行是标题 continue tds = trs[i].find_all(name=\"td\") if len(tds) &lt; 2: continue code = tds[1].get_text().strip() # 真实的区域码 if not code: continue code = int(code) name = tds[2].get_text().strip() # 区域名 id = i-2 # id codes.append((id, code, name)) return codesdef insert_db(codes: list): con = sqlite3.connect(\"area.sqlite\") cur = con.cursor() sql = \"\"\" CREATE TABLE \"area\" ( \"id\" INTEGER NOT NULL, \"code\" integer, \"name\" TEXT, PRIMARY KEY (\"id\") ); \"\"\" cur.execute(sql) sql = \"\"\" CREATE UNIQUE INDEX \"code\" ON \"area\" ( \"code\" ); \"\"\" cur.execute(sql) cur.executemany('INSERT INTO area VALUES (?,?,?)', codes) con.commit() # 关闭游标 cur.close() # 断开数据库连接 con.close()def main(): content = get_response() codes = parse_response(content) insert_db(codes)if __name__ == \"__main__\": main() 简单的爬虫脚本, 但是网页不规范(ZF 网站通病), 导致做了很多的兼容处理 执行完成后, 会在本地生成area.sqlite文件 而我们使用 go 进行 sqlite 文件的读取, 纯纯的读取而不是修改和插入, 对于读取, 需要有两个方法, 当压缩时, 我们需要通过地址码来获取对应的 id, 在解压时, 需要通过 id 获取对应的地址码, 下面是area.go: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/mattn/go-sqlite3\")// sqlitetype SqliteConn struct { file string conn *sql.DB}// 初始化func InitSqlite(file string) (*SqliteConn, error) { return &amp;SqliteConn{ file: file, }, nil}// 连接func (c *SqliteConn) Conn() error { db, err := sql.Open(\"sqlite3\", c.file) if err != nil { return err } c.conn = db return nil}// 关闭连接func (c *SqliteConn) Close() { c.conn.Close()}// 获取 codefunc (c *SqliteConn) GetCode(id int) (int, error) { code := 0 sql := \"SELECT code FROM area WHERE id=?\" row := c.conn.QueryRow(sql, id) if row.Err() != nil { return code, fmt.Errorf(\"未查询到数据\") } if err := row.Scan(&amp;code); err != nil { return code, fmt.Errorf(\"数据解析错误\") } return code, nil}// 获取 IDfunc (c *SqliteConn) GetID(code int) (int, error) { id := 0 sql := \"SELECT id FROM area WHERE code=?\" row := c.conn.QueryRow(sql, code) if row.Err() != nil { return id, fmt.Errorf(\"未查询到数据\") } if err := row.Scan(&amp;id); err != nil { return id, fmt.Errorf(\"数据解析错误\") } return id, nil} 出生日期码 出生日期码, 也是两个方法, 一个是将日期转成从19700101到指定日期的天数, 一个是根据天数算出日期 这里需要注意的是, 使用Sub方法, 不能进行很长的时间间隔计算, 其文档所述Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d)., 所以这里按照250年进行切分, 解决日期差距过长导致的计算错误 time2.go文件如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( \"fmt\" \"strconv\" \"time\")func time2Day(startTime, endTime time.Time) int { // 因为官方的 time.Add/Sub 最多只能29X 年, 所以自己实现一个, 250年一个循环 maxYear := 250 day := 0 for { middleTime := startTime.AddDate(maxYear, 0, 0) if endTime.Sub(middleTime).Hours() &gt; 0 { // 还没有到 day += int(middleTime.Sub(startTime).Hours()) / 24 startTime = middleTime } else { // 到了 day += int(endTime.Sub(startTime).Hours()) / 24 break } } return day}func Time2Day(Y, M, D string) (int, error) { // 转换时间 // 将时间转换成从1900年1月1日之后的天数 eTm, err := time.Parse(\"2006-01-02\", fmt.Sprintf(\"%v-%v-%v\", Y, M, D)) if err != nil { return 0, err } sTm, err := time.Parse(\"2006-01-02\", \"1900-01-01\") if err != nil { return 0, err } subD := time2Day(sTm, eTm) if subD &gt; 9999999 { // 防止特别大做的天数限制 return 0, fmt.Errorf(\"year exceeding the limit\") } return subD, nil}func Day2Time(d string) (string, error) { // 转换时间 // 从1900年1月1日之后的天数转换成时间 sTm, err := time.Parse(\"2006-01-02\", \"1900-01-01\") if err != nil { return \"\", err } subD, _ := strconv.Atoi(d) nTm := sTm.AddDate(0, 0, subD) snTm := fmt.Sprintf(\"%v%v%v\", nTm.Year(), func(ntm time.Time) string { if int(nTm.Month()) &lt; 10 { // 对1位月份兼容 return fmt.Sprintf(\"0%v\", int(ntm.Month())) } return fmt.Sprintf(\"%v\", int(ntm.Month())) }(nTm), func(ntm time.Time) string { if nTm.Day() &lt; 10 { // 对1位日期做兼容 return fmt.Sprintf(\"0%v\", ntm.Day()) } return fmt.Sprintf(\"%v\", ntm.Day()) }(nTm)) return snTm, nil} 校验码计算 校验码计算按照上面的百度说的方式, 先进行相乘, 然后进行整除, 求余数进行对应 validate.go代码如下 1234567891011121314151617181920package mainimport \"fmt\"var validate = [11]string{\"1\", \"0\", \"X\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\"}var base = [17]int{7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2}func CalculteValidateCode(IDCard string) (string, error) { validateCode := \"\" count := 0 if len(IDCard) != len(base) { return validateCode, fmt.Errorf(\"not find on base\") } for i, v := range IDCard { bv := base[i] count += bv * int(v-48) } return validate[count%11], nil} 这里有趣的是, 利用遍历字符串, 每个元素是其ASCII的编号的特征, 使其-48来计算得出真实的数字 进制转换 go 虽然本身自带了进制转换, 但是最高支持32位, 并不支持94位, 其实进制转换超过32位也不常见, 据我所知只有短网址生成需要64进制, 这里只能自己实现一个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"fmt\" \"math\" \"strings\")// 拼接 ascii 字符串func initAsciiString(start, end int) (string, error) { compare := \"\" if start &gt; end { return compare, fmt.Errorf(\"error\") } for i := start; i &lt;= end; i++ { compare = compare + fmt.Sprintf(\"%v\", string(rune(i))) } return compare, nil}type Conver struct { asciiString string len int}func InitConver(asciiString string) (*Conver, error) { return &amp;Conver{ asciiString: asciiString, len: len(asciiString), }, nil}// 十进制转任意进制func (c *Conver) Num2BHex(num int) string { num_str := \"\" for num != 0 { yu := num % c.len num_str = string(c.asciiString[yu]) + num_str num = num / c.len } return num_str}// 任意进制转十进制func (c *Conver) BHex2Num(str string) int { v := 0.0 length := len(str) for i := 0; i &lt; length; i++ { s := string(str[i]) index := strings.Index(c.asciiString, s) v += float64(index) * math.Pow(float64(c.len), float64(length-1-i)) // 倒序 } return int(v)} 压缩 为了一定程度的规范代码, 我会将身份证先进行分割, 保存到结构体中, 压缩的主要流程, 在complex2simple.go中 在编写代码中, 遇到过两个问题: 地区对应编号可能不足4位 比如说编号110101, 对应的是北京市东城区, 他的 id 是2, 但是 id 最长有可能是4位, 不足的话在前面填充0又感觉麻烦(比如2变成0002), 于是查看了一下目前的数据为3209条, 将 id 存储时变为5000-id, 这样保证永远占用4位, 解码时记得处理即可 压缩日期这里, 有可能不足7位 对于比较小的日期, 算出来天数, 有可能不足7位, 如果在前加入0填充, 又稍微麻烦点, 设置最高值也可以, 但是有一种办法更省力, 那就是把日期挪到最后, 地区确定4位, 顺序码3位, 剩下的全部都是天数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package mainimport ( \"fmt\" \"strconv\")type IDCardSplit struct { AreaCode string Year string Month string Day string Order string Validate string}// 切分身份证func splitID(ID string) (IDCardSplit, error) { // 切分原始身份证, 剥离出地区码和校验码 IDS := IDCardSplit{} for i, v := range ID { switch { case i &lt;= 5: IDS.AreaCode += string(v) case i &gt; 5 &amp;&amp; i &lt;= 9: IDS.Year += string(v) case i &gt; 9 &amp;&amp; i &lt;= 11: IDS.Month += string(v) case i &gt; 11 &amp;&amp; i &lt;= 13: IDS.Day += string(v) case i &gt; 13 &amp;&amp; i &lt;= 16: IDS.Order += string(v) case i == 17: IDS.Validate = string(v) } } return IDS, nil}func Complex2Simple(IDC string) (string, error) { sID, _ := splitID(IDC) simpleSID := \"\" // 初始化 sqlite 数据库 con, err := InitSqlite(\"area.sqlite\") if err != nil { fmt.Println(err) return simpleSID, err } // 连接数据库 if err := con.Conn(); err != nil { fmt.Println(err) return simpleSID, err } defer con.Close() // 转换地区码为 int areaCode, err := strconv.Atoi(sID.AreaCode) if err != nil { fmt.Println(err) return simpleSID, err } // 获取 areaID areaID, err := con.GetID(areaCode) if err != nil { fmt.Println(err) return simpleSID, err } d, err := Time2Day(sID.Year, sID.Month, sID.Day) if err != nil { return simpleSID, err } simpleSID = fmt.Sprintf(\"%v%v%v\", maxAreaID-areaID, sID.Order, d) simpleID, _ := strconv.Atoi(simpleSID) asciiString, err := initAsciiString(33, 126) // 所有可见 ascii, 94个 if err != nil { fmt.Println(err) return simpleSID, err } conver, _ := InitConver(asciiString) s := conver.Num2BHex(simpleID) return s, nil} 解压缩 与压缩基本相反, 需要注意的是顺序发生了调整, 另外, 在通过 id 获取地区码时, 注意要先使用5000-id得出真正的 id simple2complex.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport ( \"fmt\" \"strconv\")type IDCardSimpleSplit struct { AreaID string SubDay string Order string}// 切分simple 字符串func splitSimple(simple string) (IDCardSimpleSplit, error) { // 切分 simple IDS := IDCardSimpleSplit{} for i, v := range simple { switch { case i &lt;= 3: IDS.AreaID += string(v) case i &gt; 3 &amp;&amp; i &lt;= 6: IDS.Order += string(v) case i &gt; 6: IDS.SubDay += string(v) } } return IDS, nil}func Simple2Complex(simpleID string) (string, error) { complexID := \"\" asciiString, err := initAsciiString(33, 126) // 所有可见 ascii, 94个 if err != nil { fmt.Println(err) return complexID, err } conver, _ := InitConver(asciiString) s := conver.BHex2Num(simpleID) sID, err := splitSimple(fmt.Sprintf(\"%v\", s)) if err != nil { fmt.Println(err) return complexID, err } // 初始化 sqlite 数据库 con, err := InitSqlite(\"area.sqlite\") if err != nil { fmt.Println(err) return complexID, err } // 连接数据库 if err := con.Conn(); err != nil { fmt.Println(err) return complexID, err } defer con.Close() // 转换地区码为 int areaSID, err := strconv.Atoi(sID.AreaID) if err != nil { fmt.Println(err) return complexID, err } // 获取 areaID areaID, err := con.GetCode(maxAreaID - areaSID) if err != nil { fmt.Println(err) return complexID, err } snTm, err := Day2Time(sID.SubDay) if err != nil { return complexID, err } complexID = fmt.Sprintf(\"%v%v%v\", areaID, snTm, sID.Order) validate, _ := CalculteValidateCode(complexID) complexID = complexID + validate return complexID, nil} 测试 main.go如下 12345678910111213141516171819package mainimport ( \"fmt\" _ \"github.com/mattn/go-sqlite3\")var maxAreaID = 5000func main() { IDC := \"411503211208110123\" // 原始的身份证号码 simple, err := Complex2Simple(IDC) fmt.Println(err) fmt.Println(simple) c, err := Simple2Complex(simple) fmt.Println(err) fmt.Println(c)} 运行 12345➜ task_test go run .&lt;nil&gt;NtnBRM&lt;nil&gt;411503211208110123 写在最后 虽然想法比较简单, 但是实现起来还是有些复杂的, 包括日期的转换, 进制计算这些, 也算是受益良多 下次实现一个64进制的短网址 DEMO 吧","link":"/2022/03/08/zip_id_card/"}],"tags":[{"name":"架构","slug":"架构","link":"/tags/%E6%9E%B6%E6%9E%84/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"源码分析","slug":"源码分析","link":"/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"做好自己","slug":"做好自己","link":"/tags/%E5%81%9A%E5%A5%BD%E8%87%AA%E5%B7%B1/"},{"name":"心理学","slug":"心理学","link":"/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"逻辑学","slug":"逻辑学","link":"/tags/%E9%80%BB%E8%BE%91%E5%AD%A6/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"好玩的技术","slug":"好玩的技术","link":"/tags/%E5%A5%BD%E7%8E%A9%E7%9A%84%E6%8A%80%E6%9C%AF/"}],"categories":[{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"人生","slug":"人生","link":"/categories/%E4%BA%BA%E7%94%9F/"}],"pages":[{"title":"关于我","text":"格言 知识 知识就是力量, 是成功不可或缺的基础 实践 实践出真知, 否则永远是纸上谈兵, 现实往往更为复杂 灵感 灵感就在那一瞬间, 努力抓住它 机遇 人生充满机遇, 但是机会总是留给有准备的人","link":"/about/index.html"}]}